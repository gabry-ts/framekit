{"version":3,"file":"browser-B9MCPMmA.js","sources":["../src/shims/os.ts","../../../dist/browser.js"],"sourcesContent":["// Browser shim for Node.js 'os' module\n// Only the subset used by framekit-js/browser is implemented\n\nexport function cpus(): { model: string }[] {\n  const count =\n    typeof navigator !== 'undefined' && navigator.hardwareConcurrency\n      ? navigator.hardwareConcurrency\n      : 2;\n  return Array.from({ length: count }, () => ({ model: 'browser' }));\n}\n\nexport function platform(): string {\n  return 'browser';\n}\n\nexport function arch(): string {\n  return 'unknown';\n}\n\nexport function tmpdir(): string {\n  return '/tmp';\n}\n\nexport const EOL = '\\n';\n\nexport default { cpus, platform, arch, tmpdir, EOL };\n","// src/types/dtype.ts\nvar DType = /* @__PURE__ */ ((DType2) => {\n  DType2[\"Float64\"] = \"f64\";\n  DType2[\"Int32\"] = \"i32\";\n  DType2[\"Int64\"] = \"i64\";\n  DType2[\"Utf8\"] = \"utf8\";\n  DType2[\"Boolean\"] = \"bool\";\n  DType2[\"Date\"] = \"date\";\n  DType2[\"DateTime\"] = \"datetime\";\n  DType2[\"Null\"] = \"null\";\n  DType2[\"BigInt\"] = \"bigint\";\n  DType2[\"Object\"] = \"object\";\n  return DType2;\n})(DType || {});\n\n// src/errors.ts\nvar ErrorCode = /* @__PURE__ */ ((ErrorCode2) => {\n  ErrorCode2[\"COLUMN_NOT_FOUND\"] = \"COLUMN_NOT_FOUND\";\n  ErrorCode2[\"TYPE_MISMATCH\"] = \"TYPE_MISMATCH\";\n  ErrorCode2[\"SHAPE_MISMATCH\"] = \"SHAPE_MISMATCH\";\n  ErrorCode2[\"PARSE_ERROR\"] = \"PARSE_ERROR\";\n  ErrorCode2[\"IO_ERROR\"] = \"IO_ERROR\";\n  ErrorCode2[\"OUT_OF_MEMORY\"] = \"OUT_OF_MEMORY\";\n  ErrorCode2[\"INVALID_OPERATION\"] = \"INVALID_OPERATION\";\n  return ErrorCode2;\n})(ErrorCode || {});\nvar FrameKitError = class extends Error {\n  code;\n  constructor(code, message) {\n    super(message);\n    this.name = \"FrameKitError\";\n    this.code = code;\n  }\n};\nvar ColumnNotFoundError = class extends FrameKitError {\n  constructor(column, available) {\n    super(\n      \"COLUMN_NOT_FOUND\" /* COLUMN_NOT_FOUND */,\n      `Column '${column}' not found. Available columns: [${available.join(\", \")}]`\n    );\n    this.name = \"ColumnNotFoundError\";\n  }\n};\nvar TypeMismatchError = class extends FrameKitError {\n  constructor(message) {\n    super(\"TYPE_MISMATCH\" /* TYPE_MISMATCH */, message);\n    this.name = \"TypeMismatchError\";\n  }\n};\nvar ShapeMismatchError = class extends FrameKitError {\n  constructor(message) {\n    super(\"SHAPE_MISMATCH\" /* SHAPE_MISMATCH */, message);\n    this.name = \"ShapeMismatchError\";\n  }\n};\nvar ParseError = class extends FrameKitError {\n  constructor(message) {\n    super(\"PARSE_ERROR\" /* PARSE_ERROR */, message);\n    this.name = \"ParseError\";\n  }\n};\nvar IOError = class extends FrameKitError {\n  constructor(message) {\n    super(\"IO_ERROR\" /* IO_ERROR */, message);\n    this.name = \"IOError\";\n  }\n};\n\n// src/storage/bitarray.ts\nvar BitArray = class _BitArray {\n  _buffer;\n  _length;\n  constructor(length, initialValue = false) {\n    if (length < 0) {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `BitArray length must be non-negative, got ${length}`\n      );\n    }\n    this._length = length;\n    const byteCount = Math.ceil(length / 8);\n    this._buffer = new Uint8Array(byteCount);\n    if (initialValue) {\n      this._buffer.fill(255);\n    }\n  }\n  get length() {\n    return this._length;\n  }\n  get byteLength() {\n    return this._buffer.byteLength;\n  }\n  get(index) {\n    this._boundsCheck(index);\n    return this.getUnsafe(index);\n  }\n  getUnsafe(index) {\n    const byteIndex = index >> 3;\n    const bitIndex = index & 7;\n    return (this._buffer[byteIndex] & 1 << bitIndex) !== 0;\n  }\n  set(index, value) {\n    this._boundsCheck(index);\n    this.setUnsafe(index, value);\n  }\n  setUnsafe(index, value) {\n    const byteIndex = index >> 3;\n    const bitIndex = index & 7;\n    if (value) {\n      this._buffer[byteIndex] = this._buffer[byteIndex] | 1 << bitIndex;\n    } else {\n      this._buffer[byteIndex] = this._buffer[byteIndex] & ~(1 << bitIndex);\n    }\n  }\n  countOnes() {\n    let count = 0;\n    for (let i = 0; i < this._length; i++) {\n      if (this.get(i)) {\n        count++;\n      }\n    }\n    return count;\n  }\n  countZeros() {\n    return this._length - this.countOnes();\n  }\n  and(other) {\n    this._lengthCheck(other);\n    const result = new _BitArray(this._length);\n    for (let i = 0; i < this._buffer.length; i++) {\n      result._buffer[i] = this._buffer[i] & other._buffer[i];\n    }\n    return result;\n  }\n  or(other) {\n    this._lengthCheck(other);\n    const result = new _BitArray(this._length);\n    for (let i = 0; i < this._buffer.length; i++) {\n      result._buffer[i] = this._buffer[i] | other._buffer[i];\n    }\n    return result;\n  }\n  clone() {\n    const result = new _BitArray(this._length);\n    result._buffer.set(this._buffer);\n    return result;\n  }\n  not() {\n    const result = new _BitArray(this._length);\n    for (let i = 0; i < this._buffer.length; i++) {\n      result._buffer[i] = ~this._buffer[i] & 255;\n    }\n    return result;\n  }\n  _boundsCheck(index) {\n    if (index < 0 || index >= this._length) {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `BitArray index ${index} out of bounds for length ${this._length}`\n      );\n    }\n  }\n  _lengthCheck(other) {\n    if (this._length !== other._length) {\n      throw new FrameKitError(\n        \"SHAPE_MISMATCH\" /* SHAPE_MISMATCH */,\n        `BitArray length mismatch: ${this._length} vs ${other._length}`\n      );\n    }\n  }\n};\n\n// src/storage/column.ts\nvar Column = class {\n  _nullMask;\n  _length;\n  _refCount = 1;\n  constructor(length, nullMask) {\n    this._length = length;\n    this._nullMask = nullMask ?? new BitArray(length, true);\n  }\n  get length() {\n    return this._length;\n  }\n  get nullCount() {\n    return this._nullMask.countZeros();\n  }\n  addRef() {\n    this._refCount++;\n  }\n  release() {\n    if (this._refCount > 0) {\n      this._refCount--;\n    }\n  }\n  get refCount() {\n    return this._refCount;\n  }\n  get isShared() {\n    return this._refCount > 1;\n  }\n};\n\n// src/storage/numeric.ts\nvar Float64Column = class _Float64Column extends Column {\n  dtype = \"f64\" /* Float64 */;\n  _data;\n  _allValid;\n  constructor(data, nullMask) {\n    super(data.length, nullMask);\n    this._data = data;\n    this._allValid = nullMask === void 0;\n  }\n  get(index) {\n    this._boundsCheck(index);\n    if (this._allValid) {\n      return this._data[index];\n    }\n    if (!this._nullMask.getUnsafe(index)) {\n      return null;\n    }\n    return this._data[index];\n  }\n  slice(start, end) {\n    const sliced = this._data.subarray(start, end);\n    if (this._allValid) {\n      return new _Float64Column(sliced);\n    }\n    const mask = new BitArray(sliced.length);\n    for (let i = 0; i < sliced.length; i++) {\n      mask.setUnsafe(i, this._nullMask.getUnsafe(start + i));\n    }\n    return new _Float64Column(sliced, mask);\n  }\n  clone() {\n    if (this._allValid) {\n      return new _Float64Column(new Float64Array(this._data));\n    }\n    return new _Float64Column(new Float64Array(this._data), this._nullMask.clone());\n  }\n  filter(mask) {\n    if (mask.length !== this._length) {\n      throw new FrameKitError(\n        \"SHAPE_MISMATCH\" /* SHAPE_MISMATCH */,\n        `Filter mask length ${mask.length} does not match column length ${this._length}`\n      );\n    }\n    const indices = [];\n    for (let i = 0; i < mask.length; i++) {\n      if (mask.get(i) === true) {\n        indices.push(i);\n      }\n    }\n    return this._takeByIndices(indices);\n  }\n  take(indices) {\n    const data = new Float64Array(indices.length);\n    const mask = this._allValid ? void 0 : new BitArray(indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      const idx = indices[i];\n      data[i] = this._data[idx];\n      if (mask) {\n        mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n      }\n    }\n    return new _Float64Column(data, mask);\n  }\n  sum() {\n    let total = 0;\n    for (let i = 0; i < this._length; i++) {\n      if (this._nullMask.getUnsafe(i)) {\n        total += this._data[i];\n      }\n    }\n    return total;\n  }\n  mean() {\n    const validCount = this._length - this.nullCount;\n    if (validCount === 0) return null;\n    return this.sum() / validCount;\n  }\n  min() {\n    let result = null;\n    for (let i = 0; i < this._length; i++) {\n      if (this._nullMask.getUnsafe(i)) {\n        const val = this._data[i];\n        if (result === null || val < result) {\n          result = val;\n        }\n      }\n    }\n    return result;\n  }\n  max() {\n    let result = null;\n    for (let i = 0; i < this._length; i++) {\n      if (this._nullMask.getUnsafe(i)) {\n        const val = this._data[i];\n        if (result === null || val > result) {\n          result = val;\n        }\n      }\n    }\n    return result;\n  }\n  estimatedMemoryBytes() {\n    return this._length * 8 + this._nullMask.byteLength;\n  }\n  static from(values) {\n    const data = new Float64Array(values.length);\n    const mask = new BitArray(values.length);\n    let hasNull = false;\n    for (let i = 0; i < values.length; i++) {\n      const v = values[i];\n      if (v !== null && v !== void 0) {\n        data[i] = v;\n        mask.setUnsafe(i, true);\n      } else {\n        hasNull = true;\n      }\n    }\n    return hasNull ? new _Float64Column(data, mask) : new _Float64Column(data);\n  }\n  _boundsCheck(index) {\n    if (index < 0 || index >= this._length) {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `Index ${index} out of bounds for column of length ${this._length}`\n      );\n    }\n  }\n  _takeByIndices(indices) {\n    const data = new Float64Array(indices.length);\n    const mask = new BitArray(indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      const idx = indices[i];\n      data[i] = this._data[idx];\n      mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n    }\n    return new _Float64Column(data, mask);\n  }\n};\nvar Int32Column = class _Int32Column extends Column {\n  dtype = \"i32\" /* Int32 */;\n  _data;\n  _allValid;\n  constructor(data, nullMask) {\n    super(data.length, nullMask);\n    this._data = data;\n    this._allValid = nullMask === void 0;\n  }\n  get(index) {\n    this._boundsCheck(index);\n    if (this._allValid) {\n      return this._data[index];\n    }\n    if (!this._nullMask.getUnsafe(index)) {\n      return null;\n    }\n    return this._data[index];\n  }\n  slice(start, end) {\n    const sliced = this._data.subarray(start, end);\n    if (this._allValid) {\n      return new _Int32Column(sliced);\n    }\n    const mask = new BitArray(sliced.length);\n    for (let i = 0; i < sliced.length; i++) {\n      mask.setUnsafe(i, this._nullMask.getUnsafe(start + i));\n    }\n    return new _Int32Column(sliced, mask);\n  }\n  clone() {\n    if (this._allValid) {\n      return new _Int32Column(new Int32Array(this._data));\n    }\n    return new _Int32Column(new Int32Array(this._data), this._nullMask.clone());\n  }\n  filter(mask) {\n    if (mask.length !== this._length) {\n      throw new FrameKitError(\n        \"SHAPE_MISMATCH\" /* SHAPE_MISMATCH */,\n        `Filter mask length ${mask.length} does not match column length ${this._length}`\n      );\n    }\n    const indices = [];\n    for (let i = 0; i < mask.length; i++) {\n      if (mask.get(i) === true) {\n        indices.push(i);\n      }\n    }\n    return this._takeByIndices(indices);\n  }\n  take(indices) {\n    const data = new Int32Array(indices.length);\n    const mask = this._allValid ? void 0 : new BitArray(indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      const idx = indices[i];\n      data[i] = this._data[idx];\n      if (mask) {\n        mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n      }\n    }\n    return new _Int32Column(data, mask);\n  }\n  sum() {\n    let total = 0;\n    for (let i = 0; i < this._length; i++) {\n      if (this._nullMask.getUnsafe(i)) {\n        total += this._data[i];\n      }\n    }\n    return total;\n  }\n  mean() {\n    const validCount = this._length - this.nullCount;\n    if (validCount === 0) return null;\n    return this.sum() / validCount;\n  }\n  min() {\n    let result = null;\n    for (let i = 0; i < this._length; i++) {\n      if (this._nullMask.getUnsafe(i)) {\n        const val = this._data[i];\n        if (result === null || val < result) {\n          result = val;\n        }\n      }\n    }\n    return result;\n  }\n  max() {\n    let result = null;\n    for (let i = 0; i < this._length; i++) {\n      if (this._nullMask.getUnsafe(i)) {\n        const val = this._data[i];\n        if (result === null || val > result) {\n          result = val;\n        }\n      }\n    }\n    return result;\n  }\n  estimatedMemoryBytes() {\n    return this._length * 4 + this._nullMask.byteLength;\n  }\n  static from(values) {\n    const data = new Int32Array(values.length);\n    const mask = new BitArray(values.length);\n    let hasNull = false;\n    for (let i = 0; i < values.length; i++) {\n      const v = values[i];\n      if (v !== null && v !== void 0) {\n        data[i] = v;\n        mask.setUnsafe(i, true);\n      } else {\n        hasNull = true;\n      }\n    }\n    return hasNull ? new _Int32Column(data, mask) : new _Int32Column(data);\n  }\n  _boundsCheck(index) {\n    if (index < 0 || index >= this._length) {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `Index ${index} out of bounds for column of length ${this._length}`\n      );\n    }\n  }\n  _takeByIndices(indices) {\n    const data = new Int32Array(indices.length);\n    const mask = new BitArray(indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      const idx = indices[i];\n      data[i] = this._data[idx];\n      mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n    }\n    return new _Int32Column(data, mask);\n  }\n};\n\n// src/storage/string.ts\nvar Utf8Column = class _Utf8Column extends Column {\n  dtype = \"utf8\" /* Utf8 */;\n  _data;\n  _interned;\n  _allValid;\n  constructor(data, nullMask, interned) {\n    super(data.length, nullMask);\n    if (interned) {\n      this._data = null;\n      this._interned = interned;\n    } else {\n      this._data = data;\n      this._interned = null;\n    }\n    this._allValid = nullMask === void 0;\n  }\n  /** Whether this column uses interned (dictionary-encoded) storage. */\n  get isInterned() {\n    return this._interned !== null;\n  }\n  get(index) {\n    this._boundsCheck(index);\n    if (this._allValid) {\n      if (this._interned) {\n        return this._interned.dictionary[this._interned.indices[index]];\n      }\n      return this._data[index];\n    }\n    if (!this._nullMask.getUnsafe(index)) {\n      return null;\n    }\n    if (this._interned) {\n      return this._interned.dictionary[this._interned.indices[index]];\n    }\n    return this._data[index];\n  }\n  slice(start, end) {\n    const len = end - start;\n    if (this._allValid) {\n      if (this._interned) {\n        const slicedIndices = this._interned.indices.slice(start, end);\n        return new _Utf8Column(new Array(len), void 0, {\n          dictionary: this._interned.dictionary,\n          indices: slicedIndices\n        });\n      }\n      return new _Utf8Column(this._data.slice(start, end));\n    }\n    const mask = new BitArray(len);\n    for (let i = 0; i < len; i++) {\n      mask.setUnsafe(i, this._nullMask.getUnsafe(start + i));\n    }\n    if (this._interned) {\n      const slicedIndices = this._interned.indices.slice(start, end);\n      return new _Utf8Column(new Array(len), mask, {\n        dictionary: this._interned.dictionary,\n        indices: slicedIndices\n      });\n    }\n    const sliced = this._data.slice(start, end);\n    return new _Utf8Column(sliced, mask);\n  }\n  clone() {\n    if (this._allValid) {\n      if (this._interned) {\n        return new _Utf8Column(new Array(this._length), void 0, {\n          dictionary: [...this._interned.dictionary],\n          indices: new Uint32Array(this._interned.indices)\n        });\n      }\n      return new _Utf8Column([...this._data]);\n    }\n    if (this._interned) {\n      return new _Utf8Column(new Array(this._length), this._nullMask.clone(), {\n        dictionary: [...this._interned.dictionary],\n        indices: new Uint32Array(this._interned.indices)\n      });\n    }\n    return new _Utf8Column([...this._data], this._nullMask.clone());\n  }\n  filter(mask) {\n    if (mask.length !== this._length) {\n      throw new FrameKitError(\n        \"SHAPE_MISMATCH\" /* SHAPE_MISMATCH */,\n        `Filter mask length ${mask.length} does not match column length ${this._length}`\n      );\n    }\n    const indices = [];\n    for (let i = 0; i < mask.length; i++) {\n      if (mask.get(i) === true) {\n        indices.push(i);\n      }\n    }\n    return this._takeByIndices(indices);\n  }\n  take(indices) {\n    const len = indices.length;\n    const mask = this._allValid ? void 0 : new BitArray(len);\n    if (this._interned) {\n      const newIndices = new Uint32Array(len);\n      for (let i = 0; i < len; i++) {\n        const idx = indices[i];\n        newIndices[i] = this._interned.indices[idx];\n        if (mask) {\n          mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n        }\n      }\n      return new _Utf8Column(new Array(len), mask, {\n        dictionary: this._interned.dictionary,\n        indices: newIndices\n      });\n    }\n    const data = new Array(len);\n    for (let i = 0; i < len; i++) {\n      const idx = indices[i];\n      data[i] = this._data[idx];\n      if (mask) {\n        mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n      }\n    }\n    return new _Utf8Column(data, mask);\n  }\n  estimatedMemoryBytes() {\n    let bytes = this._nullMask.byteLength;\n    if (this._interned) {\n      for (const s of this._interned.dictionary) {\n        bytes += s.length * 2;\n      }\n      bytes += this._interned.indices.byteLength;\n    } else {\n      for (let i = 0; i < this._length; i++) {\n        if (this._nullMask.get(i)) {\n          bytes += this._data[i].length * 2;\n        }\n      }\n    }\n    return bytes;\n  }\n  static from(values) {\n    const len = values.length;\n    const data = new Array(len);\n    const mask = new BitArray(len);\n    let hasNull = false;\n    for (let i = 0; i < len; i++) {\n      const v = values[i];\n      if (v !== null && v !== void 0) {\n        data[i] = v;\n        mask.set(i, true);\n      } else {\n        data[i] = \"\";\n        hasNull = true;\n      }\n    }\n    if (len > 0) {\n      const uniqueSet = /* @__PURE__ */ new Set();\n      let nonNullCount = 0;\n      for (let i = 0; i < len; i++) {\n        if (mask.getUnsafe(i)) {\n          uniqueSet.add(data[i]);\n          nonNullCount++;\n        }\n      }\n      if (nonNullCount > 0 && uniqueSet.size < len * 0.5) {\n        const dictionary = Array.from(uniqueSet);\n        const dictMap = /* @__PURE__ */ new Map();\n        for (let d = 0; d < dictionary.length; d++) {\n          dictMap.set(dictionary[d], d);\n        }\n        const indices = new Uint32Array(len);\n        for (let i = 0; i < len; i++) {\n          if (mask.getUnsafe(i)) {\n            indices[i] = dictMap.get(data[i]);\n          }\n        }\n        return hasNull ? new _Utf8Column(data, mask, { dictionary, indices }) : new _Utf8Column(data, void 0, { dictionary, indices });\n      }\n    }\n    return hasNull ? new _Utf8Column(data, mask) : new _Utf8Column(data);\n  }\n  _boundsCheck(index) {\n    if (index < 0 || index >= this._length) {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `Index ${index} out of bounds for column of length ${this._length}`\n      );\n    }\n  }\n  _takeByIndices(indices) {\n    const len = indices.length;\n    const mask = new BitArray(len);\n    if (this._interned) {\n      const newIndices = new Uint32Array(len);\n      for (let i = 0; i < len; i++) {\n        const idx = indices[i];\n        newIndices[i] = this._interned.indices[idx];\n        mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n      }\n      return new _Utf8Column(new Array(len), mask, {\n        dictionary: this._interned.dictionary,\n        indices: newIndices\n      });\n    }\n    const data = new Array(len);\n    for (let i = 0; i < len; i++) {\n      const idx = indices[i];\n      data[i] = this._data[idx];\n      mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n    }\n    return new _Utf8Column(data, mask);\n  }\n};\n\n// src/storage/boolean.ts\nvar BooleanColumn = class _BooleanColumn extends Column {\n  dtype = \"bool\" /* Boolean */;\n  _data;\n  constructor(data, nullMask) {\n    super(data.length, nullMask);\n    this._data = data;\n  }\n  get(index) {\n    this._boundsCheck(index);\n    if (!this._nullMask.getUnsafe(index)) {\n      return null;\n    }\n    return this._data[index] !== 0;\n  }\n  slice(start, end) {\n    const sliced = this._data.subarray(start, end);\n    const mask = new BitArray(sliced.length);\n    for (let i = 0; i < sliced.length; i++) {\n      mask.setUnsafe(i, this._nullMask.getUnsafe(start + i));\n    }\n    return new _BooleanColumn(sliced, mask);\n  }\n  clone() {\n    return new _BooleanColumn(new Uint8Array(this._data), this._nullMask.clone());\n  }\n  filter(mask) {\n    if (mask.length !== this._length) {\n      throw new FrameKitError(\n        \"SHAPE_MISMATCH\" /* SHAPE_MISMATCH */,\n        `Filter mask length ${mask.length} does not match column length ${this._length}`\n      );\n    }\n    const indices = [];\n    for (let i = 0; i < mask.length; i++) {\n      if (mask.get(i) === true) {\n        indices.push(i);\n      }\n    }\n    return this._takeByIndices(indices);\n  }\n  take(indices) {\n    const data = new Uint8Array(indices.length);\n    const mask = new BitArray(indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      const idx = indices[i];\n      data[i] = this._data[idx];\n      mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n    }\n    return new _BooleanColumn(data, mask);\n  }\n  estimatedMemoryBytes() {\n    return this._length + this._nullMask.byteLength;\n  }\n  static from(values) {\n    const data = new Uint8Array(values.length);\n    const mask = new BitArray(values.length);\n    for (let i = 0; i < values.length; i++) {\n      const v = values[i];\n      if (v !== null && v !== void 0) {\n        data[i] = v ? 1 : 0;\n        mask.setUnsafe(i, true);\n      }\n    }\n    return new _BooleanColumn(data, mask);\n  }\n  _boundsCheck(index) {\n    if (index < 0 || index >= this._length) {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `Index ${index} out of bounds for column of length ${this._length}`\n      );\n    }\n  }\n  _takeByIndices(indices) {\n    const data = new Uint8Array(indices.length);\n    const mask = new BitArray(indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      const idx = indices[i];\n      data[i] = this._data[idx];\n      mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n    }\n    return new _BooleanColumn(data, mask);\n  }\n};\n\n// src/storage/date.ts\nvar DateColumn = class _DateColumn extends Column {\n  dtype = \"date\" /* Date */;\n  _data;\n  constructor(data, nullMask) {\n    super(data.length, nullMask);\n    this._data = data;\n  }\n  get(index) {\n    this._boundsCheck(index);\n    if (!this._nullMask.getUnsafe(index)) {\n      return null;\n    }\n    return new Date(this._data[index]);\n  }\n  slice(start, end) {\n    const sliced = this._data.subarray(start, end);\n    const mask = new BitArray(sliced.length);\n    for (let i = 0; i < sliced.length; i++) {\n      mask.setUnsafe(i, this._nullMask.getUnsafe(start + i));\n    }\n    return new _DateColumn(sliced, mask);\n  }\n  clone() {\n    return new _DateColumn(new Float64Array(this._data), this._nullMask.clone());\n  }\n  filter(mask) {\n    if (mask.length !== this._length) {\n      throw new FrameKitError(\n        \"SHAPE_MISMATCH\" /* SHAPE_MISMATCH */,\n        `Filter mask length ${mask.length} does not match column length ${this._length}`\n      );\n    }\n    const indices = [];\n    for (let i = 0; i < mask.length; i++) {\n      if (mask.get(i) === true) {\n        indices.push(i);\n      }\n    }\n    return this._takeByIndices(indices);\n  }\n  take(indices) {\n    const data = new Float64Array(indices.length);\n    const mask = new BitArray(indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      const idx = indices[i];\n      data[i] = this._data[idx];\n      mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n    }\n    return new _DateColumn(data, mask);\n  }\n  estimatedMemoryBytes() {\n    return this._length * 8 + this._nullMask.byteLength;\n  }\n  static from(values) {\n    const data = new Float64Array(values.length);\n    const mask = new BitArray(values.length);\n    for (let i = 0; i < values.length; i++) {\n      const v = values[i];\n      if (v !== null && v !== void 0) {\n        data[i] = v.getTime();\n        mask.setUnsafe(i, true);\n      }\n    }\n    return new _DateColumn(data, mask);\n  }\n  _boundsCheck(index) {\n    if (index < 0 || index >= this._length) {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `Index ${index} out of bounds for column of length ${this._length}`\n      );\n    }\n  }\n  _takeByIndices(indices) {\n    const data = new Float64Array(indices.length);\n    const mask = new BitArray(indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      const idx = indices[i];\n      data[i] = this._data[idx];\n      mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n    }\n    return new _DateColumn(data, mask);\n  }\n};\n\n// src/storage/object.ts\nvar ObjectColumn = class _ObjectColumn extends Column {\n  dtype = \"object\" /* Object */;\n  _data;\n  constructor(data, nullMask) {\n    super(data.length, nullMask);\n    this._data = data;\n  }\n  get(index) {\n    this._boundsCheck(index);\n    if (!this._nullMask.getUnsafe(index)) {\n      return null;\n    }\n    return this._data[index];\n  }\n  slice(start, end) {\n    const sliced = this._data.slice(start, end);\n    const mask = new BitArray(sliced.length);\n    for (let i = 0; i < sliced.length; i++) {\n      mask.setUnsafe(i, this._nullMask.getUnsafe(start + i));\n    }\n    return new _ObjectColumn(sliced, mask);\n  }\n  clone() {\n    return new _ObjectColumn([...this._data], this._nullMask.clone());\n  }\n  filter(mask) {\n    if (mask.length !== this._length) {\n      throw new FrameKitError(\n        \"SHAPE_MISMATCH\" /* SHAPE_MISMATCH */,\n        `Filter mask length ${mask.length} does not match column length ${this._length}`\n      );\n    }\n    const indices = [];\n    for (let i = 0; i < mask.length; i++) {\n      if (mask.get(i) === true) {\n        indices.push(i);\n      }\n    }\n    return this._takeByIndices(indices);\n  }\n  take(indices) {\n    const data = new Array(indices.length);\n    const mask = new BitArray(indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      const idx = indices[i];\n      data[i] = this._data[idx];\n      mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n    }\n    return new _ObjectColumn(data, mask);\n  }\n  estimatedMemoryBytes() {\n    return this._length * 8 + this._nullMask.byteLength;\n  }\n  static from(values) {\n    const data = new Array(values.length);\n    const mask = new BitArray(values.length);\n    for (let i = 0; i < values.length; i++) {\n      const v = values[i];\n      if (v !== null && v !== void 0) {\n        data[i] = v;\n        mask.setUnsafe(i, true);\n      } else {\n        data[i] = null;\n      }\n    }\n    return new _ObjectColumn(data, mask);\n  }\n  _boundsCheck(index) {\n    if (index < 0 || index >= this._length) {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `Index ${index} out of bounds for column of length ${this._length}`\n      );\n    }\n  }\n  _takeByIndices(indices) {\n    const data = new Array(indices.length);\n    const mask = new BitArray(indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      const idx = indices[i];\n      data[i] = this._data[idx];\n      mask.setUnsafe(i, this._nullMask.getUnsafe(idx));\n    }\n    return new _ObjectColumn(data, mask);\n  }\n};\n\n// src/accessors/string-accessor.ts\nvar StringAccessor = class {\n  _series;\n  constructor(series) {\n    if (series.dtype !== \"utf8\" /* Utf8 */) {\n      throw new TypeMismatchError(\n        `StringAccessor requires Series with dtype Utf8, got '${series.dtype}'`\n      );\n    }\n    this._series = series;\n  }\n  toLowerCase() {\n    return this._mapString((s) => s.toLowerCase());\n  }\n  toUpperCase() {\n    return this._mapString((s) => s.toUpperCase());\n  }\n  trim() {\n    return this._mapString((s) => s.trim());\n  }\n  startsWith(prefix) {\n    return this._mapBoolean((s) => s.startsWith(prefix));\n  }\n  endsWith(suffix) {\n    return this._mapBoolean((s) => s.endsWith(suffix));\n  }\n  contains(pattern) {\n    return this._mapBoolean((s) => s.includes(pattern));\n  }\n  replace(pattern, replacement) {\n    return this._mapString((s) => s.replaceAll(pattern, replacement));\n  }\n  split(separator) {\n    const data = [];\n    const mask = new BitArray(this._series.length);\n    for (let i = 0; i < this._series.length; i++) {\n      const val = this._series.get(i);\n      if (val === null) {\n        data.push([]);\n      } else {\n        data.push(val.split(separator));\n        mask.set(i, true);\n      }\n    }\n    const col2 = new ListColumn(data, mask);\n    return new Series(this._series.name, col2);\n  }\n  slice(start, end) {\n    return this._mapString((s) => s.slice(start, end));\n  }\n  length() {\n    const results = [];\n    for (let i = 0; i < this._series.length; i++) {\n      const val = this._series.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(val.length);\n      }\n    }\n    return new Series(this._series.name, Float64Column.from(results));\n  }\n  padStart(length, fillChar) {\n    return this._mapString((s) => s.padStart(length, fillChar));\n  }\n  padEnd(length, fillChar) {\n    return this._mapString((s) => s.padEnd(length, fillChar));\n  }\n  extract(pattern) {\n    const source = pattern.source;\n    if (!source.includes(\"(\") || source.replace(/\\\\\\(/g, \"\").indexOf(\"(\") === -1) {\n      throw new TypeMismatchError(\n        \"extract() pattern must contain at least one capture group\"\n      );\n    }\n    const results = [];\n    for (let i = 0; i < this._series.length; i++) {\n      const val = this._series.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        const match = val.match(pattern);\n        if (match && match[1] !== void 0) {\n          results.push(match[1]);\n        } else {\n          results.push(null);\n        }\n      }\n    }\n    return new Series(this._series.name, Utf8Column.from(results));\n  }\n  _mapString(fn) {\n    const results = [];\n    for (let i = 0; i < this._series.length; i++) {\n      const val = this._series.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(fn(val));\n      }\n    }\n    return new Series(this._series.name, Utf8Column.from(results));\n  }\n  _mapBoolean(fn) {\n    const results = [];\n    for (let i = 0; i < this._series.length; i++) {\n      const val = this._series.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(fn(val));\n      }\n    }\n    return new Series(this._series.name, BooleanColumn.from(results));\n  }\n};\nvar ListColumn = class _ListColumn extends Column {\n  dtype = \"utf8\" /* Utf8 */;\n  _data;\n  constructor(data, nullMask) {\n    super(data.length, nullMask);\n    this._data = data;\n  }\n  get(index) {\n    if (index < 0 || index >= this._length) {\n      throw new Error(`Index ${index} out of bounds for column of length ${this._length}`);\n    }\n    if (!this._nullMask.get(index)) return null;\n    return this._data[index];\n  }\n  slice(start, end) {\n    const sliced = this._data.slice(start, end);\n    const mask = new BitArray(sliced.length);\n    for (let i = 0; i < sliced.length; i++) {\n      mask.set(i, this._nullMask.get(start + i));\n    }\n    return new _ListColumn(sliced, mask);\n  }\n  clone() {\n    return new _ListColumn(\n      this._data.map((arr) => [...arr]),\n      this._nullMask.clone()\n    );\n  }\n  filter(mask) {\n    const indices = [];\n    for (let i = 0; i < mask.length; i++) {\n      if (mask.get(i) === true) indices.push(i);\n    }\n    return this._takeByIndices(indices);\n  }\n  take(indices) {\n    const idxArray = [];\n    for (let i = 0; i < indices.length; i++) {\n      idxArray.push(indices[i]);\n    }\n    return this._takeByIndices(idxArray);\n  }\n  estimatedMemoryBytes() {\n    let bytes = this._nullMask.byteLength;\n    for (let i = 0; i < this._length; i++) {\n      if (this._nullMask.get(i)) {\n        for (const s of this._data[i]) {\n          bytes += s.length * 2;\n        }\n      }\n    }\n    return bytes;\n  }\n  _takeByIndices(indices) {\n    const data = [];\n    const mask = new BitArray(indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      const idx = indices[i];\n      data.push(this._data[idx]);\n      mask.set(i, this._nullMask.get(idx));\n    }\n    return new _ListColumn(data, mask);\n  }\n};\n\n// src/accessors/date-accessor.ts\nvar DateAccessor = class {\n  _series;\n  constructor(series) {\n    if (series.dtype !== \"date\" /* Date */) {\n      throw new TypeMismatchError(\n        `DateAccessor requires Series with dtype Date, got '${series.dtype}'`\n      );\n    }\n    this._series = series;\n  }\n  year() {\n    return this._mapNumber((d) => d.getFullYear());\n  }\n  month() {\n    return this._mapNumber((d) => d.getMonth() + 1);\n  }\n  day() {\n    return this._mapNumber((d) => d.getDate());\n  }\n  hour() {\n    return this._mapNumber((d) => d.getHours());\n  }\n  minute() {\n    return this._mapNumber((d) => d.getMinutes());\n  }\n  second() {\n    return this._mapNumber((d) => d.getSeconds());\n  }\n  dayOfWeek() {\n    return this._mapNumber((d) => d.getDay());\n  }\n  dayOfYear() {\n    return this._mapNumber((d) => {\n      const start = new Date(d.getFullYear(), 0, 0);\n      const diff = d.getTime() - start.getTime();\n      const oneDay = 1e3 * 60 * 60 * 24;\n      return Math.floor(diff / oneDay);\n    });\n  }\n  weekNumber() {\n    return this._mapNumber((d) => {\n      const target = new Date(d.getTime());\n      target.setHours(0, 0, 0, 0);\n      target.setDate(target.getDate() + 3 - (target.getDay() + 6) % 7);\n      const jan4 = new Date(target.getFullYear(), 0, 4);\n      const dayDiff = (target.getTime() - jan4.getTime()) / (1e3 * 60 * 60 * 24);\n      return 1 + Math.round((dayDiff - 3 + (jan4.getDay() + 6) % 7) / 7);\n    });\n  }\n  quarter() {\n    return this._mapNumber((d) => Math.floor(d.getMonth() / 3) + 1);\n  }\n  timestamp() {\n    return this._mapNumber((d) => d.getTime());\n  }\n  format(pattern) {\n    const results = [];\n    for (let i = 0; i < this._series.length; i++) {\n      const val = this._series.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(formatDate(val, pattern));\n      }\n    }\n    return new Series(this._series.name, Utf8Column.from(results));\n  }\n  diff(other, unit) {\n    if (other.dtype !== \"date\" /* Date */) {\n      throw new TypeMismatchError(\n        `diff() requires a Date Series, got '${other.dtype}'`\n      );\n    }\n    if (other.length !== this._series.length) {\n      throw new TypeMismatchError(\n        `diff() requires Series of equal length, got ${this._series.length} and ${other.length}`\n      );\n    }\n    const results = [];\n    for (let i = 0; i < this._series.length; i++) {\n      const a = this._series.get(i);\n      const b = other.get(i);\n      if (a === null || b === null) {\n        results.push(null);\n      } else {\n        results.push(dateDiff(a, b, unit));\n      }\n    }\n    return new Series(this._series.name, Float64Column.from(results));\n  }\n  truncate(unit) {\n    const results = [];\n    for (let i = 0; i < this._series.length; i++) {\n      const val = this._series.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(truncateDate(val, unit));\n      }\n    }\n    return new Series(this._series.name, DateColumn.from(results));\n  }\n  _mapNumber(fn) {\n    const results = [];\n    for (let i = 0; i < this._series.length; i++) {\n      const val = this._series.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(fn(val));\n      }\n    }\n    return new Series(this._series.name, Float64Column.from(results));\n  }\n};\nfunction formatDate(date, pattern) {\n  const pad2 = (n) => String(n).padStart(2, \"0\");\n  const pad4 = (n) => String(n).padStart(4, \"0\");\n  return pattern.replace(\"YYYY\", pad4(date.getFullYear())).replace(\"MM\", pad2(date.getMonth() + 1)).replace(\"DD\", pad2(date.getDate())).replace(\"HH\", pad2(date.getHours())).replace(\"mm\", pad2(date.getMinutes())).replace(\"ss\", pad2(date.getSeconds()));\n}\nfunction dateDiff(a, b, unit) {\n  const msA = a.getTime();\n  const msB = b.getTime();\n  const diffMs = msB - msA;\n  switch (unit) {\n    case \"second\":\n      return diffMs / 1e3;\n    case \"minute\":\n      return diffMs / (1e3 * 60);\n    case \"hour\":\n      return diffMs / (1e3 * 60 * 60);\n    case \"day\":\n      return diffMs / (1e3 * 60 * 60 * 24);\n    case \"month\": {\n      const yearDiff = b.getFullYear() - a.getFullYear();\n      const monthDiff = b.getMonth() - a.getMonth();\n      const dayFrac = (b.getDate() - a.getDate()) / 30;\n      return yearDiff * 12 + monthDiff + dayFrac;\n    }\n    case \"year\": {\n      const yearDiff = b.getFullYear() - a.getFullYear();\n      const monthFrac = (b.getMonth() - a.getMonth()) / 12;\n      const dayFrac = (b.getDate() - a.getDate()) / 365;\n      return yearDiff + monthFrac + dayFrac;\n    }\n  }\n}\nfunction truncateDate(date, unit) {\n  switch (unit) {\n    case \"year\":\n      return new Date(date.getFullYear(), 0, 1);\n    case \"month\":\n      return new Date(date.getFullYear(), date.getMonth(), 1);\n    case \"day\":\n      return new Date(date.getFullYear(), date.getMonth(), date.getDate());\n    case \"hour\":\n      return new Date(\n        date.getFullYear(),\n        date.getMonth(),\n        date.getDate(),\n        date.getHours()\n      );\n    case \"minute\":\n      return new Date(\n        date.getFullYear(),\n        date.getMonth(),\n        date.getDate(),\n        date.getHours(),\n        date.getMinutes()\n      );\n    case \"second\":\n      return new Date(\n        date.getFullYear(),\n        date.getMonth(),\n        date.getDate(),\n        date.getHours(),\n        date.getMinutes(),\n        date.getSeconds()\n      );\n  }\n}\n\n// src/series.ts\nvar _createDataFrame;\nfunction _registerDataFrameFactory(factory) {\n  _createDataFrame = factory;\n}\nvar Series = class _Series {\n  _name;\n  _column;\n  constructor(name, column) {\n    this._name = name;\n    this._column = column;\n  }\n  get name() {\n    return this._name;\n  }\n  get dtype() {\n    return this._column.dtype;\n  }\n  get length() {\n    return this._column.length;\n  }\n  get nullCount() {\n    return this._column.nullCount;\n  }\n  get column() {\n    return this._column;\n  }\n  get str() {\n    return new StringAccessor(this);\n  }\n  get dt() {\n    return new DateAccessor(this);\n  }\n  get(index) {\n    return this._column.get(index);\n  }\n  toArray() {\n    const result = [];\n    for (let i = 0; i < this._column.length; i++) {\n      result.push(this._column.get(i));\n    }\n    return result;\n  }\n  // Numeric methods â€” only valid when T extends number\n  sum() {\n    const col2 = this._asNumericColumn();\n    return col2.sum();\n  }\n  mean() {\n    const col2 = this._asNumericColumn();\n    return col2.mean();\n  }\n  min() {\n    const col2 = this._asNumericColumn();\n    return col2.min();\n  }\n  max() {\n    const col2 = this._asNumericColumn();\n    return col2.max();\n  }\n  std() {\n    const col2 = this._asNumericColumn();\n    const m = col2.mean();\n    if (m === null) return null;\n    const validCount = col2.length - col2.nullCount;\n    if (validCount < 2) return null;\n    let sumSqDiff = 0;\n    for (let i = 0; i < col2.length; i++) {\n      const val = col2.get(i);\n      if (val !== null) {\n        const diff = val - m;\n        sumSqDiff += diff * diff;\n      }\n    }\n    return Math.sqrt(sumSqDiff / (validCount - 1));\n  }\n  median() {\n    const col2 = this._asNumericColumn();\n    const values = [];\n    for (let i = 0; i < col2.length; i++) {\n      const val = col2.get(i);\n      if (val !== null) {\n        values.push(val);\n      }\n    }\n    if (values.length === 0) return null;\n    values.sort((a, b) => a - b);\n    const mid = Math.floor(values.length / 2);\n    if (values.length % 2 === 0) {\n      return (values[mid - 1] + values[mid]) / 2;\n    }\n    return values[mid];\n  }\n  between(low, high) {\n    const col2 = this._asNumericColumn();\n    const results = [];\n    for (let i = 0; i < col2.length; i++) {\n      const val = col2.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(val >= low && val <= high);\n      }\n    }\n    return new _Series(this._name, BooleanColumn.from(results));\n  }\n  cumSum() {\n    const col2 = this._asNumericColumn();\n    const results = [];\n    let running = 0;\n    for (let i = 0; i < col2.length; i++) {\n      const val = col2.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        running += val;\n        results.push(running);\n      }\n    }\n    return new _Series(this._name, Float64Column.from(results));\n  }\n  abs() {\n    const col2 = this._asNumericColumn();\n    const results = [];\n    for (let i = 0; i < col2.length; i++) {\n      const val = col2.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(Math.abs(val));\n      }\n    }\n    return new _Series(this._name, Float64Column.from(results));\n  }\n  round(decimals = 0) {\n    const col2 = this._asNumericColumn();\n    const factor = Math.pow(10, decimals);\n    const results = [];\n    for (let i = 0; i < col2.length; i++) {\n      const val = col2.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(Math.round(val * factor) / factor);\n      }\n    }\n    return new _Series(this._name, Float64Column.from(results));\n  }\n  // Comparison methods\n  eq(value) {\n    return this._compareScalar(value, (a, b) => a === b);\n  }\n  neq(value) {\n    return this._compareScalar(value, (a, b) => a !== b);\n  }\n  gt(value) {\n    return this._compareScalar(value, (a, b) => a > b);\n  }\n  gte(value) {\n    return this._compareScalar(value, (a, b) => a >= b);\n  }\n  lt(value) {\n    return this._compareScalar(value, (a, b) => a < b);\n  }\n  lte(value) {\n    return this._compareScalar(value, (a, b) => a <= b);\n  }\n  isIn(values) {\n    const set = new Set(values.map((v) => this._toComparable(v)));\n    const results = [];\n    for (let i = 0; i < this._column.length; i++) {\n      const val = this._column.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(set.has(this._toComparable(val)));\n      }\n    }\n    return new _Series(this._name, BooleanColumn.from(results));\n  }\n  isNull() {\n    const results = [];\n    for (let i = 0; i < this._column.length; i++) {\n      results.push(this._column.get(i) === null);\n    }\n    return new _Series(this._name, BooleanColumn.from(results));\n  }\n  isNotNull() {\n    const results = [];\n    for (let i = 0; i < this._column.length; i++) {\n      results.push(this._column.get(i) !== null);\n    }\n    return new _Series(this._name, BooleanColumn.from(results));\n  }\n  fillNull(value) {\n    const values = this.toArray();\n    const filled = values.map((v) => v === null ? value : v);\n    return new _Series(this._name, this._buildColumn(filled));\n  }\n  unique() {\n    const seen = /* @__PURE__ */ new Set();\n    const values = [];\n    for (let i = 0; i < this._column.length; i++) {\n      const val = this._column.get(i);\n      const key = val === null ? \"__null__\" : String(this._toComparable(val));\n      if (!seen.has(key)) {\n        seen.add(key);\n        values.push(val);\n      }\n    }\n    return new _Series(this._name, this._buildColumn(values));\n  }\n  nUnique() {\n    const seen = /* @__PURE__ */ new Set();\n    for (let i = 0; i < this._column.length; i++) {\n      const val = this._column.get(i);\n      const key = val === null ? \"__null__\" : String(this._toComparable(val));\n      seen.add(key);\n    }\n    return seen.size;\n  }\n  valueCounts() {\n    if (!_createDataFrame) {\n      throw new FrameKitError(\"INVALID_OPERATION\" /* INVALID_OPERATION */, \"DataFrame factory not registered\");\n    }\n    const counts = /* @__PURE__ */ new Map();\n    const order = [];\n    for (let i = 0; i < this._column.length; i++) {\n      const val = this._column.get(i);\n      const key = val === null ? \"__null__\" : String(this._toComparable(val));\n      const entry = counts.get(key);\n      if (entry) {\n        entry.count++;\n      } else {\n        counts.set(key, { value: val, count: 1 });\n        order.push(key);\n      }\n    }\n    order.sort((a, b) => counts.get(b).count - counts.get(a).count);\n    const values = [];\n    const countValues = [];\n    for (const key of order) {\n      const entry = counts.get(key);\n      values.push(entry.value);\n      countValues.push(entry.count);\n    }\n    const valueCol = this._buildColumn(values);\n    const countCol = Float64Column.from(countValues);\n    const columns = /* @__PURE__ */ new Map();\n    columns.set(\"value\", valueCol);\n    columns.set(\"count\", countCol);\n    return _createDataFrame(columns, [\"value\", \"count\"]);\n  }\n  cast(dtype) {\n    const values = this.toArray();\n    const converted = values.map((v) => {\n      if (v === null) return null;\n      return this._castValue(v, dtype);\n    });\n    const col2 = buildColumnFromDType(dtype, converted);\n    return new _Series(this._name, col2);\n  }\n  apply(fn) {\n    const results = [];\n    for (let i = 0; i < this._column.length; i++) {\n      results.push(fn(this._column.get(i)));\n    }\n    let resultDType = \"f64\" /* Float64 */;\n    for (const r of results) {\n      if (r !== null) {\n        if (typeof r === \"string\") resultDType = \"utf8\" /* Utf8 */;\n        else if (typeof r === \"boolean\") resultDType = \"bool\" /* Boolean */;\n        else if (r instanceof Date) resultDType = \"date\" /* Date */;\n        else resultDType = \"f64\" /* Float64 */;\n        break;\n      }\n    }\n    const col2 = buildColumnFromDType(resultDType, results);\n    return new _Series(this._name, col2);\n  }\n  _asNumericColumn() {\n    if (this._column instanceof Float64Column) return this._column;\n    if (this._column instanceof Int32Column) return this._column;\n    throw new TypeMismatchError(\n      `Cannot perform numeric operation on Series with dtype '${this.dtype}'`\n    );\n  }\n  _compareScalar(value, predicate) {\n    const results = [];\n    for (let i = 0; i < this._column.length; i++) {\n      const val = this._column.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(predicate(val, value));\n      }\n    }\n    return new _Series(this._name, BooleanColumn.from(results));\n  }\n  _toComparable(value) {\n    if (value instanceof Date) return value.getTime();\n    return value;\n  }\n  _buildColumn(values) {\n    switch (this._column.dtype) {\n      case \"f64\" /* Float64 */:\n        return Float64Column.from(values);\n      case \"i32\" /* Int32 */:\n        return Int32Column.from(values);\n      case \"utf8\" /* Utf8 */:\n        return Utf8Column.from(values);\n      case \"bool\" /* Boolean */:\n        return BooleanColumn.from(values);\n      case \"date\" /* Date */:\n        return DateColumn.from(values);\n      case \"object\" /* Object */:\n        return ObjectColumn.from(values);\n      default:\n        throw new FrameKitError(\n          \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n          `Unsupported dtype: ${this._column.dtype}`\n        );\n    }\n  }\n  _castValue(value, targetDType) {\n    switch (targetDType) {\n      case \"f64\" /* Float64 */:\n      case \"i32\" /* Int32 */:\n        if (typeof value === \"number\") return value;\n        if (typeof value === \"string\") return Number(value);\n        if (typeof value === \"boolean\") return value ? 1 : 0;\n        if (value instanceof Date) return value.getTime();\n        return Number(value);\n      case \"utf8\" /* Utf8 */:\n        if (value instanceof Date) return value.toISOString();\n        return String(value);\n      case \"bool\" /* Boolean */:\n        return Boolean(value);\n      case \"date\" /* Date */:\n        if (value instanceof Date) return value;\n        if (typeof value === \"number\") return new Date(value);\n        if (typeof value === \"string\") return new Date(value);\n        return new Date(String(value));\n      default:\n        throw new TypeMismatchError(\n          `Cannot cast to dtype '${targetDType}'`\n        );\n    }\n  }\n};\nfunction buildColumnFromDType(dtype, values) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n      return Float64Column.from(values);\n    case \"i32\" /* Int32 */:\n      return Int32Column.from(values);\n    case \"utf8\" /* Utf8 */:\n      return Utf8Column.from(values);\n    case \"bool\" /* Boolean */:\n      return BooleanColumn.from(values);\n    case \"date\" /* Date */:\n      return DateColumn.from(values);\n    case \"object\" /* Object */:\n      return ObjectColumn.from(values);\n    default:\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `Unsupported dtype for column construction: ${dtype}`\n      );\n  }\n}\n\n// src/expr/expr.ts\nvar Expr = class _Expr {\n  as(name) {\n    return new NamedExpr(this, name);\n  }\n  // Arithmetic\n  add(other) {\n    return new ArithmeticExpr(this, wrapNum(other), \"add\");\n  }\n  sub(other) {\n    return new ArithmeticExpr(this, wrapNum(other), \"sub\");\n  }\n  mul(other) {\n    return new ArithmeticExpr(this, wrapNum(other), \"mul\");\n  }\n  div(other) {\n    return new ArithmeticExpr(this, wrapNum(other), \"div\");\n  }\n  mod(other) {\n    return new ArithmeticExpr(this, wrapNum(other), \"mod\");\n  }\n  pow(other) {\n    return new ArithmeticExpr(this, wrapNum(other), \"pow\");\n  }\n  // Comparison\n  eq(other) {\n    return new ComparisonExpr(this, wrap(other), \"eq\");\n  }\n  neq(other) {\n    return new ComparisonExpr(this, wrap(other), \"neq\");\n  }\n  gt(other) {\n    return new ComparisonExpr(this, wrap(other), \"gt\");\n  }\n  gte(other) {\n    return new ComparisonExpr(this, wrap(other), \"gte\");\n  }\n  lt(other) {\n    return new ComparisonExpr(this, wrap(other), \"lt\");\n  }\n  lte(other) {\n    return new ComparisonExpr(this, wrap(other), \"lte\");\n  }\n  // Logical\n  and(other) {\n    return new LogicalExpr(this, wrapBool(other), \"and\");\n  }\n  or(other) {\n    return new LogicalExpr(this, wrapBool(other), \"or\");\n  }\n  not() {\n    return new NotExpr(this);\n  }\n  // â”€â”€ Aggregation (returns AggExpr for use in groupBy().agg()) â”€â”€\n  _aggColumnName() {\n    const deps = this.dependencies;\n    if (deps.length === 0) {\n      throw new Error(\"Aggregation requires a column reference\");\n    }\n    return deps[0];\n  }\n  sum() {\n    return new SumAggExpr(this._aggColumnName());\n  }\n  mean() {\n    return new MeanAggExpr(this._aggColumnName());\n  }\n  count() {\n    return new CountAggExpr(this._aggColumnName());\n  }\n  countDistinct() {\n    return new CountDistinctAggExpr(this._aggColumnName());\n  }\n  min() {\n    return new MinAggExpr(this._aggColumnName());\n  }\n  max() {\n    return new MaxAggExpr(this._aggColumnName());\n  }\n  std() {\n    return new StdAggExpr(this._aggColumnName());\n  }\n  first() {\n    return new FirstAggExpr(this._aggColumnName());\n  }\n  last() {\n    return new LastAggExpr(this._aggColumnName());\n  }\n  list() {\n    return new ListAggExpr(this._aggColumnName());\n  }\n  mode() {\n    return new ModeAggExpr(this._aggColumnName());\n  }\n  // â”€â”€ Null handling â”€â”€\n  coalesce(...others) {\n    const exprs = others.map((o) => o instanceof _Expr ? o : new LiteralExpr(o));\n    return new CoalesceExpr([this, ...exprs]);\n  }\n  fillNull(value) {\n    const valExpr = value instanceof _Expr ? value : new LiteralExpr(value);\n    return new FillNullExpr(this, valExpr);\n  }\n  isNull() {\n    return new IsNullExpr(this);\n  }\n  isNotNull() {\n    return new IsNotNullExpr(this);\n  }\n};\nvar NamedExpr = class {\n  expr;\n  name;\n  constructor(expr, name) {\n    this.expr = expr;\n    this.name = name;\n  }\n  get dependencies() {\n    return this.expr.dependencies;\n  }\n  toString() {\n    return `${this.expr.toString()} AS ${this.name}`;\n  }\n};\nfunction wrap(value) {\n  if (value instanceof Expr) return value;\n  return new LiteralExpr(value);\n}\nfunction wrapNum(value) {\n  if (value instanceof Expr) return value;\n  return new LiteralExpr(value);\n}\nfunction wrapBool(value) {\n  if (value instanceof Expr) return value;\n  return new LiteralExpr(value);\n}\nfunction buildColumnForValues(dtype, values) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n      return Float64Column.from(values);\n    case \"utf8\" /* Utf8 */:\n      return Utf8Column.from(values);\n    case \"bool\" /* Boolean */:\n      return BooleanColumn.from(values);\n    case \"date\" /* Date */:\n      return DateColumn.from(values);\n    default:\n      return Float64Column.from(values);\n  }\n}\nfunction detectLiteralDType(value) {\n  if (typeof value === \"number\") return \"f64\" /* Float64 */;\n  if (typeof value === \"string\") return \"utf8\" /* Utf8 */;\n  if (typeof value === \"boolean\") return \"bool\" /* Boolean */;\n  if (value instanceof Date) return \"date\" /* Date */;\n  return \"f64\" /* Float64 */;\n}\nvar LiteralExpr = class extends Expr {\n  _value;\n  constructor(value) {\n    super();\n    this._value = value;\n  }\n  get dependencies() {\n    return [];\n  }\n  toString() {\n    if (typeof this._value === \"string\") return `\"${this._value}\"`;\n    if (this._value instanceof Date) return this._value.toISOString();\n    return String(this._value);\n  }\n  evaluate(df2) {\n    const len = df2.length;\n    const values = new Array(len).fill(this._value);\n    const dtype = detectLiteralDType(this._value);\n    const col2 = buildColumnForValues(dtype, values);\n    return new Series(\"literal\", col2);\n  }\n};\nvar ColumnExpr = class extends Expr {\n  _name;\n  constructor(name) {\n    super();\n    this._name = name;\n  }\n  get dependencies() {\n    return [this._name];\n  }\n  toString() {\n    return this._name;\n  }\n  evaluate(df2) {\n    return df2.col(this._name);\n  }\n};\nvar ARITH_OP_SYMBOLS = {\n  add: \"+\",\n  sub: \"-\",\n  mul: \"*\",\n  div: \"/\",\n  mod: \"%\",\n  pow: \"**\"\n};\nvar ArithmeticExpr = class extends Expr {\n  _left;\n  _right;\n  _op;\n  constructor(left, right, op) {\n    super();\n    this._left = left;\n    this._right = right;\n    this._op = op;\n  }\n  get dependencies() {\n    return [.../* @__PURE__ */ new Set([...this._left.dependencies, ...this._right.dependencies])];\n  }\n  toString() {\n    return `(${this._left.toString()} ${ARITH_OP_SYMBOLS[this._op]} ${this._right.toString()})`;\n  }\n  evaluate(df2) {\n    const leftSeries = this._left.evaluate(df2);\n    const rightSeries = this._right.evaluate(df2);\n    const len = leftSeries.length;\n    const results = [];\n    for (let i = 0; i < len; i++) {\n      const a = leftSeries.get(i);\n      const b = rightSeries.get(i);\n      if (a === null || b === null) {\n        results.push(null);\n      } else {\n        results.push(applyArithOp(a, b, this._op));\n      }\n    }\n    return new Series(\"\", Float64Column.from(results));\n  }\n};\nfunction applyArithOp(a, b, op) {\n  switch (op) {\n    case \"add\":\n      return a + b;\n    case \"sub\":\n      return a - b;\n    case \"mul\":\n      return a * b;\n    case \"div\":\n      return a / b;\n    case \"mod\":\n      return a % b;\n    case \"pow\":\n      return Math.pow(a, b);\n  }\n}\nvar CMP_OP_SYMBOLS = {\n  eq: \"==\",\n  neq: \"!=\",\n  gt: \">\",\n  gte: \">=\",\n  lt: \"<\",\n  lte: \"<=\"\n};\nvar ComparisonExpr = class extends Expr {\n  _left;\n  _right;\n  _op;\n  constructor(left, right, op) {\n    super();\n    this._left = left;\n    this._right = right;\n    this._op = op;\n  }\n  get dependencies() {\n    return [.../* @__PURE__ */ new Set([...this._left.dependencies, ...this._right.dependencies])];\n  }\n  toString() {\n    return `(${this._left.toString()} ${CMP_OP_SYMBOLS[this._op]} ${this._right.toString()})`;\n  }\n  evaluate(df2) {\n    if (this._left instanceof ColumnExpr && this._right instanceof LiteralExpr) {\n      const columnName = this._left.dependencies[0];\n      const literal = this._right._value;\n      const source = df2.col(columnName).column;\n      const len2 = source.length;\n      const results2 = new Array(len2);\n      for (let i = 0; i < len2; i++) {\n        const a = source.get(i);\n        if (a === null || literal === null) {\n          results2[i] = null;\n        } else {\n          results2[i] = applyCmpOp(a, literal, this._op);\n        }\n      }\n      return new Series(\"\", BooleanColumn.from(results2));\n    }\n    if (this._left instanceof LiteralExpr && this._right instanceof ColumnExpr) {\n      const literal = this._left._value;\n      const columnName = this._right.dependencies[0];\n      const source = df2.col(columnName).column;\n      const len2 = source.length;\n      const results2 = new Array(len2);\n      for (let i = 0; i < len2; i++) {\n        const b = source.get(i);\n        if (literal === null || b === null) {\n          results2[i] = null;\n        } else {\n          results2[i] = applyCmpOp(literal, b, this._op);\n        }\n      }\n      return new Series(\"\", BooleanColumn.from(results2));\n    }\n    const leftSeries = this._left.evaluate(df2);\n    const rightSeries = this._right.evaluate(df2);\n    const len = leftSeries.length;\n    const results = new Array(len);\n    for (let i = 0; i < len; i++) {\n      const a = leftSeries.get(i);\n      const b = rightSeries.get(i);\n      if (a === null || b === null) {\n        results[i] = null;\n      } else {\n        results[i] = applyCmpOp(a, b, this._op);\n      }\n    }\n    return new Series(\"\", BooleanColumn.from(results));\n  }\n};\nfunction applyCmpOp(a, b, op) {\n  switch (op) {\n    case \"eq\":\n      return a === b;\n    case \"neq\":\n      return a !== b;\n    case \"gt\":\n      return a > b;\n    case \"gte\":\n      return a >= b;\n    case \"lt\":\n      return a < b;\n    case \"lte\":\n      return a <= b;\n  }\n}\nvar LogicalExpr = class extends Expr {\n  _left;\n  _right;\n  _op;\n  constructor(left, right, op) {\n    super();\n    this._left = left;\n    this._right = right;\n    this._op = op;\n  }\n  get dependencies() {\n    return [.../* @__PURE__ */ new Set([...this._left.dependencies, ...this._right.dependencies])];\n  }\n  toString() {\n    return `(${this._left.toString()} ${this._op.toUpperCase()} ${this._right.toString()})`;\n  }\n  evaluate(df2) {\n    const leftSeries = this._left.evaluate(df2);\n    const rightSeries = this._right.evaluate(df2);\n    const len = leftSeries.length;\n    const results = [];\n    for (let i = 0; i < len; i++) {\n      const a = leftSeries.get(i);\n      const b = rightSeries.get(i);\n      if (a === null || b === null) {\n        results.push(null);\n      } else if (this._op === \"and\") {\n        results.push(a && b);\n      } else {\n        results.push(a || b);\n      }\n    }\n    return new Series(\"\", BooleanColumn.from(results));\n  }\n};\nvar NotExpr = class extends Expr {\n  _inner;\n  constructor(inner) {\n    super();\n    this._inner = inner;\n  }\n  get dependencies() {\n    return this._inner.dependencies;\n  }\n  toString() {\n    return `NOT ${this._inner.toString()}`;\n  }\n  evaluate(df2) {\n    const innerSeries = this._inner.evaluate(df2);\n    const len = innerSeries.length;\n    const results = [];\n    for (let i = 0; i < len; i++) {\n      const v = innerSeries.get(i);\n      results.push(v === null ? null : !v);\n    }\n    return new Series(\"\", BooleanColumn.from(results));\n  }\n};\nfunction col(name) {\n  return new ColumnExpr(name);\n}\nfunction lit(value) {\n  return new LiteralExpr(value);\n}\nfunction toComparableKey(v) {\n  if (v instanceof Date) return `\\0date${v.getTime()}`;\n  if (typeof v === \"string\") return `\\0str${v}`;\n  if (typeof v === \"number\") return `\\0num${v}`;\n  if (typeof v === \"boolean\") return `\\0bool${v}`;\n  return `\\0other${String(v)}`;\n}\nvar AggExpr = class extends Expr {\n  _columnName;\n  constructor(columnName) {\n    super();\n    this._columnName = columnName;\n  }\n  get dependencies() {\n    return [this._columnName];\n  }\n  toString() {\n    return `${this._aggName}(${this._columnName})`;\n  }\n  evaluate(df2) {\n    const result = this.evaluateFrame(df2);\n    const values = [result];\n    const col2 = Float64Column.from(values);\n    return new Series(\"\", col2);\n  }\n  evaluateFrame(df2) {\n    const series = df2.col(this._columnName);\n    return this.evaluateColumn(series.column);\n  }\n};\nvar SumAggExpr = class extends AggExpr {\n  _aggName = \"sum\";\n  evaluateColumn(column) {\n    let total = 0;\n    for (let i = 0; i < column.length; i++) {\n      const v = column.get(i);\n      if (v !== null && typeof v === \"number\") {\n        total += v;\n      }\n    }\n    return total;\n  }\n};\nvar MeanAggExpr = class extends AggExpr {\n  _aggName = \"mean\";\n  evaluateColumn(column) {\n    let total = 0;\n    let count = 0;\n    for (let i = 0; i < column.length; i++) {\n      const v = column.get(i);\n      if (v !== null && typeof v === \"number\") {\n        total += v;\n        count++;\n      }\n    }\n    return count === 0 ? null : total / count;\n  }\n};\nvar CountAggExpr = class extends AggExpr {\n  _aggName = \"count\";\n  evaluateColumn(column) {\n    let count = 0;\n    for (let i = 0; i < column.length; i++) {\n      if (column.get(i) !== null) {\n        count++;\n      }\n    }\n    return count;\n  }\n};\nvar CountDistinctAggExpr = class extends AggExpr {\n  _aggName = \"count_distinct\";\n  evaluateColumn(column) {\n    const seen = /* @__PURE__ */ new Set();\n    for (let i = 0; i < column.length; i++) {\n      const v = column.get(i);\n      if (v !== null) {\n        seen.add(toComparableKey(v));\n      }\n    }\n    return seen.size;\n  }\n};\nvar MinAggExpr = class extends AggExpr {\n  _aggName = \"min\";\n  evaluateColumn(column) {\n    let result = null;\n    for (let i = 0; i < column.length; i++) {\n      const v = column.get(i);\n      if (v !== null && typeof v === \"number\") {\n        if (result === null || v < result) {\n          result = v;\n        }\n      }\n    }\n    return result;\n  }\n};\nvar MaxAggExpr = class extends AggExpr {\n  _aggName = \"max\";\n  evaluateColumn(column) {\n    let result = null;\n    for (let i = 0; i < column.length; i++) {\n      const v = column.get(i);\n      if (v !== null && typeof v === \"number\") {\n        if (result === null || v > result) {\n          result = v;\n        }\n      }\n    }\n    return result;\n  }\n};\nvar StdAggExpr = class extends AggExpr {\n  _aggName = \"std\";\n  evaluateColumn(column) {\n    const values = [];\n    for (let i = 0; i < column.length; i++) {\n      const v = column.get(i);\n      if (v !== null && typeof v === \"number\") {\n        values.push(v);\n      }\n    }\n    if (values.length < 2) return null;\n    const mean = values.reduce((a, b) => a + b, 0) / values.length;\n    const sumSqDiff = values.reduce((acc, v) => acc + (v - mean) ** 2, 0);\n    return Math.sqrt(sumSqDiff / (values.length - 1));\n  }\n};\nvar FirstAggExpr = class extends AggExpr {\n  _aggName = \"first\";\n  evaluateColumn(column) {\n    for (let i = 0; i < column.length; i++) {\n      const v = column.get(i);\n      if (v !== null) {\n        return v;\n      }\n    }\n    return null;\n  }\n};\nvar LastAggExpr = class extends AggExpr {\n  _aggName = \"last\";\n  evaluateColumn(column) {\n    for (let i = column.length - 1; i >= 0; i--) {\n      const v = column.get(i);\n      if (v !== null) {\n        return v;\n      }\n    }\n    return null;\n  }\n};\nvar ListAggExpr = class extends AggExpr {\n  _aggName = \"list\";\n  evaluateColumn(column) {\n    const result = [];\n    for (let i = 0; i < column.length; i++) {\n      const v = column.get(i);\n      if (v !== null) {\n        result.push(v);\n      }\n    }\n    return result;\n  }\n};\nvar ModeAggExpr = class extends AggExpr {\n  _aggName = \"mode\";\n  evaluateColumn(column) {\n    const counts = /* @__PURE__ */ new Map();\n    for (let i = 0; i < column.length; i++) {\n      const v = column.get(i);\n      if (v !== null) {\n        const key = toComparableKey(v);\n        const entry = counts.get(key);\n        if (entry) {\n          entry.count++;\n        } else {\n          counts.set(key, { value: v, count: 1 });\n        }\n      }\n    }\n    let best = null;\n    let bestCount = 0;\n    for (const entry of counts.values()) {\n      if (entry.count > bestCount) {\n        best = entry.value;\n        bestCount = entry.count;\n      }\n    }\n    return best;\n  }\n};\nvar CoalesceExpr = class extends Expr {\n  _exprs;\n  constructor(exprs) {\n    super();\n    this._exprs = exprs;\n  }\n  get dependencies() {\n    const deps = /* @__PURE__ */ new Set();\n    for (const e of this._exprs) {\n      for (const d of e.dependencies) {\n        deps.add(d);\n      }\n    }\n    return [...deps];\n  }\n  toString() {\n    return `coalesce(${this._exprs.map((e) => e.toString()).join(\", \")})`;\n  }\n  evaluate(df2) {\n    const evaluated = this._exprs.map((e) => e.evaluate(df2));\n    const len = evaluated[0].length;\n    const results = [];\n    for (let i = 0; i < len; i++) {\n      let found = null;\n      for (const s of evaluated) {\n        const v = s.get(i);\n        if (v !== null) {\n          found = v;\n          break;\n        }\n      }\n      results.push(found);\n    }\n    const firstSeries = evaluated[0];\n    const dtype = firstSeries.column.dtype;\n    const col2 = buildColumnForValues(dtype, results);\n    return new Series(\"\", col2);\n  }\n};\nvar FillNullExpr = class extends Expr {\n  _inner;\n  _fill;\n  constructor(inner, fill) {\n    super();\n    this._inner = inner;\n    this._fill = fill;\n  }\n  get dependencies() {\n    return [.../* @__PURE__ */ new Set([...this._inner.dependencies, ...this._fill.dependencies])];\n  }\n  toString() {\n    return `fillNull(${this._inner.toString()}, ${this._fill.toString()})`;\n  }\n  evaluate(df2) {\n    const innerSeries = this._inner.evaluate(df2);\n    const fillSeries = this._fill.evaluate(df2);\n    const len = innerSeries.length;\n    const results = [];\n    for (let i = 0; i < len; i++) {\n      const v = innerSeries.get(i);\n      results.push(v !== null ? v : fillSeries.get(i));\n    }\n    const dtype = innerSeries.column.dtype;\n    const col2 = buildColumnForValues(dtype, results);\n    return new Series(\"\", col2);\n  }\n};\nvar IsNullExpr = class extends Expr {\n  _inner;\n  constructor(inner) {\n    super();\n    this._inner = inner;\n  }\n  get dependencies() {\n    return this._inner.dependencies;\n  }\n  toString() {\n    return `${this._inner.toString()} IS NULL`;\n  }\n  evaluate(df2) {\n    const innerSeries = this._inner.evaluate(df2);\n    const len = innerSeries.length;\n    const results = [];\n    for (let i = 0; i < len; i++) {\n      results.push(innerSeries.get(i) === null);\n    }\n    return new Series(\"\", BooleanColumn.from(results));\n  }\n};\nvar IsNotNullExpr = class extends Expr {\n  _inner;\n  constructor(inner) {\n    super();\n    this._inner = inner;\n  }\n  get dependencies() {\n    return this._inner.dependencies;\n  }\n  toString() {\n    return `${this._inner.toString()} IS NOT NULL`;\n  }\n  evaluate(df2) {\n    const innerSeries = this._inner.evaluate(df2);\n    const len = innerSeries.length;\n    const results = [];\n    for (let i = 0; i < len; i++) {\n      results.push(innerSeries.get(i) !== null);\n    }\n    return new Series(\"\", BooleanColumn.from(results));\n  }\n};\n\n// src/io/csv/parser.ts\nvar DEFAULT_NULL_VALUES = [\"\", \"null\", \"NULL\", \"NA\", \"N/A\", \"NaN\", \"nan\", \"None\", \"none\"];\nfunction parseCSV(content, options = {}) {\n  const lines = splitLines(content, options);\n  if (lines.length === 0) {\n    return { header: [], columns: {}, inferredTypes: {} };\n  }\n  const delimiter = options.delimiter ?? detectDelimiter(lines.slice(0, 10));\n  const hasHeader = options.hasHeader !== false;\n  const nullValues = new Set(options.nullValues ?? DEFAULT_NULL_VALUES);\n  const allRows = lines.map((line) => parseLine(line, delimiter));\n  let dataStart = 0;\n  if (options.skipRows && options.skipRows > 0) {\n    dataStart = options.skipRows;\n  }\n  let header;\n  let rowStart;\n  if (options.header) {\n    header = options.header;\n    rowStart = dataStart + (hasHeader ? 1 : 0);\n  } else if (hasHeader && dataStart < allRows.length) {\n    header = allRows[dataStart].map((h) => h.trim());\n    rowStart = dataStart + 1;\n  } else {\n    const firstRow = allRows[dataStart];\n    if (!firstRow) {\n      return { header: [], columns: {}, inferredTypes: {} };\n    }\n    header = firstRow.map((_, i) => `column_${i}`);\n    rowStart = dataStart;\n  }\n  let rowEnd = allRows.length;\n  if (options.nRows !== void 0 && options.nRows >= 0) {\n    rowEnd = Math.min(rowEnd, rowStart + options.nRows);\n  }\n  const selectedColumns = options.columns ? new Set(options.columns) : null;\n  const columns = {};\n  const activeHeader = [];\n  for (const name of header) {\n    if (selectedColumns && !selectedColumns.has(name)) continue;\n    activeHeader.push(name);\n    columns[name] = [];\n  }\n  const headerIndexMap = /* @__PURE__ */ new Map();\n  for (let i = 0; i < header.length; i++) {\n    const name = header[i];\n    if (selectedColumns && !selectedColumns.has(name)) continue;\n    headerIndexMap.set(i, name);\n  }\n  for (let r = rowStart; r < rowEnd; r++) {\n    const row = allRows[r];\n    if (!row) continue;\n    for (const [colIdx, colName] of headerIndexMap) {\n      const raw = colIdx < row.length ? row[colIdx] : \"\";\n      const value = nullValues.has(raw) ? null : raw;\n      columns[colName].push(value);\n    }\n  }\n  const inferredTypes = inferColumnTypes(columns, activeHeader, options);\n  return { header: activeHeader, columns, inferredTypes };\n}\nfunction splitLines(content, options) {\n  const comment = options.comment;\n  const lines = [];\n  let current = \"\";\n  let inQuotes = false;\n  for (let i = 0; i < content.length; i++) {\n    const ch = content[i];\n    if (ch === '\"') {\n      if (inQuotes && i + 1 < content.length && content[i + 1] === '\"') {\n        current += '\"\"';\n        i++;\n      } else {\n        inQuotes = !inQuotes;\n        current += ch;\n      }\n    } else if ((ch === \"\\n\" || ch === \"\\r\") && !inQuotes) {\n      if (ch === \"\\r\" && i + 1 < content.length && content[i + 1] === \"\\n\") {\n        i++;\n      }\n      if (current.length > 0 || lines.length > 0) {\n        if (!comment || !current.trimStart().startsWith(comment)) {\n          lines.push(current);\n        }\n      }\n      current = \"\";\n    } else {\n      current += ch;\n    }\n  }\n  if (current.length > 0) {\n    if (!comment || !current.trimStart().startsWith(comment)) {\n      lines.push(current);\n    }\n  }\n  return lines;\n}\nfunction parseLine(line, delimiter) {\n  const fields = [];\n  let current = \"\";\n  let inQuotes = false;\n  let i = 0;\n  while (i < line.length) {\n    const ch = line[i];\n    if (inQuotes) {\n      if (ch === '\"') {\n        if (i + 1 < line.length && line[i + 1] === '\"') {\n          current += '\"';\n          i += 2;\n        } else {\n          inQuotes = false;\n          i++;\n        }\n      } else {\n        current += ch;\n        i++;\n      }\n    } else {\n      if (ch === '\"' && current.length === 0) {\n        inQuotes = true;\n        i++;\n      } else if (line.startsWith(delimiter, i)) {\n        fields.push(current);\n        current = \"\";\n        i += delimiter.length;\n      } else {\n        current += ch;\n        i++;\n      }\n    }\n  }\n  if (inQuotes) {\n    throw new ParseError(\"Unterminated quoted field in CSV\");\n  }\n  fields.push(current);\n  return fields;\n}\nfunction detectDelimiter(lines) {\n  const candidates = [\",\", \";\", \"\t\", \"|\"];\n  let bestDelimiter = \",\";\n  let bestScore = -1;\n  for (const delim of candidates) {\n    const counts = lines.map((line) => {\n      let count = 0;\n      let inQuotes = false;\n      for (let i = 0; i < line.length; i++) {\n        const ch = line[i];\n        if (ch === '\"') inQuotes = !inQuotes;\n        else if (!inQuotes && line.startsWith(delim, i)) count++;\n      }\n      return count;\n    });\n    if (counts.length === 0) continue;\n    const avg = counts.reduce((a, b) => a + b, 0) / counts.length;\n    if (avg === 0) continue;\n    const allSame = counts.every((c) => c === counts[0]);\n    const score = allSame ? avg * 2 : avg;\n    if (score > bestScore) {\n      bestScore = score;\n      bestDelimiter = delim;\n    }\n  }\n  return bestDelimiter;\n}\nfunction inferColumnTypes(columns, header, options) {\n  const types = {};\n  const parseNumbers = options.parseNumbers !== false;\n  const parseDates = options.parseDates !== false;\n  for (const name of header) {\n    if (options.dtypes && name in options.dtypes) {\n      types[name] = options.dtypes[name];\n      continue;\n    }\n    const values = columns[name];\n    const sample = values.slice(0, 100).filter((v) => v !== null);\n    if (sample.length === 0) {\n      types[name] = \"utf8\" /* Utf8 */;\n      continue;\n    }\n    if (parseNumbers && sample.every(isNumericString)) {\n      types[name] = sample.every(isIntegerString) ? \"i32\" /* Int32 */ : \"f64\" /* Float64 */;\n      continue;\n    }\n    if (sample.every(isBooleanString)) {\n      types[name] = \"bool\" /* Boolean */;\n      continue;\n    }\n    if (parseDates && sample.every(isDateString)) {\n      types[name] = \"date\" /* Date */;\n      continue;\n    }\n    types[name] = \"utf8\" /* Utf8 */;\n  }\n  return types;\n}\nfunction isNumericString(s) {\n  if (s.length === 0) return false;\n  const n = Number(s);\n  return !Number.isNaN(n) && s.trim().length > 0;\n}\nfunction isIntegerString(s) {\n  if (!isNumericString(s)) return false;\n  const n = Number(s);\n  return Number.isInteger(n) && !s.includes(\".\") && !s.includes(\"e\") && !s.includes(\"E\");\n}\nfunction isBooleanString(s) {\n  const lower = s.toLowerCase();\n  return lower === \"true\" || lower === \"false\";\n}\nvar ISO_DATE_RE = /^\\d{4}-\\d{2}-\\d{2}(T\\d{2}:\\d{2}(:\\d{2})?(\\.\\d+)?(Z|[+-]\\d{2}:?\\d{2})?)?$/;\nfunction isDateString(s) {\n  if (!ISO_DATE_RE.test(s)) return false;\n  const d = new Date(s);\n  return !Number.isNaN(d.getTime());\n}\n\n// src/io/csv/writer.ts\nfunction writeCSV(header, rows, options = {}) {\n  const delimiter = options.delimiter ?? \",\";\n  const quoteStyle = options.quoteStyle ?? \"necessary\";\n  const nullValue = options.nullValue ?? \"\";\n  const includeHeader = options.header !== false;\n  const bom = options.bom === true;\n  const lines = [];\n  if (bom) {\n    lines.push(\"\\uFEFF\");\n  }\n  if (includeHeader) {\n    lines.push(header.map((h) => quoteField(h, delimiter, quoteStyle)).join(delimiter));\n  }\n  for (const row of rows) {\n    const fields = row.map((value) => {\n      if (value === null || value === void 0) {\n        return quoteField(nullValue, delimiter, quoteStyle);\n      }\n      if (value instanceof Date) {\n        return quoteField(value.toISOString(), delimiter, quoteStyle);\n      }\n      if (typeof value === \"number\" || typeof value === \"string\" || typeof value === \"boolean\") {\n        return quoteField(String(value), delimiter, quoteStyle);\n      }\n      return quoteField(JSON.stringify(value), delimiter, quoteStyle);\n    });\n    lines.push(fields.join(delimiter));\n  }\n  return lines.join(\"\\n\") + \"\\n\";\n}\nfunction quoteField(value, delimiter, quoteStyle) {\n  if (quoteStyle === \"never\") {\n    return value;\n  }\n  if (quoteStyle === \"always\") {\n    return '\"' + value.replace(/\"/g, '\"\"') + '\"';\n  }\n  if (value.includes(delimiter) || value.includes('\"') || value.includes(\"\\n\") || value.includes(\"\\r\")) {\n    return '\"' + value.replace(/\"/g, '\"\"') + '\"';\n  }\n  return value;\n}\n\n// src/engine/streaming/scanner.ts\nvar DEFAULT_NULL_VALUES2 = [\"\", \"null\", \"NULL\", \"NA\", \"N/A\", \"NaN\", \"nan\", \"None\", \"none\"];\nasync function* streamCSVFile(filePath, options = {}) {\n  const chunkSize = options.chunkSize ?? 1e4;\n  const fs = await import(\"fs\");\n  const { createReadStream } = fs;\n  let stream;\n  try {\n    stream = createReadStream(filePath, { encoding: options.encoding ?? \"utf-8\" });\n  } catch (err) {\n    const message = err instanceof Error ? err.message : String(err);\n    throw new IOError(`Failed to open CSV file '${filePath}': ${message}`);\n  }\n  const hasHeader = options.hasHeader !== false;\n  const nullValues = new Set(options.nullValues ?? DEFAULT_NULL_VALUES2);\n  const comment = options.comment;\n  const skipRows = options.skipRows ?? 0;\n  let schema = null;\n  let buffer = \"\";\n  let inQuotes = false;\n  let pendingLines = [];\n  let linesSkipped = 0;\n  let headerConsumed = false;\n  let chunkRows = {};\n  let rowCount = 0;\n  let totalRowsEmitted = 0;\n  const nRows = options.nRows;\n  function parseLine2(line, delimiter) {\n    const fields = [];\n    let current = \"\";\n    let quoted = false;\n    let i = 0;\n    while (i < line.length) {\n      const ch = line[i];\n      if (quoted) {\n        if (ch === '\"') {\n          if (i + 1 < line.length && line[i + 1] === '\"') {\n            current += '\"';\n            i += 2;\n          } else {\n            quoted = false;\n            i++;\n          }\n        } else {\n          current += ch;\n          i++;\n        }\n      } else {\n        if (ch === '\"' && current.length === 0) {\n          quoted = true;\n          i++;\n        } else if (line.startsWith(delimiter, i)) {\n          fields.push(current);\n          current = \"\";\n          i += delimiter.length;\n        } else {\n          current += ch;\n          i++;\n        }\n      }\n    }\n    if (quoted) {\n      throw new ParseError(\"Unterminated quoted field in CSV\");\n    }\n    fields.push(current);\n    return fields;\n  }\n  function detectDelimiter2(lines) {\n    const candidates = [\",\", \";\", \"\t\", \"|\"];\n    let bestDelimiter = \",\";\n    let bestScore = -1;\n    for (const delim of candidates) {\n      const counts = lines.map((line) => {\n        let count = 0;\n        let q = false;\n        for (let i = 0; i < line.length; i++) {\n          const ch = line[i];\n          if (ch === '\"') q = !q;\n          else if (!q && line.startsWith(delim, i)) count++;\n        }\n        return count;\n      });\n      if (counts.length === 0) continue;\n      const avg = counts.reduce((a, b) => a + b, 0) / counts.length;\n      if (avg === 0) continue;\n      const allSame = counts.every((c) => c === counts[0]);\n      const score = allSame ? avg * 2 : avg;\n      if (score > bestScore) {\n        bestScore = score;\n        bestDelimiter = delim;\n      }\n    }\n    return bestDelimiter;\n  }\n  function inferTypes(columns, header, opts) {\n    const types = {};\n    const parseNumbers = opts.parseNumbers !== false;\n    const parseDates = opts.parseDates !== false;\n    for (const name of header) {\n      if (opts.dtypes && name in opts.dtypes) {\n        types[name] = opts.dtypes[name];\n        continue;\n      }\n      const values = columns[name];\n      const sample = values.slice(0, 100).filter((v) => v !== null);\n      if (sample.length === 0) {\n        types[name] = \"utf8\" /* Utf8 */;\n        continue;\n      }\n      if (parseNumbers && sample.every(isNumericString2)) {\n        types[name] = sample.every(isIntegerString2) ? \"i32\" /* Int32 */ : \"f64\" /* Float64 */;\n        continue;\n      }\n      if (sample.every(isBooleanString2)) {\n        types[name] = \"bool\" /* Boolean */;\n        continue;\n      }\n      if (parseDates && sample.every(isDateString2)) {\n        types[name] = \"date\" /* Date */;\n        continue;\n      }\n      types[name] = \"utf8\" /* Utf8 */;\n    }\n    return types;\n  }\n  function initChunkRows(header) {\n    const cols = {};\n    for (const name of header) {\n      cols[name] = [];\n    }\n    return cols;\n  }\n  function addRowToChunk(fields, schema2) {\n    for (let i = 0; i < schema2.header.length; i++) {\n      const name = schema2.header[i];\n      const raw = i < fields.length ? fields[i] : \"\";\n      const value = schema2.nullValues.has(raw) ? null : raw;\n      chunkRows[name].push(value);\n    }\n    rowCount++;\n  }\n  let parsedHeader = null;\n  let detectedDelimiter = null;\n  function processLine(line) {\n    if (comment && line.trimStart().startsWith(comment)) {\n      return null;\n    }\n    if (linesSkipped < skipRows) {\n      linesSkipped++;\n      return null;\n    }\n    if (!headerConsumed) {\n      detectedDelimiter = options.delimiter ?? detectDelimiter2([line]);\n      if (options.header) {\n        parsedHeader = options.header;\n        pendingLines.push(line);\n      } else if (hasHeader) {\n        parsedHeader = parseLine2(line, detectedDelimiter).map((h) => h.trim());\n      } else {\n        const firstFields = parseLine2(line, detectedDelimiter);\n        parsedHeader = firstFields.map((_, i) => `column_${i}`);\n        pendingLines.push(line);\n      }\n      headerConsumed = true;\n      return null;\n    }\n    if (!schema) {\n      pendingLines.push(line);\n      const delimiter = detectedDelimiter;\n      const header = parsedHeader;\n      const tempCols = initChunkRows(header);\n      for (const pl of pendingLines) {\n        const fields2 = parseLine2(pl, delimiter);\n        for (let i = 0; i < header.length; i++) {\n          const name = header[i];\n          const raw = i < fields2.length ? fields2[i] : \"\";\n          const value = nullValues.has(raw) ? null : raw;\n          tempCols[name].push(value);\n        }\n      }\n      const inferredTypes = inferTypes(tempCols, header, options);\n      schema = { header, delimiter, nullValues, inferredTypes };\n      chunkRows = initChunkRows(header);\n      for (const pl of pendingLines) {\n        const fields2 = parseLine2(pl, delimiter);\n        addRowToChunk(fields2, schema);\n      }\n      pendingLines = [];\n      if (rowCount >= chunkSize) {\n        const result = { header: schema.header, rawColumns: chunkRows, inferredTypes: schema.inferredTypes };\n        chunkRows = initChunkRows(schema.header);\n        totalRowsEmitted += rowCount;\n        rowCount = 0;\n        return result;\n      }\n      return null;\n    }\n    const fields = parseLine2(line, schema.delimiter);\n    addRowToChunk(fields, schema);\n    if (rowCount >= chunkSize) {\n      const result = { header: schema.header, rawColumns: chunkRows, inferredTypes: schema.inferredTypes };\n      chunkRows = initChunkRows(schema.header);\n      totalRowsEmitted += rowCount;\n      rowCount = 0;\n      return result;\n    }\n    return null;\n  }\n  for await (const rawChunk of stream) {\n    buffer += rawChunk;\n    let lineStart = 0;\n    for (let i = 0; i < buffer.length; i++) {\n      const ch = buffer[i];\n      if (ch === '\"') {\n        inQuotes = !inQuotes;\n      } else if (!inQuotes && (ch === \"\\n\" || ch === \"\\r\")) {\n        const line = buffer.slice(lineStart, i);\n        if (ch === \"\\r\" && i + 1 < buffer.length && buffer[i + 1] === \"\\n\") {\n          i++;\n        }\n        lineStart = i + 1;\n        if (line.length > 0) {\n          if (nRows !== void 0 && totalRowsEmitted + rowCount >= nRows) {\n            break;\n          }\n          const result = processLine(line);\n          if (result) {\n            yield result;\n            if (nRows !== void 0 && totalRowsEmitted >= nRows) {\n              stream.destroy();\n              return;\n            }\n          }\n        }\n      }\n    }\n    buffer = buffer.slice(lineStart);\n    if (nRows !== void 0 && totalRowsEmitted >= nRows) {\n      stream.destroy();\n      return;\n    }\n  }\n  if (buffer.length > 0 && !(nRows !== void 0 && totalRowsEmitted >= nRows)) {\n    if (!comment || !buffer.trimStart().startsWith(comment)) {\n      processLine(buffer);\n    }\n  }\n  const finalSchema = schema;\n  if (rowCount > 0 && finalSchema !== null) {\n    if (nRows !== void 0) {\n      const remaining = nRows - totalRowsEmitted;\n      if (remaining <= 0) return;\n      if (remaining < rowCount) {\n        for (const name of finalSchema.header) {\n          chunkRows[name] = chunkRows[name].slice(0, remaining);\n        }\n      }\n    }\n    yield { header: finalSchema.header, rawColumns: chunkRows, inferredTypes: finalSchema.inferredTypes };\n  }\n}\nfunction isNumericString2(s) {\n  if (s.length === 0) return false;\n  const n = Number(s);\n  return !Number.isNaN(n) && s.trim().length > 0;\n}\nfunction isIntegerString2(s) {\n  if (!isNumericString2(s)) return false;\n  const n = Number(s);\n  return Number.isInteger(n) && !s.includes(\".\") && !s.includes(\"e\") && !s.includes(\"E\");\n}\nfunction isBooleanString2(s) {\n  const lower = s.toLowerCase();\n  return lower === \"true\" || lower === \"false\";\n}\nvar ISO_DATE_RE2 = /^\\d{4}-\\d{2}-\\d{2}(T\\d{2}:\\d{2}(:\\d{2})?(\\.\\d+)?(Z|[+-]\\d{2}:?\\d{2})?)?$/;\nfunction isDateString2(s) {\n  if (!ISO_DATE_RE2.test(s)) return false;\n  const d = new Date(s);\n  return !Number.isNaN(d.getTime());\n}\n\n// src/engine/streaming/ndjson-scanner.ts\nasync function* streamNDJSONFile(filePath, options = {}) {\n  const chunkSize = options.chunkSize ?? 1e4;\n  const nRows = options.nRows;\n  const fs = await import(\"fs\");\n  const { createReadStream } = fs;\n  let stream;\n  try {\n    stream = createReadStream(filePath, { encoding: options.encoding ?? \"utf-8\" });\n  } catch (err) {\n    const message = err instanceof Error ? err.message : String(err);\n    throw new IOError(`Failed to open NDJSON file '${filePath}': ${message}`);\n  }\n  let buffer = \"\";\n  let chunk = [];\n  let totalEmitted = 0;\n  for await (const rawChunk of stream) {\n    buffer += rawChunk;\n    let lineStart = 0;\n    for (let i = 0; i < buffer.length; i++) {\n      const ch = buffer[i];\n      if (ch === \"\\n\" || ch === \"\\r\") {\n        const line = buffer.slice(lineStart, i);\n        if (ch === \"\\r\" && i + 1 < buffer.length && buffer[i + 1] === \"\\n\") {\n          i++;\n        }\n        lineStart = i + 1;\n        if (line.trim().length > 0) {\n          chunk.push(JSON.parse(line));\n          if (chunk.length >= chunkSize) {\n            yield chunk;\n            totalEmitted += chunk.length;\n            chunk = [];\n            if (nRows !== void 0 && totalEmitted >= nRows) {\n              stream.destroy();\n              return;\n            }\n          }\n        }\n      }\n    }\n    buffer = buffer.slice(lineStart);\n  }\n  if (buffer.trim().length > 0) {\n    chunk.push(JSON.parse(buffer));\n  }\n  if (chunk.length > 0) {\n    if (nRows !== void 0) {\n      const remaining = nRows - totalEmitted;\n      if (remaining <= 0) return;\n      if (remaining < chunk.length) {\n        chunk = chunk.slice(0, remaining);\n      }\n    }\n    yield chunk;\n  }\n}\n\n// src/io/json/writer.ts\nfunction writeJSON(header, rows, options = {}) {\n  const objects = [];\n  for (const row of rows) {\n    const obj = {};\n    for (let i = 0; i < header.length; i++) {\n      const value = row[i];\n      if (value instanceof Date) {\n        obj[header[i]] = value.toISOString();\n      } else {\n        obj[header[i]] = value ?? null;\n      }\n    }\n    objects.push(obj);\n  }\n  if (options.pretty) {\n    return JSON.stringify(objects, null, 2);\n  }\n  return JSON.stringify(objects);\n}\nfunction writeNDJSON(header, rows) {\n  const lines = [];\n  for (const row of rows) {\n    const obj = {};\n    for (let i = 0; i < header.length; i++) {\n      const value = row[i];\n      if (value instanceof Date) {\n        obj[header[i]] = value.toISOString();\n      } else {\n        obj[header[i]] = value ?? null;\n      }\n    }\n    lines.push(JSON.stringify(obj));\n  }\n  return lines.join(\"\\n\") + \"\\n\";\n}\n\n// src/io/excel/reader.ts\nfunction detectCellDType(value) {\n  if (value === null || value === void 0) return \"f64\" /* Float64 */;\n  if (typeof value === \"number\") return \"f64\" /* Float64 */;\n  if (typeof value === \"boolean\") return \"bool\" /* Boolean */;\n  if (value instanceof Date) return \"date\" /* Date */;\n  if (typeof value === \"string\") return \"utf8\" /* Utf8 */;\n  if (typeof value === \"object\") return \"object\" /* Object */;\n  return \"utf8\" /* Utf8 */;\n}\nfunction parseCellRef(ref) {\n  const match = /^([A-Z]+)(\\d+)$/.exec(ref.toUpperCase());\n  if (!match) throw new IOError(`Invalid cell reference: '${ref}'`);\n  const colStr = match[1];\n  const rowNum = parseInt(match[2], 10);\n  let colNum = 0;\n  for (let i = 0; i < colStr.length; i++) {\n    colNum = colNum * 26 + (colStr.charCodeAt(i) - 64);\n  }\n  return { col: colNum, row: rowNum };\n}\nfunction parseRange(range) {\n  const parts = range.split(\":\");\n  if (parts.length !== 2) throw new IOError(`Invalid range format: '${range}'. Expected format like 'A1:G100'`);\n  const start = parseCellRef(parts[0]);\n  const end = parseCellRef(parts[1]);\n  return { startCol: start.col, startRow: start.row, endCol: end.col, endRow: end.row };\n}\nfunction getWorksheet(workbook, sheet) {\n  if (sheet === void 0 || sheet === 0) {\n    const ws2 = workbook.worksheets[0];\n    if (!ws2) throw new IOError(\"Workbook contains no worksheets\");\n    return ws2;\n  }\n  if (typeof sheet === \"number\") {\n    const ws2 = workbook.worksheets[sheet];\n    if (!ws2) throw new IOError(`Worksheet at index ${String(sheet)} not found`);\n    return ws2;\n  }\n  const ws = workbook.getWorksheet(sheet);\n  if (!ws) throw new IOError(`Worksheet '${sheet}' not found`);\n  return ws;\n}\nfunction normalizeCellValue(value) {\n  if (value === null || value === void 0) return null;\n  if (typeof value === \"object\" && value !== null && !Array.isArray(value) && !(value instanceof Date)) {\n    if (\"richText\" in value) {\n      return value.richText.map((t) => String(t.text)).join(\"\");\n    }\n    if (\"result\" in value) {\n      return value.result;\n    }\n  }\n  return value;\n}\nfunction parseExcelWorksheet(worksheet, options = {}) {\n  const hasHeader = options.hasHeader !== false;\n  const rangeDef = options.range;\n  let startRow;\n  let endRow;\n  let startCol;\n  let endCol;\n  if (rangeDef) {\n    const r = parseRange(rangeDef);\n    startRow = r.startRow;\n    endRow = r.endRow;\n    startCol = r.startCol;\n    endCol = r.endCol;\n  } else {\n    startRow = 1;\n    endRow = worksheet.rowCount;\n    startCol = 1;\n    endCol = worksheet.columnCount;\n  }\n  if (endRow < startRow || endCol < startCol) {\n    return { header: [], columns: {}, inferredTypes: {} };\n  }\n  const rawRows = [];\n  for (let r = startRow; r <= endRow; r++) {\n    const row = worksheet.getRow(r);\n    const rowValues = [];\n    for (let c = startCol; c <= endCol; c++) {\n      const cell = row.getCell(c);\n      rowValues.push(normalizeCellValue(cell.value));\n    }\n    rawRows.push(rowValues);\n  }\n  let header;\n  let dataStartIdx;\n  if (hasHeader && rawRows.length > 0) {\n    header = rawRows[0].map((v, i) => {\n      if (v === null || v === void 0) return `column_${String(i)}`;\n      if (typeof v === \"string\") return v;\n      if (typeof v === \"number\" || typeof v === \"boolean\" || typeof v === \"bigint\") return String(v);\n      if (v instanceof Date) return v.toISOString();\n      return `column_${String(i)}`;\n    });\n    dataStartIdx = 1;\n  } else {\n    const colCount = endCol - startCol + 1;\n    header = Array.from({ length: colCount }, (_, i) => `column_${String(i)}`);\n    dataStartIdx = 0;\n  }\n  const columns = {};\n  for (const name of header) {\n    columns[name] = [];\n  }\n  for (let i = dataStartIdx; i < rawRows.length; i++) {\n    const row = rawRows[i];\n    for (let j = 0; j < header.length; j++) {\n      const colName = header[j];\n      columns[colName].push(j < row.length ? row[j] ?? null : null);\n    }\n  }\n  const inferredTypes = {};\n  for (const name of header) {\n    if (options.dtypes?.[name] !== void 0) {\n      inferredTypes[name] = options.dtypes[name];\n    } else {\n      const colValues = columns[name];\n      let detected = \"f64\" /* Float64 */;\n      for (const v of colValues) {\n        if (v !== null && v !== void 0) {\n          detected = detectCellDType(v);\n          break;\n        }\n      }\n      inferredTypes[name] = detected;\n    }\n  }\n  return { header, columns, inferredTypes };\n}\nasync function readExcelFile(filePath, options = {}) {\n  let ExcelJS;\n  try {\n    ExcelJS = await import(\"exceljs\");\n  } catch {\n    throw new IOError(\n      \"exceljs is required to read Excel files but is not installed. Run: npm install exceljs\"\n    );\n  }\n  try {\n    const workbook = new ExcelJS.Workbook();\n    await workbook.xlsx.readFile(filePath);\n    const worksheet = getWorksheet(workbook, options.sheet);\n    return parseExcelWorksheet(worksheet, options);\n  } catch (err) {\n    if (err instanceof IOError) throw err;\n    const message = err instanceof Error ? err.message : String(err);\n    throw new IOError(`Failed to read Excel file '${filePath}': ${message}`);\n  }\n}\n\n// src/io/parquet/reader.ts\nfunction arrowTypeToDType(field) {\n  const typeStr = field.type?.toString?.() ?? String(field.type);\n  const lower = typeStr.toLowerCase();\n  if (lower.includes(\"int32\") || lower.includes(\"int16\") || lower.includes(\"int8\")) {\n    return \"i32\" /* Int32 */;\n  }\n  if (lower.includes(\"int64\") || lower.includes(\"int\") || lower.includes(\"uint\")) {\n    return \"f64\" /* Float64 */;\n  }\n  if (lower.includes(\"float\") || lower.includes(\"double\") || lower.includes(\"decimal\")) {\n    return \"f64\" /* Float64 */;\n  }\n  if (lower.includes(\"utf8\") || lower.includes(\"string\") || lower.includes(\"largestring\") || lower.includes(\"largeutf8\")) {\n    return \"utf8\" /* Utf8 */;\n  }\n  if (lower === \"bool\" || lower.includes(\"boolean\")) {\n    return \"bool\" /* Boolean */;\n  }\n  if (lower.includes(\"date\") || lower.includes(\"timestamp\")) {\n    return \"date\" /* Date */;\n  }\n  return \"utf8\" /* Utf8 */;\n}\nfunction extractColumnValues(column, dtype, length) {\n  const values = [];\n  for (let i = 0; i < length; i++) {\n    if (column.isValid(i) === false) {\n      values.push(null);\n      continue;\n    }\n    let val = column.get(i);\n    if (typeof val === \"bigint\") {\n      val = Number(val);\n    }\n    if (dtype === \"date\" /* Date */ && typeof val === \"number\") {\n      val = new Date(val);\n    }\n    values.push(val);\n  }\n  return values;\n}\nasync function readParquetFile(filePath, options = {}) {\n  let parquetWasm;\n  try {\n    const moduleName = \"parquet-wasm\";\n    parquetWasm = await import(moduleName);\n  } catch {\n    throw new IOError(\n      \"parquet-wasm is required to read Parquet files but is not installed. Run: npm install parquet-wasm\"\n    );\n  }\n  try {\n    const fs = await import(\"fs/promises\");\n    const buffer = await fs.readFile(filePath);\n    const uint8 = new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    const arrowTable = parquetWasm.readParquet(uint8);\n    const schema = arrowTable.schema;\n    const numFields = schema.numFields ?? schema.fields?.length ?? 0;\n    const numRows = arrowTable.numRows ?? 0;\n    const allFields = [];\n    for (let i = 0; i < numFields; i++) {\n      const field = schema.field(i);\n      const name = String(field.name);\n      const dtype = arrowTypeToDType(field);\n      allFields.push({ name, dtype, index: i });\n    }\n    const selectedFields = options.columns ? allFields.filter((f) => options.columns.includes(f.name)) : allFields;\n    const header = [];\n    const columns = {};\n    const inferredTypes = {};\n    for (const field of selectedFields) {\n      header.push(field.name);\n      inferredTypes[field.name] = field.dtype;\n      const arrowCol = arrowTable.getChildAt(field.index);\n      if (arrowCol) {\n        columns[field.name] = extractColumnValues(arrowCol, field.dtype, numRows);\n      } else {\n        columns[field.name] = new Array(numRows).fill(null);\n      }\n    }\n    return { header, columns, inferredTypes };\n  } catch (err) {\n    if (err instanceof IOError) throw err;\n    const message = err instanceof Error ? err.message : String(err);\n    throw new IOError(`Failed to read Parquet file '${filePath}': ${message}`);\n  }\n}\n\n// src/io/excel/writer.ts\nfunction parseCellRef2(ref) {\n  const match = /^([A-Z]+)(\\d+)$/.exec(ref.toUpperCase());\n  if (!match) throw new IOError(`Invalid cell reference: '${ref}'`);\n  const colStr = match[1];\n  const rowNum = parseInt(match[2], 10);\n  let colNum = 0;\n  for (let i = 0; i < colStr.length; i++) {\n    colNum = colNum * 26 + (colStr.charCodeAt(i) - 64);\n  }\n  return { col: colNum, row: rowNum };\n}\nfunction columnNumberToLetter(col2) {\n  let result = \"\";\n  let n = col2;\n  while (n > 0) {\n    const remainder = (n - 1) % 26;\n    result = String.fromCharCode(65 + remainder) + result;\n    n = Math.floor((n - 1) / 26);\n  }\n  return result;\n}\nasync function writeExcelFile(filePath, header, rows, options = {}) {\n  let ExcelJS;\n  try {\n    ExcelJS = await import(\"exceljs\");\n  } catch {\n    throw new IOError(\n      \"exceljs is required to write Excel files but is not installed. Run: npm install exceljs\"\n    );\n  }\n  try {\n    const workbook = new ExcelJS.Workbook();\n    const sheetName = options.sheet ?? \"Sheet1\";\n    const worksheet = workbook.addWorksheet(sheetName);\n    const startCell = options.startCell ?? \"A1\";\n    const { col: startCol, row: startRow } = parseCellRef2(startCell);\n    for (let i = 0; i < header.length; i++) {\n      const colLetter = columnNumberToLetter(startCol + i);\n      const cellRef = `${colLetter}${String(startRow)}`;\n      worksheet.getCell(cellRef).value = header[i];\n    }\n    for (let r = 0; r < rows.length; r++) {\n      const row = rows[r];\n      for (let c = 0; c < header.length; c++) {\n        const colLetter = columnNumberToLetter(startCol + c);\n        const cellRef = `${colLetter}${String(startRow + 1 + r)}`;\n        const value = c < row.length ? row[c] : null;\n        worksheet.getCell(cellRef).value = value === null || value === void 0 ? null : value;\n      }\n    }\n    if (options.autoFilter) {\n      const lastColLetter = columnNumberToLetter(startCol + header.length - 1);\n      const lastRow = startRow + rows.length;\n      worksheet.autoFilter = `${columnNumberToLetter(startCol)}${String(startRow)}:${lastColLetter}${String(lastRow)}`;\n    }\n    if (options.freezePanes) {\n      const freezeRow = options.freezePanes.row;\n      const freezeCol = options.freezePanes.col;\n      worksheet.views = [\n        {\n          state: \"frozen\",\n          xSplit: freezeCol,\n          ySplit: startRow - 1 + freezeRow,\n          topLeftCell: `${columnNumberToLetter(startCol + freezeCol)}${String(startRow + freezeRow)}`,\n          activeCell: `${columnNumberToLetter(startCol)}${String(startRow)}`\n        }\n      ];\n    }\n    if (options.columnWidths) {\n      for (let i = 0; i < header.length; i++) {\n        const colName = header[i];\n        const width = options.columnWidths[colName];\n        if (width !== void 0) {\n          const col2 = worksheet.getColumn(startCol + i);\n          col2.width = width;\n        }\n      }\n    }\n    await workbook.xlsx.writeFile(filePath);\n  } catch (err) {\n    if (err instanceof IOError) throw err;\n    const message = err instanceof Error ? err.message : String(err);\n    throw new IOError(`Failed to write Excel file '${filePath}': ${message}`);\n  }\n}\n\n// src/io/parquet/writer.ts\nfunction dtypeToArrowType(arrow, dtype) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n      return new arrow.Float64();\n    case \"i32\" /* Int32 */:\n      return new arrow.Int32();\n    case \"utf8\" /* Utf8 */:\n      return new arrow.Utf8();\n    case \"bool\" /* Boolean */:\n      return new arrow.Bool();\n    case \"date\" /* Date */:\n    case \"datetime\" /* DateTime */:\n      return new arrow.DateMillisecond();\n    default:\n      return new arrow.Utf8();\n  }\n}\nfunction coerceValues(values, dtype) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n    case \"i32\" /* Int32 */:\n      return values.map((v) => v === null || v === void 0 ? null : Number(v));\n    case \"utf8\" /* Utf8 */:\n      return values.map((v) => {\n        if (v === null || v === void 0) return null;\n        if (typeof v === \"string\") return v;\n        if (typeof v === \"number\" || typeof v === \"boolean\" || typeof v === \"bigint\") return String(v);\n        return typeof v === \"object\" ? JSON.stringify(v) : String(v);\n      });\n    case \"bool\" /* Boolean */:\n      return values.map((v) => v === null || v === void 0 ? null : Boolean(v));\n    case \"date\" /* Date */:\n    case \"datetime\" /* DateTime */:\n      return values.map((v) => {\n        if (v === null || v === void 0) return null;\n        if (v instanceof Date) return v.getTime();\n        if (typeof v === \"number\") return v;\n        return null;\n      });\n    default:\n      return values.map((v) => {\n        if (v === null || v === void 0) return null;\n        if (typeof v === \"string\") return v;\n        if (typeof v === \"number\" || typeof v === \"boolean\" || typeof v === \"bigint\") {\n          return String(v);\n        }\n        return typeof v === \"object\" ? JSON.stringify(v) : String(v);\n      });\n  }\n}\nfunction resolveCompression(parquetWasm, compression) {\n  const Compression = parquetWasm.Compression;\n  if (!Compression) return compression.toUpperCase();\n  switch (compression) {\n    case \"snappy\":\n      return Compression.SNAPPY;\n    case \"gzip\":\n      return Compression.GZIP;\n    case \"zstd\":\n      return Compression.ZSTD;\n    case \"none\":\n      return Compression.UNCOMPRESSED;\n  }\n}\nasync function writeParquetFile(filePath, header, columns, options = {}) {\n  let parquetWasm;\n  try {\n    const moduleName = \"parquet-wasm\";\n    parquetWasm = await import(moduleName);\n  } catch {\n    throw new IOError(\n      \"parquet-wasm is required to write Parquet files but is not installed. Run: npm install parquet-wasm\"\n    );\n  }\n  let arrow;\n  try {\n    const arrowModule = \"apache-arrow\";\n    arrow = await import(arrowModule);\n  } catch {\n    throw new IOError(\n      \"apache-arrow is required to write Parquet files but is not installed. Run: npm install apache-arrow\"\n    );\n  }\n  try {\n    const fields = [];\n    const arrowColumns = {};\n    for (const name of header) {\n      const col2 = columns[name];\n      const arrowType = dtypeToArrowType(arrow, col2.dtype);\n      fields.push(new arrow.Field(name, arrowType, true));\n      const coerced = coerceValues(col2.values, col2.dtype);\n      arrowColumns[name] = arrow.vectorFromArray(coerced, arrowType);\n    }\n    const schema = new arrow.Schema(fields);\n    const arrowTable = new arrow.Table(schema, arrowColumns);\n    const ipcBytes = arrow.tableToIPC(arrowTable, \"stream\");\n    const wasmTable = parquetWasm.Table.fromIPCStream(ipcBytes);\n    const compression = options.compression ?? \"snappy\";\n    const resolvedCompression = resolveCompression(parquetWasm, compression);\n    let builder = new parquetWasm.WriterPropertiesBuilder();\n    builder = builder.setCompression(resolvedCompression);\n    if (options.rowGroupSize !== void 0) {\n      builder = builder.setMaxRowGroupSize(options.rowGroupSize);\n    }\n    const writerProperties = builder.build();\n    const parquetBytes = parquetWasm.writeParquet(wasmTable, writerProperties);\n    const fs = await import(\"fs/promises\");\n    await fs.writeFile(filePath, parquetBytes);\n  } catch (err) {\n    if (err instanceof IOError) throw err;\n    const message = err instanceof Error ? err.message : String(err);\n    throw new IOError(`Failed to write Parquet file '${filePath}': ${message}`);\n  }\n}\n\n// src/io/arrow/to-arrow.ts\nfunction dtypeToArrowType2(arrow, dtype) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n      return new arrow.Float64();\n    case \"i32\" /* Int32 */:\n      return new arrow.Int32();\n    case \"utf8\" /* Utf8 */:\n      return new arrow.Utf8();\n    case \"bool\" /* Boolean */:\n      return new arrow.Bool();\n    case \"date\" /* Date */:\n    case \"datetime\" /* DateTime */:\n      return new arrow.DateMillisecond();\n    default:\n      return new arrow.Utf8();\n  }\n}\nfunction coerceValue(value, dtype) {\n  if (value === null || value === void 0) return null;\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n    case \"i32\" /* Int32 */:\n      return Number(value);\n    case \"bool\" /* Boolean */:\n      return Boolean(value);\n    case \"date\" /* Date */:\n    case \"datetime\" /* DateTime */:\n      if (value instanceof Date) return value.getTime();\n      if (typeof value === \"number\") return value;\n      return new Date(value).getTime();\n    case \"utf8\" /* Utf8 */:\n    default:\n      if (typeof value === \"string\") return value;\n      if (typeof value === \"number\" || typeof value === \"boolean\" || typeof value === \"bigint\") return String(value);\n      return typeof value === \"object\" ? JSON.stringify(value) : String(value);\n  }\n}\nasync function toArrowTable(input) {\n  let arrow;\n  try {\n    const moduleName = \"apache-arrow\";\n    arrow = await import(moduleName);\n  } catch {\n    throw new IOError(\n      \"apache-arrow is required for Arrow interop but is not installed. Run: npm install apache-arrow\"\n    );\n  }\n  const { columnOrder, getColumnValues } = input;\n  const tableData = {};\n  for (const name of columnOrder) {\n    const { values, dtype } = getColumnValues(name);\n    const arrowType = dtypeToArrowType2(arrow, dtype);\n    const coerced = values.map((v) => coerceValue(v, dtype));\n    tableData[name] = arrow.vectorFromArray(coerced, arrowType);\n  }\n  return new arrow.Table(tableData);\n}\n\n// src/io/arrow/from-arrow.ts\nfunction arrowTypeToDType2(field) {\n  const typeId = field.type?.typeId;\n  const typeStr = String(field.type ?? \"\");\n  switch (typeId) {\n    case 2:\n      return \"i32\" /* Int32 */;\n    case 3:\n      return \"f64\" /* Float64 */;\n    case 5:\n      return \"utf8\" /* Utf8 */;\n    case 6:\n      return \"bool\" /* Boolean */;\n    case 8:\n    // Date\n    case 10:\n      return \"date\" /* Date */;\n    case -1:\n      if (typeStr.includes(\"Utf8\")) return \"utf8\" /* Utf8 */;\n      return \"utf8\" /* Utf8 */;\n    default:\n      if (typeStr.includes(\"Int\")) return \"i32\" /* Int32 */;\n      if (typeStr.includes(\"Float\")) return \"f64\" /* Float64 */;\n      if (typeStr.includes(\"Utf8\") || typeStr.includes(\"utf8\")) return \"utf8\" /* Utf8 */;\n      if (typeStr.includes(\"Bool\")) return \"bool\" /* Boolean */;\n      if (typeStr.includes(\"Date\") || typeStr.includes(\"Timestamp\")) return \"date\" /* Date */;\n      return \"utf8\" /* Utf8 */;\n  }\n}\nfunction fromArrowTable(table) {\n  if (!table || !table.schema || !table.schema.fields) {\n    throw new IOError(\"Invalid Arrow Table: missing schema or fields\");\n  }\n  const header = [];\n  const columns = {};\n  const inferredTypes = {};\n  const numRows = Number(table.numRows);\n  const fields = table.schema.fields;\n  for (const field of fields) {\n    const name = String(field.name);\n    header.push(name);\n    const dtype = arrowTypeToDType2(field);\n    inferredTypes[name] = dtype;\n    const column = table.getChild(name);\n    const values = [];\n    for (let i = 0; i < numRows; i++) {\n      const val = column.get(i);\n      if (val === null || val === void 0) {\n        values.push(null);\n      } else if (dtype === \"date\" /* Date */ && typeof val === \"number\") {\n        values.push(new Date(val));\n      } else {\n        values.push(val);\n      }\n    }\n    columns[name] = values;\n  }\n  return { header, columns, inferredTypes };\n}\n\n// src/engine/parallelism/parallel-agg.ts\nimport os from \"os\";\n\n// src/engine/parallelism/worker-code.ts\nvar WORKER_CODE = `\n'use strict';\nconst { parentPort } = require('worker_threads');\n\nfunction getNumericValue(data, nullMask, index, dtype) {\n  // Check null mask\n  if (nullMask) {\n    const byteIndex = index >> 3;\n    const bitIndex = index & 7;\n    if (!((nullMask[byteIndex] >> bitIndex) & 1)) {\n      return null; // null value\n    }\n  }\n  if (dtype === 'float64' || dtype === 'int32' || dtype === 'date') {\n    return data[index];\n  }\n  return null;\n}\n\nfunction getStringValue(data, nullMask, index) {\n  if (nullMask) {\n    const byteIndex = index >> 3;\n    const bitIndex = index & 7;\n    if (!((nullMask[byteIndex] >> bitIndex) & 1)) {\n      return null;\n    }\n  }\n  return data[index];\n}\n\nfunction getValue(colData, index) {\n  if (colData.dtype === 'utf8') {\n    return getStringValue(colData.data, colData.nullMaskArr, index);\n  }\n  return getNumericValue(colData.dataArr, colData.nullMaskArr, index, colData.dtype);\n}\n\nfunction computeAgg(colData, indices, aggType) {\n  switch (aggType) {\n    case 'sum': {\n      let total = 0;\n      let hasValue = false;\n      for (let i = 0; i < indices.length; i++) {\n        const v = getValue(colData, indices[i]);\n        if (v !== null && typeof v === 'number') {\n          total += v;\n          hasValue = true;\n        }\n      }\n      return hasValue ? total : null;\n    }\n    case 'mean': {\n      let total = 0;\n      let count = 0;\n      for (let i = 0; i < indices.length; i++) {\n        const v = getValue(colData, indices[i]);\n        if (v !== null && typeof v === 'number') {\n          total += v;\n          count++;\n        }\n      }\n      return count > 0 ? total / count : null;\n    }\n    case 'count': {\n      let count = 0;\n      for (let i = 0; i < indices.length; i++) {\n        const v = getValue(colData, indices[i]);\n        if (v !== null) count++;\n      }\n      return count;\n    }\n    case 'count_distinct': {\n      const seen = new Set();\n      for (let i = 0; i < indices.length; i++) {\n        const v = getValue(colData, indices[i]);\n        if (v !== null) seen.add(v);\n      }\n      return seen.size;\n    }\n    case 'min': {\n      let result = null;\n      for (let i = 0; i < indices.length; i++) {\n        const v = getValue(colData, indices[i]);\n        if (v !== null && typeof v === 'number') {\n          if (result === null || v < result) result = v;\n        }\n      }\n      return result;\n    }\n    case 'max': {\n      let result = null;\n      for (let i = 0; i < indices.length; i++) {\n        const v = getValue(colData, indices[i]);\n        if (v !== null && typeof v === 'number') {\n          if (result === null || v > result) result = v;\n        }\n      }\n      return result;\n    }\n    case 'std': {\n      let sum = 0;\n      let sumSq = 0;\n      let count = 0;\n      for (let i = 0; i < indices.length; i++) {\n        const v = getValue(colData, indices[i]);\n        if (v !== null && typeof v === 'number') {\n          sum += v;\n          sumSq += v * v;\n          count++;\n        }\n      }\n      if (count < 2) return null;\n      const mean = sum / count;\n      const variance = sumSq / count - mean * mean;\n      return Math.sqrt(variance);\n    }\n    case 'first': {\n      for (let i = 0; i < indices.length; i++) {\n        const v = getValue(colData, indices[i]);\n        if (v !== null) return v;\n      }\n      return null;\n    }\n    case 'last': {\n      for (let i = indices.length - 1; i >= 0; i--) {\n        const v = getValue(colData, indices[i]);\n        if (v !== null) return v;\n      }\n      return null;\n    }\n    default:\n      return null;\n  }\n}\n\nparentPort.on('message', (msg) => {\n  const { columns, groups, aggSpecs, keyColumns } = msg;\n\n  // Pre-process column data for fast access\n  const processedColumns = {};\n  for (const [name, colData] of Object.entries(columns)) {\n    const processed = { ...colData };\n    if (colData.dtype === 'float64' || colData.dtype === 'date') {\n      processed.dataArr = new Float64Array(colData.data);\n    } else if (colData.dtype === 'int32') {\n      processed.dataArr = new Int32Array(colData.data);\n    } else if (colData.dtype === 'boolean') {\n      processed.dataArr = new Uint8Array(colData.data);\n    }\n    // utf8: data is already string[]\n    if (colData.nullMask) {\n      processed.nullMaskArr = new Uint8Array(colData.nullMask);\n    } else {\n      processed.nullMaskArr = null;\n    }\n    processedColumns[name] = processed;\n  }\n\n  const results = [];\n  const aggEntries = Object.entries(aggSpecs);\n\n  for (const [groupIndex, indices] of groups) {\n    // Extract key values from first row\n    const keyValues = [];\n    const firstIndex = indices[0];\n    for (const keyCol of keyColumns) {\n      const colData = processedColumns[keyCol];\n      if (colData) {\n        keyValues.push(getValue(colData, firstIndex));\n      } else {\n        keyValues.push(null);\n      }\n    }\n\n    // Compute aggregations\n    const aggValues = {};\n    for (const [outputName, spec] of aggEntries) {\n      const colData = processedColumns[spec.columnName];\n      if (colData) {\n        aggValues[outputName] = computeAgg(colData, indices, spec.aggType);\n      } else {\n        aggValues[outputName] = null;\n      }\n    }\n\n    results.push({ groupIndex, keyValues, aggValues });\n  }\n\n  parentPort.postMessage({ results });\n});\n`;\n\n// src/engine/parallelism/parallel-agg.ts\nvar DEFAULT_THRESHOLD = 1e6;\nvar defaultWorkerCount = Math.max(1, os.cpus().length - 1);\nvar workerThreadsAvailable = null;\nfunction isWorkerThreadsAvailableSync() {\n  if (workerThreadsAvailable === null) {\n    return true;\n  }\n  return workerThreadsAvailable;\n}\nfunction shouldUseParallel(rowCount, options) {\n  const threshold = options?.threshold ?? DEFAULT_THRESHOLD;\n  if (rowCount < threshold) return false;\n  if (!isWorkerThreadsAvailableSync()) return false;\n  const workerCount = options?.workerCount ?? defaultWorkerCount;\n  return workerCount > 1;\n}\nfunction serializeColumn(name, column) {\n  const len = column.length;\n  let nullMask = null;\n  if (column.nullCount > 0) {\n    const maskBytes = new Uint8Array(Math.ceil(len / 8));\n    for (let i = 0; i < len; i++) {\n      if (column.get(i) !== null) {\n        maskBytes[i >> 3] |= 1 << (i & 7);\n      }\n    }\n    nullMask = maskBytes.buffer;\n  }\n  switch (column.dtype) {\n    case \"f64\" /* Float64 */:\n    case \"date\" /* Date */: {\n      const arr = new Float64Array(len);\n      for (let i = 0; i < len; i++) {\n        const v = column.get(i);\n        if (v === null) {\n          arr[i] = 0;\n        } else if (v instanceof Date) {\n          arr[i] = v.getTime();\n        } else {\n          arr[i] = v;\n        }\n      }\n      return {\n        name,\n        dtype: column.dtype === \"date\" /* Date */ ? \"date\" : \"float64\",\n        data: arr.buffer,\n        nullMask,\n        length: len\n      };\n    }\n    case \"i32\" /* Int32 */: {\n      const arr = new Int32Array(len);\n      for (let i = 0; i < len; i++) {\n        const v = column.get(i);\n        arr[i] = v === null ? 0 : v;\n      }\n      return {\n        name,\n        dtype: \"int32\",\n        data: arr.buffer,\n        nullMask,\n        length: len\n      };\n    }\n    case \"bool\" /* Boolean */: {\n      const arr = new Uint8Array(len);\n      for (let i = 0; i < len; i++) {\n        const v = column.get(i);\n        arr[i] = v === null ? 0 : v ? 1 : 0;\n      }\n      return {\n        name,\n        dtype: \"boolean\",\n        data: arr.buffer,\n        nullMask,\n        length: len\n      };\n    }\n    case \"utf8\" /* Utf8 */:\n    default: {\n      const arr = [];\n      for (let i = 0; i < len; i++) {\n        const v = column.get(i);\n        if (v === null) {\n          arr.push(\"\");\n        } else if (typeof v === \"string\") {\n          arr.push(v);\n        } else if (typeof v === \"number\" || typeof v === \"boolean\") {\n          arr.push(String(v));\n        } else {\n          arr.push(\"\");\n        }\n      }\n      return {\n        name,\n        dtype: \"utf8\",\n        data: arr,\n        nullMask,\n        length: len\n      };\n    }\n  }\n}\nfunction partitionGroups(groupEntries, workerCount) {\n  const partitions = Array.from(\n    { length: workerCount },\n    () => []\n  );\n  for (let i = 0; i < groupEntries.length; i++) {\n    const [, indices] = groupEntries[i];\n    partitions[i % workerCount].push([i, indices]);\n  }\n  return partitions;\n}\nasync function parallelAgg(groupEntries, keyColumnNames, keyColumns, aggSpecs, sourceColumns, options) {\n  const wt = await import(\"worker_threads\");\n  const { Worker } = wt;\n  workerThreadsAvailable = true;\n  const workerCount = Math.min(\n    options?.workerCount ?? defaultWorkerCount,\n    groupEntries.length\n  );\n  const neededColumns = /* @__PURE__ */ new Set();\n  for (const keyName of keyColumnNames) {\n    neededColumns.add(keyName);\n  }\n  for (const spec of Object.values(aggSpecs)) {\n    neededColumns.add(spec.columnName);\n  }\n  const serializedColumns = {};\n  for (const colName of neededColumns) {\n    const column = sourceColumns.get(colName);\n    if (column) {\n      serializedColumns[colName] = serializeColumn(colName, column);\n    }\n  }\n  const partitions = partitionGroups(groupEntries, workerCount);\n  const workerPromises = partitions.map((partition) => {\n    if (partition.length === 0) {\n      return Promise.resolve({ results: [] });\n    }\n    return new Promise((resolve, reject) => {\n      const worker = new Worker(WORKER_CODE, { eval: true });\n      const message = {\n        columns: serializedColumns,\n        groups: partition,\n        aggSpecs,\n        keyColumns: keyColumnNames\n      };\n      worker.on(\"message\", (result) => {\n        void worker.terminate();\n        resolve(result);\n      });\n      worker.on(\"error\", (err) => {\n        void worker.terminate();\n        reject(err);\n      });\n      worker.postMessage(message);\n    });\n  });\n  const results = await Promise.all(workerPromises);\n  const allResults = [];\n  for (const workerResult of results) {\n    allResults.push(...workerResult.results);\n  }\n  allResults.sort((a, b) => a.groupIndex - b.groupIndex);\n  return allResults;\n}\n\n// src/ops/groupby.ts\nvar GroupBy = class {\n  _df;\n  _keys;\n  _groupMap;\n  constructor(df2, keys) {\n    this._df = df2;\n    this._keys = keys;\n    for (const key of keys) {\n      if (!df2.columns.includes(key)) {\n        throw new ColumnNotFoundError(key, df2.columns);\n      }\n    }\n    this._groupMap = /* @__PURE__ */ new Map();\n    const columns = keys.map((k) => df2.col(k).column);\n    for (let i = 0; i < df2.length; i++) {\n      const keyStr = this._serializeKey(columns, i);\n      const group = this._groupMap.get(keyStr);\n      if (group) {\n        group.push(i);\n      } else {\n        this._groupMap.set(keyStr, [i]);\n      }\n    }\n  }\n  get keys() {\n    return [...this._keys];\n  }\n  get dataframe() {\n    return this._df;\n  }\n  get groupMap() {\n    return this._groupMap;\n  }\n  nGroups() {\n    return this._groupMap.size;\n  }\n  agg(specs, options) {\n    if (options || shouldUseParallel(this._df.length)) {\n      const useParallel = shouldUseParallel(this._df.length, options);\n      if (useParallel) {\n      }\n    }\n    return this._aggSync(specs);\n  }\n  /**\n   * Async aggregation that uses worker threads for large datasets.\n   * Falls back to single-threaded when workers are unavailable or data is small.\n   */\n  async aggAsync(specs, options) {\n    const resolvedSpecs = {};\n    for (const [name, spec] of Object.entries(specs)) {\n      if (typeof spec === \"string\") {\n        resolvedSpecs[name] = this._resolveShorthand(name, spec);\n      } else {\n        resolvedSpecs[name] = spec;\n      }\n    }\n    const useParallel = shouldUseParallel(this._df.length, options);\n    if (!useParallel) {\n      return this._aggSync(specs);\n    }\n    const aggSpecs = {};\n    for (const [name, aggExpr] of Object.entries(resolvedSpecs)) {\n      const aggType = this._aggExprToType(aggExpr);\n      if (!aggType) {\n        return this._aggSync(specs);\n      }\n      aggSpecs[name] = {\n        columnName: aggExpr.dependencies[0],\n        aggType\n      };\n    }\n    const sourceColumns = /* @__PURE__ */ new Map();\n    for (const colName of this._df.columns) {\n      sourceColumns.set(colName, this._df.col(colName).column);\n    }\n    const groupEntries = [...this._groupMap.entries()];\n    const keyCols = this._keys.map((k) => this._df.col(k).column);\n    const results = await parallelAgg(\n      groupEntries,\n      [...this._keys],\n      keyCols,\n      aggSpecs,\n      sourceColumns,\n      options\n    );\n    const nGroups = results.length;\n    const resultColumns = /* @__PURE__ */ new Map();\n    const columnOrder = [];\n    for (let ki = 0; ki < this._keys.length; ki++) {\n      const k = this._keys[ki];\n      const vals = results.map((r) => r.keyValues[ki] ?? null);\n      resultColumns.set(k, this._buildColumnLike(keyCols[ki], vals));\n      columnOrder.push(k);\n    }\n    const aggNames = Object.keys(specs);\n    for (const name of aggNames) {\n      const vals = results.map((r) => r.aggValues[name] ?? null);\n      resultColumns.set(name, this._inferColumn(vals, nGroups));\n      columnOrder.push(name);\n    }\n    const Ctor = this._df.constructor;\n    return new Ctor(resultColumns, columnOrder);\n  }\n  _aggSync(specs) {\n    const groupEntries = [...this._groupMap.entries()];\n    const nGroups = groupEntries.length;\n    const keyColumns = this._keys;\n    const aggNames = Object.keys(specs);\n    const resolvedSpecs = {};\n    for (const [name, spec] of Object.entries(specs)) {\n      if (typeof spec === \"string\") {\n        resolvedSpecs[name] = this._resolveShorthand(name, spec);\n      } else {\n        resolvedSpecs[name] = spec;\n      }\n    }\n    const keyValues = /* @__PURE__ */ new Map();\n    for (const k of keyColumns) {\n      keyValues.set(k, []);\n    }\n    const aggValues = /* @__PURE__ */ new Map();\n    for (const name of aggNames) {\n      aggValues.set(name, []);\n    }\n    const keyCols = keyColumns.map((k) => this._df.col(k).column);\n    if (aggNames.length === 1) {\n      const onlyAggName = aggNames[0];\n      const onlyAgg = resolvedSpecs[onlyAggName];\n      if (onlyAgg instanceof SumAggExpr) {\n        const sourceCol = this._df.col(onlyAgg.dependencies[0]).column;\n        for (const [, indices] of groupEntries) {\n          const firstIndex = indices[0];\n          for (let ki = 0; ki < keyColumns.length; ki++) {\n            keyValues.get(keyColumns[ki]).push(keyCols[ki].get(firstIndex));\n          }\n          let sum = 0;\n          let hasValue = false;\n          for (let ii = 0; ii < indices.length; ii++) {\n            const v = sourceCol.get(indices[ii]);\n            if (typeof v === \"number\") {\n              sum += v;\n              hasValue = true;\n            }\n          }\n          aggValues.get(onlyAggName).push(hasValue ? sum : null);\n        }\n        const resultColumns2 = /* @__PURE__ */ new Map();\n        const columnOrder2 = [];\n        for (let ki = 0; ki < keyColumns.length; ki++) {\n          const k = keyColumns[ki];\n          const vals = keyValues.get(k);\n          resultColumns2.set(k, this._buildColumnLike(keyCols[ki], vals));\n          columnOrder2.push(k);\n        }\n        resultColumns2.set(\n          onlyAggName,\n          Float64Column.from(aggValues.get(onlyAggName))\n        );\n        columnOrder2.push(onlyAggName);\n        const Ctor2 = this._df.constructor;\n        return new Ctor2(resultColumns2, columnOrder2);\n      }\n    }\n    for (const [, indices] of groupEntries) {\n      const firstIndex = indices[0];\n      for (let ki = 0; ki < keyColumns.length; ki++) {\n        keyValues.get(keyColumns[ki]).push(keyCols[ki].get(firstIndex));\n      }\n      const int32Indices = new Int32Array(indices);\n      const subColumns = /* @__PURE__ */ new Map();\n      for (const sourceName of this._df.columns) {\n        subColumns.set(sourceName, this._df.col(sourceName).column.take(int32Indices));\n      }\n      const Ctor2 = this._df.constructor;\n      const subFrame = new Ctor2(subColumns, [...this._df.columns]);\n      for (const name of aggNames) {\n        const aggExpr = resolvedSpecs[name];\n        const result = aggExpr.evaluateFrame(subFrame);\n        aggValues.get(name).push(result);\n      }\n    }\n    const resultColumns = /* @__PURE__ */ new Map();\n    const columnOrder = [];\n    for (let ki = 0; ki < keyColumns.length; ki++) {\n      const k = keyColumns[ki];\n      const sourceCol = keyCols[ki];\n      const vals = keyValues.get(k);\n      resultColumns.set(k, this._buildColumnLike(sourceCol, vals));\n      columnOrder.push(k);\n    }\n    for (const name of aggNames) {\n      const vals = aggValues.get(name);\n      resultColumns.set(name, this._inferColumn(vals, nGroups));\n      columnOrder.push(name);\n    }\n    const Ctor = this._df.constructor;\n    return new Ctor(resultColumns, columnOrder);\n  }\n  _aggExprToType(aggExpr) {\n    const name = aggExpr.constructor.name;\n    const map = {\n      SumAggExpr: \"sum\",\n      MeanAggExpr: \"mean\",\n      CountAggExpr: \"count\",\n      CountDistinctAggExpr: \"count_distinct\",\n      MinAggExpr: \"min\",\n      MaxAggExpr: \"max\",\n      StdAggExpr: \"std\",\n      FirstAggExpr: \"first\",\n      LastAggExpr: \"last\"\n    };\n    return map[name] ?? null;\n  }\n  _resolveShorthand(columnName, method) {\n    const colExpr = col(columnName);\n    switch (method) {\n      case \"sum\":\n        return colExpr.sum();\n      case \"mean\":\n        return colExpr.mean();\n      case \"count\":\n        return colExpr.count();\n      case \"min\":\n        return colExpr.min();\n      case \"max\":\n        return colExpr.max();\n      case \"std\":\n        return colExpr.std();\n      case \"first\":\n        return colExpr.first();\n      case \"last\":\n        return colExpr.last();\n      default:\n        throw new Error(`Unknown aggregation method: ${method}`);\n    }\n  }\n  _buildColumnLike(source, values) {\n    switch (source.dtype) {\n      case \"f64\" /* Float64 */:\n        return Float64Column.from(values);\n      case \"i32\" /* Int32 */:\n        return Float64Column.from(values);\n      case \"utf8\" /* Utf8 */:\n        return Utf8Column.from(values);\n      case \"bool\" /* Boolean */:\n        return BooleanColumn.from(values);\n      case \"date\" /* Date */:\n        return DateColumn.from(values);\n      default:\n        return Float64Column.from(values);\n    }\n  }\n  _inferColumn(values, _length) {\n    let sample = null;\n    for (const v of values) {\n      if (v !== null) {\n        sample = v;\n        break;\n      }\n    }\n    if (sample === null || typeof sample === \"number\") {\n      return Float64Column.from(values);\n    }\n    if (typeof sample === \"string\") {\n      return Utf8Column.from(values);\n    }\n    if (typeof sample === \"boolean\") {\n      return BooleanColumn.from(values);\n    }\n    if (sample instanceof Date) {\n      return DateColumn.from(values);\n    }\n    return Float64Column.from(values);\n  }\n  count() {\n    const groupEntries = [...this._groupMap.entries()];\n    const keyCols = this._keys.map((k) => this._df.col(k).column);\n    const keyValues = /* @__PURE__ */ new Map();\n    for (const k of this._keys) {\n      keyValues.set(k, []);\n    }\n    const counts = [];\n    for (const [, indices] of groupEntries) {\n      const firstIndex = indices[0];\n      for (let ki = 0; ki < this._keys.length; ki++) {\n        keyValues.get(this._keys[ki]).push(keyCols[ki].get(firstIndex));\n      }\n      counts.push(indices.length);\n    }\n    const resultColumns = /* @__PURE__ */ new Map();\n    const columnOrder = [];\n    for (let ki = 0; ki < this._keys.length; ki++) {\n      const k = this._keys[ki];\n      const vals = keyValues.get(k);\n      resultColumns.set(k, this._buildColumnLike(keyCols[ki], vals));\n      columnOrder.push(k);\n    }\n    resultColumns.set(\"count\", Float64Column.from(counts));\n    columnOrder.push(\"count\");\n    const Ctor = this._df.constructor;\n    return new Ctor(resultColumns, columnOrder);\n  }\n  sum(column) {\n    return this.agg({ [column]: col(column).sum() });\n  }\n  mean(column) {\n    return this.agg({ [column]: col(column).mean() });\n  }\n  min(column) {\n    return this.agg({ [column]: col(column).min() });\n  }\n  max(column) {\n    return this.agg({ [column]: col(column).max() });\n  }\n  first() {\n    const nonKeyColumns = this._df.columns.filter((c) => !this._keys.includes(c));\n    const specs = {};\n    for (const c of nonKeyColumns) {\n      specs[c] = col(c).first();\n    }\n    return this.agg(specs);\n  }\n  last() {\n    const nonKeyColumns = this._df.columns.filter((c) => !this._keys.includes(c));\n    const specs = {};\n    for (const c of nonKeyColumns) {\n      specs[c] = col(c).last();\n    }\n    return this.agg(specs);\n  }\n  apply(fn) {\n    const results = [];\n    for (const [, indices] of this._groupMap) {\n      const subFrame = this._buildSubFrame(indices);\n      results.push(fn(subFrame));\n    }\n    if (results.length === 0) {\n      return this._df.slice(0, 0);\n    }\n    const Ctor = this._df.constructor;\n    return Ctor.concat(...results);\n  }\n  groups() {\n    const result = /* @__PURE__ */ new Map();\n    for (const [key, indices] of this._groupMap) {\n      result.set(key, this._buildSubFrame(indices));\n    }\n    return result;\n  }\n  _serializeKey(columns, index) {\n    if (columns.length === 1) {\n      const v = columns[0].get(index);\n      if (v === null) return \"\\0null\";\n      if (v instanceof Date) return `\\0d${v.getTime()}`;\n      if (typeof v === \"number\" || typeof v === \"string\" || typeof v === \"boolean\") {\n        return `\\0${typeof v}${String(v)}`;\n      }\n      return `\\0obj${JSON.stringify(v)}`;\n    }\n    const parts = [];\n    for (const column of columns) {\n      const v = column.get(index);\n      if (v === null) {\n        parts.push(\"\\0null\");\n      } else if (v instanceof Date) {\n        parts.push(`\\0d${v.getTime()}`);\n      } else if (typeof v === \"number\" || typeof v === \"string\" || typeof v === \"boolean\") {\n        parts.push(`\\0${typeof v}${String(v)}`);\n      } else {\n        parts.push(`\\0obj${JSON.stringify(v)}`);\n      }\n    }\n    return parts.join(\"\u0001\");\n  }\n  _buildSubFrame(indices) {\n    const int32Indices = new Int32Array(indices);\n    const newColumns = /* @__PURE__ */ new Map();\n    const columnOrder = this._df.columns;\n    for (const name of columnOrder) {\n      newColumns.set(name, this._df.col(name).column.take(int32Indices));\n    }\n    const Ctor = this._df.constructor;\n    return new Ctor(newColumns, columnOrder);\n  }\n};\n\n// src/ops/join.ts\nfunction serializeKey(columns, index) {\n  const parts = [];\n  for (const column of columns) {\n    const v = column.get(index);\n    if (v === null) {\n      return null;\n    } else if (v instanceof Date) {\n      parts.push(`\\0d${v.getTime()}`);\n    } else if (typeof v === \"number\" || typeof v === \"string\" || typeof v === \"boolean\") {\n      parts.push(`\\0${typeof v}${String(v)}`);\n    } else {\n      parts.push(`\\0obj${JSON.stringify(v)}`);\n    }\n  }\n  return parts.join(\"\u0001\");\n}\nfunction normalizeSingleKey(value) {\n  if (value === null) return null;\n  if (value instanceof Date) return `\\0d${value.getTime()}`;\n  if (typeof value === \"number\" || typeof value === \"string\" || typeof value === \"boolean\") {\n    return value;\n  }\n  return `\\0obj${JSON.stringify(value)}`;\n}\nfunction buildColumnFromValues(dtype, values) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n      return Float64Column.from(values);\n    case \"i32\" /* Int32 */:\n      return Int32Column.from(values);\n    case \"utf8\" /* Utf8 */:\n      return Utf8Column.from(values);\n    case \"bool\" /* Boolean */:\n      return BooleanColumn.from(values);\n    case \"date\" /* Date */:\n      return DateColumn.from(values);\n    default:\n      return Float64Column.from(values);\n  }\n}\nfunction resolveKeys(on) {\n  if (typeof on === \"string\") {\n    return { leftKeys: [on], rightKeys: [on] };\n  }\n  if (Array.isArray(on)) {\n    return { leftKeys: on, rightKeys: on };\n  }\n  const leftKeys = Array.isArray(on.left) ? on.left : [on.left];\n  const rightKeys = Array.isArray(on.right) ? on.right : [on.right];\n  if (leftKeys.length !== rightKeys.length) {\n    throw new Error(\"Left and right key arrays must have the same length\");\n  }\n  return { leftKeys, rightKeys };\n}\nfunction crossJoin(left, right, suffix) {\n  const resultLength = left.length * right.length;\n  const resultColumns = /* @__PURE__ */ new Map();\n  const columnOrder = [];\n  const rightColRenames = /* @__PURE__ */ new Map();\n  for (const rc of right.columns) {\n    if (left.columns.includes(rc)) {\n      rightColRenames.set(rc, `${rc}${suffix}`);\n    } else {\n      rightColRenames.set(rc, rc);\n    }\n  }\n  for (const colName of left.columns) {\n    const srcCol = left.col(colName).column;\n    const values = new Array(resultLength);\n    for (let li = 0; li < left.length; li++) {\n      const v = srcCol.get(li);\n      for (let ri = 0; ri < right.length; ri++) {\n        values[li * right.length + ri] = v;\n      }\n    }\n    resultColumns.set(colName, buildColumnFromValues(srcCol.dtype, values));\n    columnOrder.push(colName);\n  }\n  for (const colName of right.columns) {\n    const srcCol = right.col(colName).column;\n    const outputName = rightColRenames.get(colName);\n    const values = new Array(resultLength);\n    for (let li = 0; li < left.length; li++) {\n      for (let ri = 0; ri < right.length; ri++) {\n        values[li * right.length + ri] = srcCol.get(ri);\n      }\n    }\n    resultColumns.set(outputName, buildColumnFromValues(srcCol.dtype, values));\n    columnOrder.push(outputName);\n  }\n  const Ctor = left.constructor;\n  return new Ctor(resultColumns, columnOrder);\n}\nfunction semiAntiJoin(left, right, on, anti) {\n  const { leftKeys, rightKeys } = resolveKeys(on);\n  for (const key of leftKeys) {\n    if (!left.columns.includes(key)) {\n      throw new ColumnNotFoundError(key, left.columns);\n    }\n  }\n  for (const key of rightKeys) {\n    if (!right.columns.includes(key)) {\n      throw new ColumnNotFoundError(key, right.columns);\n    }\n  }\n  const rightKeyCols = rightKeys.map((k) => right.col(k).column);\n  const leftKeyCols = leftKeys.map((k) => left.col(k).column);\n  const rightKeySet = /* @__PURE__ */ new Set();\n  if (rightKeyCols.length === 1) {\n    const rightKeyCol = rightKeyCols[0];\n    for (let i = 0; i < right.length; i++) {\n      const key = normalizeSingleKey(rightKeyCol.get(i));\n      if (key !== null) rightKeySet.add(key);\n    }\n  } else {\n    for (let i = 0; i < right.length; i++) {\n      const keyStr = serializeKey(rightKeyCols, i);\n      if (keyStr !== null) rightKeySet.add(keyStr);\n    }\n  }\n  const matchedIndices = [];\n  if (leftKeyCols.length === 1) {\n    const leftKeyCol = leftKeyCols[0];\n    for (let i = 0; i < left.length; i++) {\n      const key = normalizeSingleKey(leftKeyCol.get(i));\n      const hasMatch = key !== null && rightKeySet.has(key);\n      if (anti ? !hasMatch : hasMatch) {\n        matchedIndices.push(i);\n      }\n    }\n  } else {\n    for (let i = 0; i < left.length; i++) {\n      const keyStr = serializeKey(leftKeyCols, i);\n      const hasMatch = keyStr !== null && rightKeySet.has(keyStr);\n      if (anti ? !hasMatch : hasMatch) {\n        matchedIndices.push(i);\n      }\n    }\n  }\n  const resultColumns = /* @__PURE__ */ new Map();\n  const columnOrder = [];\n  for (const colName of left.columns) {\n    const srcCol = left.col(colName).column;\n    const values = new Array(matchedIndices.length);\n    for (let i = 0; i < matchedIndices.length; i++) {\n      values[i] = srcCol.get(matchedIndices[i]);\n    }\n    resultColumns.set(colName, buildColumnFromValues(srcCol.dtype, values));\n    columnOrder.push(colName);\n  }\n  const Ctor = left.constructor;\n  return new Ctor(resultColumns, columnOrder);\n}\nfunction hashJoin(left, right, on, how = \"inner\", options) {\n  const suffix = options?.suffix ?? \"_right\";\n  if (how === \"cross\") {\n    return crossJoin(left, right, suffix);\n  }\n  if (how === \"semi\") {\n    return semiAntiJoin(left, right, on, false);\n  }\n  if (how === \"anti\") {\n    return semiAntiJoin(left, right, on, true);\n  }\n  const { leftKeys, rightKeys } = resolveKeys(on);\n  for (const key of leftKeys) {\n    if (!left.columns.includes(key)) {\n      throw new ColumnNotFoundError(key, left.columns);\n    }\n  }\n  for (const key of rightKeys) {\n    if (!right.columns.includes(key)) {\n      throw new ColumnNotFoundError(key, right.columns);\n    }\n  }\n  if (how === \"left\" && leftKeys.length === 1 && rightKeys.length === 1) {\n    const leftKeyCol = left.col(leftKeys[0]).column;\n    const rightKeyCol = right.col(rightKeys[0]).column;\n    const rightIndexByKey = /* @__PURE__ */ new Map();\n    let rightKeyUnique = true;\n    for (let i = 0; i < right.length; i++) {\n      const key = normalizeSingleKey(rightKeyCol.get(i));\n      if (key === null) continue;\n      if (rightIndexByKey.has(key)) {\n        rightKeyUnique = false;\n        break;\n      }\n      rightIndexByKey.set(key, i);\n    }\n    if (rightKeyUnique) {\n      const resultColumns2 = /* @__PURE__ */ new Map();\n      const columnOrder2 = [];\n      for (const colName of left.columns) {\n        resultColumns2.set(colName, left.col(colName).column);\n        columnOrder2.push(colName);\n      }\n      const rightNonKeyCols2 = right.columns.filter((c) => c !== rightKeys[0]);\n      const rightColRenames2 = /* @__PURE__ */ new Map();\n      for (const rc of rightNonKeyCols2) {\n        rightColRenames2.set(rc, left.columns.includes(rc) ? `${rc}${suffix}` : rc);\n      }\n      for (const colName of rightNonKeyCols2) {\n        const srcCol = right.col(colName).column;\n        const values = new Array(left.length);\n        for (let li = 0; li < left.length; li++) {\n          const key = normalizeSingleKey(leftKeyCol.get(li));\n          if (key === null) {\n            values[li] = null;\n            continue;\n          }\n          const ri = rightIndexByKey.get(key);\n          values[li] = ri === void 0 ? null : srcCol.get(ri);\n        }\n        const outputName = rightColRenames2.get(colName);\n        resultColumns2.set(outputName, buildColumnFromValues(srcCol.dtype, values));\n        columnOrder2.push(outputName);\n      }\n      const Ctor2 = left.constructor;\n      return new Ctor2(resultColumns2, columnOrder2);\n    }\n  }\n  const rightKeyCols = rightKeys.map((k) => right.col(k).column);\n  const hashTable = /* @__PURE__ */ new Map();\n  if (rightKeyCols.length === 1) {\n    const rightKeyCol = rightKeyCols[0];\n    for (let i = 0; i < right.length; i++) {\n      const key = normalizeSingleKey(rightKeyCol.get(i));\n      if (key === null) continue;\n      const bucket = hashTable.get(key);\n      if (bucket === void 0) {\n        hashTable.set(key, i);\n      } else if (typeof bucket === \"number\") {\n        hashTable.set(key, [bucket, i]);\n      } else {\n        bucket.push(i);\n      }\n    }\n  } else {\n    for (let i = 0; i < right.length; i++) {\n      const keyStr = serializeKey(rightKeyCols, i);\n      if (keyStr === null) continue;\n      const bucket = hashTable.get(keyStr);\n      if (bucket === void 0) {\n        hashTable.set(keyStr, [i]);\n      } else if (typeof bucket === \"number\") {\n        hashTable.set(keyStr, [bucket, i]);\n      } else {\n        bucket.push(i);\n      }\n    }\n  }\n  const leftKeyCols = leftKeys.map((k) => left.col(k).column);\n  const leftIndices = [];\n  const rightIndices = [];\n  const rightMatched = new Uint8Array(right.length);\n  if (leftKeyCols.length === 1) {\n    const leftKeyCol = leftKeyCols[0];\n    for (let i = 0; i < left.length; i++) {\n      const key = normalizeSingleKey(leftKeyCol.get(i));\n      if (key === null) {\n        if (how === \"left\" || how === \"outer\") {\n          leftIndices.push(i);\n          rightIndices.push(null);\n        }\n        continue;\n      }\n      const matches = hashTable.get(key);\n      if (matches !== void 0) {\n        if (typeof matches === \"number\") {\n          leftIndices.push(i);\n          rightIndices.push(matches);\n          if (how === \"right\" || how === \"outer\") {\n            rightMatched[matches] = 1;\n          }\n        } else {\n          for (let mi = 0; mi < matches.length; mi++) {\n            const ri = matches[mi];\n            leftIndices.push(i);\n            rightIndices.push(ri);\n            if (how === \"right\" || how === \"outer\") {\n              rightMatched[ri] = 1;\n            }\n          }\n        }\n      } else if (how === \"left\" || how === \"outer\") {\n        leftIndices.push(i);\n        rightIndices.push(null);\n      }\n    }\n  } else {\n    for (let i = 0; i < left.length; i++) {\n      const keyStr = serializeKey(leftKeyCols, i);\n      if (keyStr === null) {\n        if (how === \"left\" || how === \"outer\") {\n          leftIndices.push(i);\n          rightIndices.push(null);\n        }\n        continue;\n      }\n      const matches = hashTable.get(keyStr);\n      if (matches !== void 0) {\n        if (typeof matches === \"number\") {\n          leftIndices.push(i);\n          rightIndices.push(matches);\n          if (how === \"right\" || how === \"outer\") {\n            rightMatched[matches] = 1;\n          }\n        } else {\n          for (let mi = 0; mi < matches.length; mi++) {\n            const ri = matches[mi];\n            leftIndices.push(i);\n            rightIndices.push(ri);\n            if (how === \"right\" || how === \"outer\") {\n              rightMatched[ri] = 1;\n            }\n          }\n        }\n      } else if (how === \"left\" || how === \"outer\") {\n        leftIndices.push(i);\n        rightIndices.push(null);\n      }\n    }\n  }\n  if (how === \"right\" || how === \"outer\") {\n    for (let i = 0; i < right.length; i++) {\n      if (rightMatched[i] === 0) {\n        leftIndices.push(-1);\n        rightIndices.push(i);\n      }\n    }\n  }\n  const resultColumns = /* @__PURE__ */ new Map();\n  const columnOrder = [];\n  const resultLength = leftIndices.length;\n  const rightNonKeyCols = right.columns.filter((c) => !rightKeys.includes(c));\n  const leftNonKeyCols = left.columns.filter((c) => !leftKeys.includes(c));\n  const rightColRenames = /* @__PURE__ */ new Map();\n  for (const rc of rightNonKeyCols) {\n    if (left.columns.includes(rc)) {\n      rightColRenames.set(rc, `${rc}${suffix}`);\n    } else {\n      rightColRenames.set(rc, rc);\n    }\n  }\n  for (let ki = 0; ki < leftKeys.length; ki++) {\n    const leftKey = leftKeys[ki];\n    const rightKey = rightKeys[ki];\n    const leftCol = left.col(leftKey).column;\n    const rightCol = right.col(rightKey).column;\n    const values = new Array(resultLength);\n    for (let i = 0; i < resultLength; i++) {\n      const li = leftIndices[i];\n      const ri = rightIndices[i];\n      if (li >= 0) {\n        values[i] = leftCol.get(li);\n      } else if (ri !== null) {\n        values[i] = rightCol.get(ri);\n      } else {\n        values[i] = null;\n      }\n    }\n    resultColumns.set(leftKey, buildColumnFromValues(leftCol.dtype, values));\n    columnOrder.push(leftKey);\n  }\n  for (const colName of leftNonKeyCols) {\n    const srcCol = left.col(colName).column;\n    const values = new Array(resultLength);\n    for (let i = 0; i < resultLength; i++) {\n      const li = leftIndices[i];\n      values[i] = li >= 0 ? srcCol.get(li) : null;\n    }\n    resultColumns.set(colName, buildColumnFromValues(srcCol.dtype, values));\n    columnOrder.push(colName);\n  }\n  for (const colName of rightNonKeyCols) {\n    const srcCol = right.col(colName).column;\n    const outputName = rightColRenames.get(colName);\n    const values = new Array(resultLength);\n    for (let i = 0; i < resultLength; i++) {\n      const ri = rightIndices[i];\n      if (ri !== null) {\n        values[i] = srcCol.get(ri);\n      } else {\n        values[i] = null;\n      }\n    }\n    resultColumns.set(outputName, buildColumnFromValues(srcCol.dtype, values));\n    columnOrder.push(outputName);\n  }\n  const Ctor = left.constructor;\n  return new Ctor(resultColumns, columnOrder);\n}\n\n// src/ops/lookup.ts\nfunction serializeKey2(columns, index) {\n  const parts = [];\n  for (const column of columns) {\n    const v = column.get(index);\n    if (v === null) {\n      return null;\n    } else if (v instanceof Date) {\n      parts.push(`\\0d${v.getTime()}`);\n    } else if (typeof v === \"number\" || typeof v === \"string\" || typeof v === \"boolean\") {\n      parts.push(`\\0${typeof v}${String(v)}`);\n    } else {\n      parts.push(`\\0obj${JSON.stringify(v)}`);\n    }\n  }\n  return parts.join(\"\u0001\");\n}\nfunction buildColumnFromValues2(dtype, values) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n      return Float64Column.from(values);\n    case \"i32\" /* Int32 */:\n      return Int32Column.from(values);\n    case \"utf8\" /* Utf8 */:\n      return Utf8Column.from(values);\n    case \"bool\" /* Boolean */:\n      return BooleanColumn.from(values);\n    case \"date\" /* Date */:\n      return DateColumn.from(values);\n    default:\n      return new ObjectColumn(values);\n  }\n}\nfunction lookup(left, right, on, values) {\n  if (!left.columns.includes(on)) {\n    throw new ColumnNotFoundError(on, left.columns);\n  }\n  if (!right.columns.includes(on)) {\n    throw new ColumnNotFoundError(on, right.columns);\n  }\n  const valueCols = values ?? right.columns.filter((c) => c !== on);\n  for (const col2 of valueCols) {\n    if (!right.columns.includes(col2)) {\n      throw new ColumnNotFoundError(col2, right.columns);\n    }\n  }\n  const rightKeyCol = [right.col(on).column];\n  const lookupMap = /* @__PURE__ */ new Map();\n  for (let i = 0; i < right.length; i++) {\n    const keyStr = serializeKey2(rightKeyCol, i);\n    if (keyStr === null) continue;\n    if (!lookupMap.has(keyStr)) {\n      lookupMap.set(keyStr, i);\n    }\n  }\n  const leftKeyCol = [left.col(on).column];\n  const resultColumns = /* @__PURE__ */ new Map();\n  const columnOrder = [];\n  for (const colName of left.columns) {\n    resultColumns.set(colName, left.col(colName).column);\n    columnOrder.push(colName);\n  }\n  for (const colName of valueCols) {\n    const srcCol = right.col(colName).column;\n    const vals = new Array(left.length);\n    for (let i = 0; i < left.length; i++) {\n      const keyStr = serializeKey2(leftKeyCol, i);\n      if (keyStr !== null) {\n        const ri = lookupMap.get(keyStr);\n        vals[i] = ri !== void 0 ? srcCol.get(ri) : null;\n      } else {\n        vals[i] = null;\n      }\n    }\n    const outputName = left.columns.includes(colName) ? colName : colName;\n    resultColumns.set(outputName, buildColumnFromValues2(srcCol.dtype, vals));\n    columnOrder.push(outputName);\n  }\n  const Ctor = left.constructor;\n  return new Ctor(resultColumns, columnOrder);\n}\n\n// src/ops/spread.ts\nfunction spread(df2, column, options = {}) {\n  if (!df2.columns.includes(column)) {\n    throw new ColumnNotFoundError(column, df2.columns);\n  }\n  const { limit, name: nameFn, drop = false } = options;\n  const srcCol = df2.col(column).column;\n  const len = df2.length;\n  let isObject = false;\n  let maxArrayLen = 0;\n  const objectKeys = /* @__PURE__ */ new Set();\n  for (let i = 0; i < len; i++) {\n    const val = srcCol.get(i);\n    if (val === null) continue;\n    if (Array.isArray(val)) {\n      maxArrayLen = Math.max(maxArrayLen, val.length);\n    } else if (typeof val === \"object\") {\n      isObject = true;\n      for (const key of Object.keys(val)) {\n        objectKeys.add(key);\n      }\n    }\n  }\n  const resultColumns = /* @__PURE__ */ new Map();\n  const columnOrder = [];\n  for (const colName of df2.columns) {\n    if (drop && colName === column) continue;\n    resultColumns.set(colName, df2.col(colName).column);\n    columnOrder.push(colName);\n  }\n  if (isObject) {\n    const keys = [...objectKeys];\n    const effectiveKeys = limit !== void 0 ? keys.slice(0, limit) : keys;\n    for (const key of effectiveKeys) {\n      const outName = nameFn ? nameFn(column, key) : `${column}_${key}`;\n      const values = new Array(len);\n      for (let i = 0; i < len; i++) {\n        const val = srcCol.get(i);\n        if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n          values[i] = null;\n        } else {\n          const obj = val;\n          values[i] = key in obj ? obj[key] : null;\n        }\n      }\n      resultColumns.set(outName, ObjectColumn.from(values));\n      columnOrder.push(outName);\n    }\n  } else {\n    const width = limit !== void 0 ? Math.min(maxArrayLen, limit) : maxArrayLen;\n    for (let idx = 0; idx < width; idx++) {\n      const outName = nameFn ? nameFn(column, idx) : `${column}_${String(idx)}`;\n      const values = new Array(len);\n      for (let i = 0; i < len; i++) {\n        const val = srcCol.get(i);\n        if (val === null || !Array.isArray(val) || idx >= val.length) {\n          values[i] = null;\n        } else {\n          values[i] = val[idx];\n        }\n      }\n      resultColumns.set(outName, ObjectColumn.from(values));\n      columnOrder.push(outName);\n    }\n  }\n  const Ctor = df2.constructor;\n  return new Ctor(resultColumns, columnOrder);\n}\n\n// src/ops/unroll.ts\nfunction unroll(df2, columns, options = {}) {\n  const cols = Array.isArray(columns) ? columns : [columns];\n  for (const c of cols) {\n    if (!df2.columns.includes(c)) {\n      throw new ColumnNotFoundError(c, df2.columns);\n    }\n  }\n  const len = df2.length;\n  const nonUnrollCols = df2.columns.filter((c) => !cols.includes(c));\n  const rowCounts = new Array(len);\n  for (let i = 0; i < len; i++) {\n    let maxLen = 0;\n    for (const c of cols) {\n      const val = df2.col(c).column.get(i);\n      if (Array.isArray(val)) {\n        maxLen = Math.max(maxLen, val.length);\n      }\n    }\n    rowCounts[i] = maxLen;\n  }\n  const totalRows = rowCounts.reduce((a, b) => a + b, 0);\n  const resultData = {};\n  for (const c of nonUnrollCols) {\n    resultData[c] = new Array(totalRows);\n  }\n  for (const c of cols) {\n    resultData[c] = new Array(totalRows);\n  }\n  let indexData;\n  if (options.index) {\n    indexData = new Array(totalRows);\n  }\n  let outIdx = 0;\n  for (let i = 0; i < len; i++) {\n    const count = rowCounts[i];\n    if (count === 0) continue;\n    for (let j = 0; j < count; j++) {\n      for (const c of nonUnrollCols) {\n        resultData[c][outIdx] = df2.col(c).column.get(i);\n      }\n      for (const c of cols) {\n        const val = df2.col(c).column.get(i);\n        if (Array.isArray(val) && j < val.length) {\n          resultData[c][outIdx] = val[j];\n        } else {\n          resultData[c][outIdx] = null;\n        }\n      }\n      if (indexData) {\n        indexData[outIdx] = j;\n      }\n      outIdx++;\n    }\n  }\n  const resultColumns = /* @__PURE__ */ new Map();\n  const columnOrder = [];\n  for (const c of df2.columns) {\n    resultColumns.set(c, ObjectColumn.from(resultData[c]));\n    columnOrder.push(c);\n  }\n  if (options.index && indexData) {\n    resultColumns.set(options.index, ObjectColumn.from(indexData));\n    columnOrder.push(options.index);\n  }\n  const Ctor = df2.constructor;\n  return new Ctor(resultColumns, columnOrder);\n}\n\n// src/ops/impute.ts\nfunction rowKey(row, keys) {\n  return keys.map((k) => {\n    const value = row[k];\n    if (value === null) return \"__null__\";\n    if (value instanceof Date) return `__date__${String(value.getTime())}`;\n    return `__${typeof value}__${JSON.stringify(value)}`;\n  }).join(\"|\");\n}\nfunction cartesian(values) {\n  if (values.length === 0) return [[]];\n  let out = [[]];\n  for (const set of values) {\n    const next = [];\n    for (const prefix of out) {\n      for (const item of set) {\n        next.push([...prefix, item]);\n      }\n    }\n    out = next;\n  }\n  return out;\n}\nfunction impute(df2, values, options = {}) {\n  for (const colName of Object.keys(values)) {\n    if (!df2.columns.includes(colName)) {\n      throw new ColumnNotFoundError(colName, df2.columns);\n    }\n  }\n  const expandKeys = options.expand ?? [];\n  for (const key of expandKeys) {\n    if (!df2.columns.includes(key)) {\n      throw new ColumnNotFoundError(key, df2.columns);\n    }\n  }\n  const sourceRows = df2.toArray();\n  let workingRows = sourceRows;\n  if (expandKeys.length > 0) {\n    const keyDomains = expandKeys.map((key) => {\n      const seen = /* @__PURE__ */ new Set();\n      const out = [];\n      for (const row of sourceRows) {\n        const raw = row[key];\n        const normalized = raw instanceof Date ? `d:${String(raw.getTime())}` : JSON.stringify(raw);\n        if (!seen.has(normalized)) {\n          seen.add(normalized);\n          out.push(raw ?? null);\n        }\n      }\n      return out;\n    });\n    const combos = cartesian(keyDomains);\n    const existing = /* @__PURE__ */ new Map();\n    for (const row of sourceRows) {\n      existing.set(rowKey(row, expandKeys), row);\n    }\n    workingRows = combos.map((combo) => {\n      const comboRow = {};\n      for (let i = 0; i < expandKeys.length; i++) {\n        comboRow[expandKeys[i]] = combo[i] ?? null;\n      }\n      const existingRow = existing.get(rowKey(comboRow, expandKeys));\n      if (existingRow) {\n        return existingRow;\n      }\n      const generated = {};\n      for (const colName of df2.columns) {\n        generated[colName] = comboRow[colName] ?? null;\n      }\n      return generated;\n    });\n  }\n  const columnData = {};\n  for (const colName of df2.columns) {\n    columnData[colName] = workingRows.map((row) => row[colName] ?? null);\n  }\n  const resolvedValues = {};\n  for (const [colName, spec] of Object.entries(values)) {\n    resolvedValues[colName] = typeof spec === \"function\" ? spec(columnData) : spec;\n  }\n  const resultRows = workingRows.map((row) => {\n    const next = { ...row };\n    for (const [colName, fillValue] of Object.entries(resolvedValues)) {\n      if ((next[colName] ?? null) === null) {\n        next[colName] = fillValue;\n      }\n    }\n    return next;\n  });\n  return df2.constructor.fromRows(resultRows);\n}\n\n// src/ops/pivot.ts\nfunction aggregate(values, aggFunc) {\n  switch (aggFunc) {\n    case \"first\":\n      return values.length > 0 ? values[0] : null;\n    case \"last\":\n      return values.length > 0 ? values[values.length - 1] : null;\n    case \"count\":\n      return values.length;\n    case \"sum\": {\n      let total = 0;\n      for (const v of values) {\n        if (typeof v === \"number\") total += v;\n      }\n      return total;\n    }\n    case \"mean\": {\n      let total = 0;\n      let count = 0;\n      for (const v of values) {\n        if (typeof v === \"number\") {\n          total += v;\n          count++;\n        }\n      }\n      return count > 0 ? total / count : null;\n    }\n  }\n}\nfunction serializeKey3(df2, index, indexCols) {\n  const parts = [];\n  for (const name of indexCols) {\n    const v = df2.col(name).get(index);\n    if (v === null) {\n      parts.push(\"\\0null\");\n    } else if (v instanceof Date) {\n      parts.push(`\\0d${v.getTime()}`);\n    } else if (typeof v === \"number\" || typeof v === \"string\" || typeof v === \"boolean\") {\n      parts.push(`\\0${typeof v}${String(v)}`);\n    } else {\n      parts.push(`\\0obj${JSON.stringify(v)}`);\n    }\n  }\n  return parts.join(\"\u0001\");\n}\nfunction buildColumnFromValues3(dtype, values) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n      return Float64Column.from(values);\n    case \"i32\" /* Int32 */:\n      return Int32Column.from(values);\n    case \"utf8\" /* Utf8 */:\n      return Utf8Column.from(values);\n    case \"bool\" /* Boolean */:\n      return BooleanColumn.from(values);\n    case \"date\" /* Date */:\n      return DateColumn.from(values);\n    default:\n      return Float64Column.from(values);\n  }\n}\nfunction pivot(df2, options) {\n  const indexCols = Array.isArray(options.index) ? options.index : [options.index];\n  const columnsCol = options.columns;\n  const valuesCol = options.values;\n  const aggFunc = options.aggFunc ?? \"first\";\n  for (const col2 of [...indexCols, columnsCol, valuesCol]) {\n    if (!df2.columns.includes(col2)) {\n      throw new ColumnNotFoundError(col2, df2.columns);\n    }\n  }\n  const indexKeyOrder = [];\n  const indexKeyToRowIndices = /* @__PURE__ */ new Map();\n  for (let i = 0; i < df2.length; i++) {\n    const key = serializeKey3(df2, i, indexCols);\n    if (!indexKeyToRowIndices.has(key)) {\n      indexKeyOrder.push(key);\n      indexKeyToRowIndices.set(key, []);\n    }\n    indexKeyToRowIndices.get(key).push(i);\n  }\n  const pivotColValues = [];\n  const pivotColSet = /* @__PURE__ */ new Set();\n  const pivotColumnSeries = df2.col(columnsCol);\n  for (let i = 0; i < df2.length; i++) {\n    const v = pivotColumnSeries.get(i);\n    let str;\n    if (v === null) {\n      str = \"null\";\n    } else if (typeof v === \"string\" || typeof v === \"number\" || typeof v === \"boolean\") {\n      str = String(v);\n    } else if (v instanceof Date) {\n      str = v.toISOString();\n    } else {\n      str = JSON.stringify(v);\n    }\n    if (!pivotColSet.has(str)) {\n      pivotColSet.add(str);\n      pivotColValues.push(str);\n    }\n  }\n  const cellData = /* @__PURE__ */ new Map();\n  for (let i = 0; i < df2.length; i++) {\n    const indexKey = serializeKey3(df2, i, indexCols);\n    const pivotVal = pivotColumnSeries.get(i);\n    let pivotStr;\n    if (pivotVal === null) {\n      pivotStr = \"null\";\n    } else if (typeof pivotVal === \"string\" || typeof pivotVal === \"number\" || typeof pivotVal === \"boolean\") {\n      pivotStr = String(pivotVal);\n    } else if (pivotVal instanceof Date) {\n      pivotStr = pivotVal.toISOString();\n    } else {\n      pivotStr = JSON.stringify(pivotVal);\n    }\n    const cellKey = indexKey + \"\u0002\" + pivotStr;\n    if (!cellData.has(cellKey)) {\n      cellData.set(cellKey, []);\n    }\n    cellData.get(cellKey).push(df2.col(valuesCol).get(i));\n  }\n  const valuesDtype = df2.col(valuesCol).column.dtype;\n  const resultDtype = aggFunc === \"count\" ? \"f64\" /* Float64 */ : valuesDtype;\n  const resultColumns = /* @__PURE__ */ new Map();\n  const columnOrder = [];\n  for (const idxCol of indexCols) {\n    const vals = [];\n    const sourceCol = df2.col(idxCol);\n    for (const key of indexKeyOrder) {\n      const firstRow = indexKeyToRowIndices.get(key)[0];\n      vals.push(sourceCol.get(firstRow));\n    }\n    resultColumns.set(idxCol, buildColumnFromValues3(sourceCol.column.dtype, vals));\n    columnOrder.push(idxCol);\n  }\n  for (const pivotVal of pivotColValues) {\n    const vals = [];\n    for (const indexKey of indexKeyOrder) {\n      const cellKey = indexKey + \"\u0002\" + pivotVal;\n      const cellValues = cellData.get(cellKey);\n      if (cellValues && cellValues.length > 0) {\n        vals.push(aggregate(cellValues, aggFunc));\n      } else {\n        vals.push(null);\n      }\n    }\n    resultColumns.set(pivotVal, buildColumnFromValues3(resultDtype, vals));\n    columnOrder.push(pivotVal);\n  }\n  const Ctor = df2.constructor;\n  return new Ctor(resultColumns, columnOrder);\n}\n\n// src/ops/melt.ts\nfunction buildColumnFromValues4(dtype, values) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n      return Float64Column.from(values);\n    case \"i32\" /* Int32 */:\n      return Int32Column.from(values);\n    case \"utf8\" /* Utf8 */:\n      return Utf8Column.from(values);\n    case \"bool\" /* Boolean */:\n      return BooleanColumn.from(values);\n    case \"date\" /* Date */:\n      return DateColumn.from(values);\n    default:\n      return Float64Column.from(values);\n  }\n}\nfunction detectDType(values) {\n  for (const v of values) {\n    if (v === null || v === void 0) continue;\n    if (typeof v === \"number\") return Number.isInteger(v) ? \"f64\" /* Float64 */ : \"f64\" /* Float64 */;\n    if (typeof v === \"string\") return \"utf8\" /* Utf8 */;\n    if (typeof v === \"boolean\") return \"bool\" /* Boolean */;\n    if (v instanceof Date) return \"date\" /* Date */;\n  }\n  return \"f64\" /* Float64 */;\n}\nfunction melt(df2, options) {\n  const idVars = Array.isArray(options.idVars) ? options.idVars : [options.idVars];\n  const varName = options.varName ?? \"variable\";\n  const valueName = options.valueName ?? \"value\";\n  for (const col2 of idVars) {\n    if (!df2.columns.includes(col2)) {\n      throw new ColumnNotFoundError(col2, df2.columns);\n    }\n  }\n  let valueVars;\n  if (options.valueVars) {\n    valueVars = Array.isArray(options.valueVars) ? options.valueVars : [options.valueVars];\n    for (const col2 of valueVars) {\n      if (!df2.columns.includes(col2)) {\n        throw new ColumnNotFoundError(col2, df2.columns);\n      }\n    }\n  } else {\n    const idSet = new Set(idVars);\n    valueVars = df2.columns.filter((c) => !idSet.has(c));\n  }\n  const nRows = df2.length;\n  const nValueVars = valueVars.length;\n  const resultLength = nRows * nValueVars;\n  const resultColumns = /* @__PURE__ */ new Map();\n  const columnOrder = [];\n  for (const idCol of idVars) {\n    const sourceSeries = df2.col(idCol);\n    const vals = new Array(resultLength);\n    for (let i = 0; i < nRows; i++) {\n      const v = sourceSeries.get(i);\n      for (let j = 0; j < nValueVars; j++) {\n        vals[i * nValueVars + j] = v;\n      }\n    }\n    resultColumns.set(idCol, buildColumnFromValues4(sourceSeries.column.dtype, vals));\n    columnOrder.push(idCol);\n  }\n  const varValues = new Array(resultLength);\n  for (let i = 0; i < nRows; i++) {\n    for (let j = 0; j < nValueVars; j++) {\n      varValues[i * nValueVars + j] = valueVars[j];\n    }\n  }\n  resultColumns.set(varName, Utf8Column.from(varValues));\n  columnOrder.push(varName);\n  const valueValues = new Array(resultLength);\n  for (let i = 0; i < nRows; i++) {\n    for (let j = 0; j < nValueVars; j++) {\n      valueValues[i * nValueVars + j] = df2.col(valueVars[j]).get(i);\n    }\n  }\n  const valueDtype = detectDType(valueValues);\n  resultColumns.set(valueName, buildColumnFromValues4(valueDtype, valueValues));\n  columnOrder.push(valueName);\n  const Ctor = df2.constructor;\n  return new Ctor(resultColumns, columnOrder);\n}\n\n// src/ops/reshape.ts\nfunction detectDType2(values) {\n  for (const v of values) {\n    if (v === null || v === void 0) continue;\n    if (typeof v === \"number\") return \"f64\" /* Float64 */;\n    if (typeof v === \"string\") return \"utf8\" /* Utf8 */;\n    if (typeof v === \"boolean\") return \"bool\" /* Boolean */;\n    if (v instanceof Date) return \"date\" /* Date */;\n  }\n  return \"f64\" /* Float64 */;\n}\nfunction buildColumnFromValues5(dtype, values) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n      return Float64Column.from(values);\n    case \"i32\" /* Int32 */:\n      return Int32Column.from(values);\n    case \"utf8\" /* Utf8 */:\n      return Utf8Column.from(values);\n    case \"bool\" /* Boolean */:\n      return BooleanColumn.from(values);\n    case \"date\" /* Date */:\n      return DateColumn.from(values);\n    default:\n      return Float64Column.from(values);\n  }\n}\nfunction serializeValue(v) {\n  if (v === null || v === void 0) return \"null\";\n  if (v instanceof Date) return v.toISOString();\n  if (typeof v === \"number\" || typeof v === \"string\" || typeof v === \"boolean\") {\n    return String(v);\n  }\n  return JSON.stringify(v);\n}\nfunction transpose(df2, headerColumn) {\n  const Ctor = df2.constructor;\n  const nRows = df2.length;\n  const cols = df2.columns;\n  if (cols.length === 0 || nRows === 0) {\n    return new Ctor(/* @__PURE__ */ new Map(), []);\n  }\n  let newHeaders;\n  let sourceColumns;\n  if (headerColumn) {\n    const headerSeries = df2.col(headerColumn);\n    newHeaders = [];\n    for (let i = 0; i < nRows; i++) {\n      newHeaders.push(serializeValue(headerSeries.get(i)));\n    }\n    sourceColumns = cols.filter((c) => c !== headerColumn);\n  } else {\n    newHeaders = [];\n    for (let i = 0; i < nRows; i++) {\n      newHeaders.push(String(i));\n    }\n    sourceColumns = cols;\n  }\n  const resultColumns = /* @__PURE__ */ new Map();\n  const columnOrder = [\"column\"];\n  resultColumns.set(\"column\", Utf8Column.from(sourceColumns));\n  for (let rowIdx = 0; rowIdx < nRows; rowIdx++) {\n    const header = newHeaders[rowIdx];\n    const values = [];\n    for (const colName of sourceColumns) {\n      values.push(df2.col(colName).get(rowIdx));\n    }\n    const dtype = detectDType2(values);\n    resultColumns.set(header, buildColumnFromValues5(dtype, values));\n    columnOrder.push(header);\n  }\n  return new Ctor(resultColumns, columnOrder);\n}\nfunction concat(...frames) {\n  if (frames.length === 0) {\n    throw new ShapeMismatchError(\"concat requires at least one DataFrame\");\n  }\n  const first = frames[0];\n  const Ctor = first.constructor;\n  if (frames.length === 1) {\n    return first;\n  }\n  const allColumns = [];\n  const columnSet = /* @__PURE__ */ new Set();\n  for (const frame of frames) {\n    for (const col2 of frame.columns) {\n      if (!columnSet.has(col2)) {\n        columnSet.add(col2);\n        allColumns.push(col2);\n      }\n    }\n  }\n  const dtypeMap = /* @__PURE__ */ new Map();\n  for (const frame of frames) {\n    const dtypes = frame.dtypes;\n    for (const col2 of frame.columns) {\n      const existing = dtypeMap.get(col2);\n      const current = dtypes[col2];\n      if (existing !== void 0 && existing !== current) {\n        throw new ShapeMismatchError(\n          `Column '${col2}' has incompatible types: ${existing} vs ${current}`\n        );\n      }\n      dtypeMap.set(col2, current);\n    }\n  }\n  const totalRows = frames.reduce((sum, f) => sum + f.length, 0);\n  const resultColumns = /* @__PURE__ */ new Map();\n  for (const colName of allColumns) {\n    const values = new Array(totalRows);\n    let offset = 0;\n    for (const frame of frames) {\n      const frameLen = frame.length;\n      if (frame.columns.includes(colName)) {\n        const series = frame.col(colName);\n        for (let i = 0; i < frameLen; i++) {\n          values[offset + i] = series.get(i);\n        }\n      } else {\n        for (let i = 0; i < frameLen; i++) {\n          values[offset + i] = null;\n        }\n      }\n      offset += frameLen;\n    }\n    const dtype = dtypeMap.get(colName) ?? detectDType2(values);\n    resultColumns.set(colName, buildColumnFromValues5(dtype, values));\n  }\n  return new Ctor(resultColumns, allColumns);\n}\n\n// src/ops/setops.ts\nfunction serializeRow(df2, index, cols) {\n  const parts = [];\n  for (const name of cols) {\n    const v = df2.col(name).get(index);\n    if (v === null) {\n      parts.push(\"\\0null\");\n    } else if (v instanceof Date) {\n      parts.push(`\\0d${v.getTime()}`);\n    } else if (typeof v === \"number\" || typeof v === \"string\" || typeof v === \"boolean\") {\n      parts.push(`\\0${typeof v}${String(v)}`);\n    } else {\n      parts.push(`\\0obj${JSON.stringify(v)}`);\n    }\n  }\n  return parts.join(\"\u0001\");\n}\nfunction validateMatchingSchemas(left, right) {\n  const leftCols = left.columns;\n  const rightCols = right.columns;\n  if (leftCols.length !== rightCols.length) {\n    throw new ShapeMismatchError(\n      `Schema mismatch: left has ${leftCols.length} columns, right has ${rightCols.length} columns`\n    );\n  }\n  const leftDtypes = left.dtypes;\n  const rightDtypes = right.dtypes;\n  for (const name of leftCols) {\n    if (!(name in rightDtypes)) {\n      throw new ShapeMismatchError(\n        `Schema mismatch: column '${name}' not found in right DataFrame`\n      );\n    }\n    if (leftDtypes[name] !== rightDtypes[name]) {\n      throw new ShapeMismatchError(\n        `Schema mismatch: column '${name}' has dtype '${leftDtypes[name]}' in left but '${rightDtypes[name]}' in right`\n      );\n    }\n  }\n}\nfunction buildColumnFromValues6(dtype, values) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n      return Float64Column.from(values);\n    case \"i32\" /* Int32 */:\n      return Int32Column.from(values);\n    case \"utf8\" /* Utf8 */:\n      return Utf8Column.from(values);\n    case \"bool\" /* Boolean */:\n      return BooleanColumn.from(values);\n    case \"date\" /* Date */:\n      return DateColumn.from(values);\n    default:\n      return Float64Column.from(values);\n  }\n}\nfunction collectRows(df2, indices) {\n  const cols = df2.columns;\n  const dtypes = df2.dtypes;\n  const resultColumns = /* @__PURE__ */ new Map();\n  for (const name of cols) {\n    const series = df2.col(name);\n    const values = [];\n    for (const idx of indices) {\n      values.push(series.get(idx));\n    }\n    resultColumns.set(name, buildColumnFromValues6(dtypes[name], values));\n  }\n  const Ctor = df2.constructor;\n  return new Ctor(resultColumns, [...cols]);\n}\nfunction union(left, right) {\n  validateMatchingSchemas(left, right);\n  const cols = left.columns;\n  const dtypes = left.dtypes;\n  const seen = /* @__PURE__ */ new Set();\n  const valueArrays = /* @__PURE__ */ new Map();\n  for (const name of cols) {\n    valueArrays.set(name, []);\n  }\n  for (let i = 0; i < left.length; i++) {\n    const key = serializeRow(left, i, cols);\n    if (!seen.has(key)) {\n      seen.add(key);\n      for (const name of cols) {\n        valueArrays.get(name).push(left.col(name).get(i));\n      }\n    }\n  }\n  for (let i = 0; i < right.length; i++) {\n    const key = serializeRow(right, i, cols);\n    if (!seen.has(key)) {\n      seen.add(key);\n      for (const name of cols) {\n        valueArrays.get(name).push(right.col(name).get(i));\n      }\n    }\n  }\n  const resultColumns = /* @__PURE__ */ new Map();\n  for (const name of cols) {\n    resultColumns.set(name, buildColumnFromValues6(dtypes[name], valueArrays.get(name)));\n  }\n  const Ctor = left.constructor;\n  return new Ctor(resultColumns, [...cols]);\n}\nfunction intersection(left, right) {\n  validateMatchingSchemas(left, right);\n  const cols = left.columns;\n  const rightKeys = /* @__PURE__ */ new Set();\n  for (let i = 0; i < right.length; i++) {\n    rightKeys.add(serializeRow(right, i, cols));\n  }\n  const seen = /* @__PURE__ */ new Set();\n  const indices = [];\n  for (let i = 0; i < left.length; i++) {\n    const key = serializeRow(left, i, cols);\n    if (rightKeys.has(key) && !seen.has(key)) {\n      seen.add(key);\n      indices.push(i);\n    }\n  }\n  return collectRows(left, indices);\n}\nfunction difference(left, right) {\n  validateMatchingSchemas(left, right);\n  const cols = left.columns;\n  const rightKeys = /* @__PURE__ */ new Set();\n  for (let i = 0; i < right.length; i++) {\n    rightKeys.add(serializeRow(right, i, cols));\n  }\n  const seen = /* @__PURE__ */ new Set();\n  const indices = [];\n  for (let i = 0; i < left.length; i++) {\n    const key = serializeRow(left, i, cols);\n    if (!rightKeys.has(key) && !seen.has(key)) {\n      seen.add(key);\n      indices.push(i);\n    }\n  }\n  return collectRows(left, indices);\n}\n\n// src/io/sql/writer.ts\nfunction escapeIdentifier(name) {\n  return `\"${name.replace(/\"/g, '\"\"')}\"`;\n}\nfunction escapeSQLValue(value) {\n  if (value === null || value === void 0) {\n    return \"NULL\";\n  }\n  if (typeof value === \"boolean\") {\n    return value ? \"TRUE\" : \"FALSE\";\n  }\n  if (typeof value === \"number\") {\n    if (!isFinite(value)) {\n      return \"NULL\";\n    }\n    return String(value);\n  }\n  if (typeof value === \"bigint\") {\n    return String(value);\n  }\n  if (value instanceof Date) {\n    return `'${value.toISOString()}'`;\n  }\n  if (typeof value === \"string\") {\n    return `'${value.replace(/'/g, \"''\")}'`;\n  }\n  const json = JSON.stringify(value);\n  return `'${json.replace(/'/g, \"''\")}'`;\n}\nfunction writeSQL(tableName, header, rows, options = {}) {\n  const batchSize = options.batchSize ?? 1e3;\n  if (header.length === 0 || rows.length === 0) {\n    return \"\";\n  }\n  const columnList = header.map(escapeIdentifier).join(\", \");\n  const statements = [];\n  for (let i = 0; i < rows.length; i += batchSize) {\n    const batch = rows.slice(i, i + batchSize);\n    const valueRows = batch.map((row) => {\n      const values = row.map(escapeSQLValue).join(\", \");\n      return `(${values})`;\n    });\n    statements.push(\n      `INSERT INTO ${escapeIdentifier(tableName)} (${columnList}) VALUES\n${valueRows.join(\",\\n\")};`\n    );\n  }\n  return statements.join(\"\\n\\n\");\n}\n\n// src/engine/lazy/plan.ts\nvar nextNodeId = 0;\nfunction createScanNode() {\n  return { type: \"scan\", id: nextNodeId++ };\n}\nfunction explainPlan(node, indent = 0) {\n  const pad = \"  \".repeat(indent);\n  switch (node.type) {\n    case \"scan\":\n      if (node.projection) {\n        return `${pad}SCAN [id=${node.id}, cols=${node.projection.join(\", \")}]`;\n      }\n      return `${pad}SCAN [id=${node.id}]`;\n    case \"filter\":\n      return `${pad}FILTER [${node.predicate.toString()}]\n${explainPlan(node.input, indent + 1)}`;\n    case \"select\":\n      return `${pad}SELECT [${node.columns.join(\", \")}]\n${explainPlan(node.input, indent + 1)}`;\n    case \"project\": {\n      const exprStrs = node.exprs.map((e) => e.toString()).join(\", \");\n      return `${pad}PROJECT [${exprStrs}]\n${explainPlan(node.input, indent + 1)}`;\n    }\n    case \"groupby\": {\n      const aggStrs = node.aggs.map((a) => a.toString()).join(\", \");\n      return `${pad}GROUPBY [keys: ${node.keys.join(\", \")}; aggs: ${aggStrs}]\n${explainPlan(node.input, indent + 1)}`;\n    }\n    case \"join\":\n      return `${pad}JOIN [${node.how}]\n${pad}  left:\n${explainPlan(node.left, indent + 2)}\n${pad}  right:\n${explainPlan(node.right, indent + 2)}`;\n    case \"sort\":\n      return `${pad}SORT [${node.by} ${node.descending ? \"DESC\" : \"ASC\"}]\n${explainPlan(node.input, indent + 1)}`;\n    case \"limit\":\n      return `${pad}LIMIT [${node.n}]\n${explainPlan(node.input, indent + 1)}`;\n    case \"distinct\":\n      return `${pad}DISTINCT${node.subset ? ` [${node.subset.join(\", \")}]` : \"\"}\n${explainPlan(node.input, indent + 1)}`;\n  }\n}\n\n// src/engine/lazy/executor.ts\nfunction execute(plan, source) {\n  function run(node) {\n    switch (node.type) {\n      case \"scan\":\n        if (node.projection) {\n          return source.select(...node.projection);\n        }\n        return source;\n      case \"filter\": {\n        const input = run(node.input);\n        return input.filter(node.predicate);\n      }\n      case \"select\": {\n        const input = run(node.input);\n        return input.select(...node.columns);\n      }\n      case \"project\": {\n        const input = run(node.input);\n        let result = input;\n        for (const expr of node.exprs) {\n          const series = expr.evaluate(input);\n          result = result.withColumn(series.name, expr);\n        }\n        return result;\n      }\n      case \"groupby\": {\n        const input = run(node.input);\n        const gb = input.groupBy(...node.keys);\n        const specs = {};\n        for (const aggExpr of node.aggs) {\n          const agg = aggExpr;\n          const deps = agg.dependencies;\n          const outputName = deps[0] ?? \"value\";\n          specs[outputName] = agg;\n        }\n        return gb.agg(specs);\n      }\n      case \"sort\": {\n        const input = run(node.input);\n        return input.sortBy(node.by, node.descending ? \"desc\" : \"asc\");\n      }\n      case \"limit\": {\n        const input = run(node.input);\n        return input.head(node.n);\n      }\n      case \"distinct\": {\n        const input = run(node.input);\n        return input.unique(node.subset);\n      }\n      case \"join\": {\n        const left = run(node.left);\n        const right = run(node.right);\n        return left.join(right, node.on, node.how);\n      }\n    }\n  }\n  return run(plan);\n}\n\n// src/engine/lazy/optimizer.ts\nfunction optimize(plan) {\n  const optimized = pushDown(plan);\n  const merged = mergeFilters(optimized);\n  return pushProjectionDown(merged);\n}\nfunction pushDown(node) {\n  switch (node.type) {\n    case \"scan\":\n      return node;\n    case \"filter\": {\n      const input = pushDown(node.input);\n      const filter = { type: \"filter\", input, predicate: node.predicate };\n      return pushFilterDown(filter);\n    }\n    case \"select\":\n      return { type: \"select\", input: pushDown(node.input), columns: node.columns };\n    case \"project\":\n      return { type: \"project\", input: pushDown(node.input), exprs: node.exprs };\n    case \"groupby\":\n      return { type: \"groupby\", input: pushDown(node.input), keys: node.keys, aggs: node.aggs };\n    case \"sort\":\n      return { type: \"sort\", input: pushDown(node.input), by: node.by, descending: node.descending };\n    case \"limit\":\n      return { type: \"limit\", input: pushDown(node.input), n: node.n };\n    case \"distinct\":\n      return { type: \"distinct\", input: pushDown(node.input), subset: node.subset };\n    case \"join\":\n      return { type: \"join\", left: pushDown(node.left), right: pushDown(node.right), on: node.on, how: node.how };\n  }\n}\nfunction pushFilterDown(filter) {\n  const child = filter.input;\n  switch (child.type) {\n    // Safe to push filter below select/project\n    case \"select\":\n      return {\n        type: \"select\",\n        input: pushFilterDown({ type: \"filter\", input: child.input, predicate: filter.predicate }),\n        columns: child.columns\n      };\n    case \"project\":\n      return {\n        type: \"project\",\n        input: pushFilterDown({ type: \"filter\", input: child.input, predicate: filter.predicate }),\n        exprs: child.exprs\n      };\n    // Safe to push filter below sort\n    case \"sort\":\n      return {\n        type: \"sort\",\n        input: pushFilterDown({ type: \"filter\", input: child.input, predicate: filter.predicate }),\n        by: child.by,\n        descending: child.descending\n      };\n    // NOT safe to push below groupby â€” changes semantics\n    case \"groupby\":\n      return filter;\n    // For all other node types, keep filter in place\n    default:\n      return filter;\n  }\n}\nfunction mergeFilters(node) {\n  switch (node.type) {\n    case \"scan\":\n      return node;\n    case \"filter\": {\n      const input = mergeFilters(node.input);\n      if (input.type === \"filter\") {\n        return {\n          type: \"filter\",\n          input: input.input,\n          predicate: input.predicate.and(node.predicate)\n        };\n      }\n      return { type: \"filter\", input, predicate: node.predicate };\n    }\n    case \"select\":\n      return { type: \"select\", input: mergeFilters(node.input), columns: node.columns };\n    case \"project\":\n      return { type: \"project\", input: mergeFilters(node.input), exprs: node.exprs };\n    case \"groupby\":\n      return { type: \"groupby\", input: mergeFilters(node.input), keys: node.keys, aggs: node.aggs };\n    case \"sort\":\n      return { type: \"sort\", input: mergeFilters(node.input), by: node.by, descending: node.descending };\n    case \"limit\":\n      return { type: \"limit\", input: mergeFilters(node.input), n: node.n };\n    case \"distinct\":\n      return { type: \"distinct\", input: mergeFilters(node.input), subset: node.subset };\n    case \"join\":\n      return { type: \"join\", left: mergeFilters(node.left), right: mergeFilters(node.right), on: node.on, how: node.how };\n  }\n}\nfunction pushProjectionDown(node, needed) {\n  switch (node.type) {\n    case \"scan\": {\n      if (needed && needed.size > 0) {\n        const projection = [...needed].sort();\n        return { type: \"scan\", id: node.id, projection };\n      }\n      return node;\n    }\n    case \"select\": {\n      const childNeeded = new Set(node.columns);\n      return { type: \"select\", input: pushProjectionDown(node.input, childNeeded), columns: node.columns };\n    }\n    case \"filter\": {\n      const childNeeded = new Set(needed);\n      for (const dep of node.predicate.dependencies) {\n        childNeeded.add(dep);\n      }\n      return { type: \"filter\", input: pushProjectionDown(node.input, childNeeded), predicate: node.predicate };\n    }\n    case \"project\": {\n      const childNeeded = /* @__PURE__ */ new Set();\n      for (const expr of node.exprs) {\n        for (const dep of expr.dependencies) {\n          childNeeded.add(dep);\n        }\n      }\n      return { type: \"project\", input: pushProjectionDown(node.input, childNeeded), exprs: node.exprs };\n    }\n    case \"groupby\": {\n      const childNeeded = new Set(node.keys);\n      for (const agg of node.aggs) {\n        for (const dep of agg.dependencies) {\n          childNeeded.add(dep);\n        }\n      }\n      return { type: \"groupby\", input: pushProjectionDown(node.input, childNeeded), keys: node.keys, aggs: node.aggs };\n    }\n    case \"sort\": {\n      const childNeeded = new Set(needed);\n      childNeeded.add(node.by);\n      return { type: \"sort\", input: pushProjectionDown(node.input, childNeeded), by: node.by, descending: node.descending };\n    }\n    case \"limit\":\n      return { type: \"limit\", input: pushProjectionDown(node.input, needed), n: node.n };\n    case \"distinct\": {\n      if (node.subset) {\n        const childNeeded = new Set(needed);\n        for (const col2 of node.subset) {\n          childNeeded.add(col2);\n        }\n        return { type: \"distinct\", input: pushProjectionDown(node.input, childNeeded), subset: node.subset };\n      }\n      return { type: \"distinct\", input: pushProjectionDown(node.input, needed), subset: node.subset };\n    }\n    case \"join\": {\n      const onCols = typeof node.on === \"string\" ? [node.on] : node.on;\n      const leftNeeded = new Set(needed);\n      const rightNeeded = new Set(needed);\n      for (const c of onCols) {\n        leftNeeded.add(c);\n        rightNeeded.add(c);\n      }\n      return { type: \"join\", left: pushProjectionDown(node.left, leftNeeded), right: pushProjectionDown(node.right, rightNeeded), on: node.on, how: node.how };\n    }\n  }\n}\n\n// src/lazy.ts\nvar LazyGroupBy = class {\n  /** @internal */\n  _source;\n  /** @internal */\n  _plan;\n  /** @internal */\n  _keys;\n  constructor(source, plan, keys) {\n    this._source = source;\n    this._plan = plan;\n    this._keys = keys;\n  }\n  agg(...specs) {\n    return new LazyFrame(this._source, {\n      type: \"groupby\",\n      input: this._plan,\n      keys: [...this._keys],\n      aggs: specs\n    });\n  }\n};\nvar LazyFrame = class _LazyFrame {\n  /** @internal */\n  _source;\n  /** @internal */\n  _plan;\n  constructor(source, plan) {\n    this._source = source;\n    this._plan = plan;\n  }\n  filter(predicate) {\n    return new _LazyFrame(this._source, {\n      type: \"filter\",\n      input: this._plan,\n      predicate\n    });\n  }\n  select(...columns) {\n    return new _LazyFrame(this._source, {\n      type: \"select\",\n      input: this._plan,\n      columns\n    });\n  }\n  project(...exprs) {\n    return new _LazyFrame(this._source, {\n      type: \"project\",\n      input: this._plan,\n      exprs\n    });\n  }\n  sort(by, descending = false) {\n    return new _LazyFrame(this._source, {\n      type: \"sort\",\n      input: this._plan,\n      by,\n      descending\n    });\n  }\n  sortBy(by, descending = false) {\n    return this.sort(by, descending);\n  }\n  limit(n) {\n    return new _LazyFrame(this._source, {\n      type: \"limit\",\n      input: this._plan,\n      n\n    });\n  }\n  head(n) {\n    return this.limit(n);\n  }\n  distinct(subset) {\n    return new _LazyFrame(this._source, {\n      type: \"distinct\",\n      input: this._plan,\n      subset\n    });\n  }\n  unique(subset) {\n    return this.distinct(subset);\n  }\n  groupBy(...keys) {\n    return new LazyGroupBy(this._source, this._plan, keys);\n  }\n  explain() {\n    const original = explainPlan(this._plan);\n    const optimizedPlan = optimize(this._plan);\n    const optimized = explainPlan(optimizedPlan);\n    return `ORIGINAL:\n${original}\n\nOPTIMIZED:\n${optimized}`;\n  }\n  collect() {\n    return Promise.resolve(execute(this._plan, this._source));\n  }\n  async sink(filePath) {\n    const df2 = await this.collect();\n    const ext = filePath.toLowerCase();\n    if (ext.endsWith(\".csv\") || ext.endsWith(\".tsv\")) {\n      await df2.toCSV(filePath);\n    } else if (ext.endsWith(\".ndjson\") || ext.endsWith(\".jsonl\")) {\n      await df2.toNDJSON(filePath);\n    } else {\n      throw new Error(`Unsupported sink format for '${filePath}'. Supported: .csv, .tsv, .ndjson, .jsonl`);\n    }\n  }\n};\nfunction createLazyFrame(source) {\n  return new LazyFrame(source, createScanNode());\n}\n\n// src/ops/query.ts\nvar KEYWORDS = /* @__PURE__ */ new Set([\n  \"SELECT\",\n  \"FROM\",\n  \"WHERE\",\n  \"ORDER\",\n  \"BY\",\n  \"LIMIT\",\n  \"GROUP\",\n  \"HAVING\",\n  \"AND\",\n  \"OR\",\n  \"IN\",\n  \"LIKE\",\n  \"IS\",\n  \"NOT\",\n  \"NULL\",\n  \"ASC\",\n  \"DESC\",\n  \"AS\"\n]);\nfunction tokenize(input) {\n  const tokens = [];\n  let i = 0;\n  while (i < input.length) {\n    if (/\\s/.test(input[i])) {\n      i++;\n      continue;\n    }\n    const pos = i;\n    if (input[i] === \"'\") {\n      i++;\n      let value = \"\";\n      while (i < input.length && input[i] !== \"'\") {\n        if (input[i] === \"'\" && input[i + 1] === \"'\") {\n          value += \"'\";\n          i += 2;\n        } else {\n          value += input[i];\n          i++;\n        }\n      }\n      if (i >= input.length) {\n        throw new ParseError(`Unterminated string literal at position ${pos}`);\n      }\n      i++;\n      tokens.push({ type: \"STRING\" /* STRING */, value, position: pos });\n      continue;\n    }\n    if (/\\d/.test(input[i]) || input[i] === \"-\" && i + 1 < input.length && /\\d/.test(input[i + 1])) {\n      let value = \"\";\n      if (input[i] === \"-\") {\n        value += \"-\";\n        i++;\n      }\n      while (i < input.length && /[\\d.]/.test(input[i])) {\n        value += input[i];\n        i++;\n      }\n      tokens.push({ type: \"NUMBER\" /* NUMBER */, value, position: pos });\n      continue;\n    }\n    if (input[i] === \"*\") {\n      tokens.push({ type: \"STAR\" /* STAR */, value: \"*\", position: pos });\n      i++;\n      continue;\n    }\n    if (input[i] === \",\") {\n      tokens.push({ type: \"COMMA\" /* COMMA */, value: \",\", position: pos });\n      i++;\n      continue;\n    }\n    if (input[i] === \"(\") {\n      tokens.push({ type: \"LPAREN\" /* LPAREN */, value: \"(\", position: pos });\n      i++;\n      continue;\n    }\n    if (input[i] === \")\") {\n      tokens.push({ type: \"RPAREN\" /* RPAREN */, value: \")\", position: pos });\n      i++;\n      continue;\n    }\n    if (input[i] === \"!\" && input[i + 1] === \"=\") {\n      tokens.push({ type: \"NEQ\" /* NEQ */, value: \"!=\", position: pos });\n      i += 2;\n      continue;\n    }\n    if (input[i] === \"<\" && input[i + 1] === \">\") {\n      tokens.push({ type: \"NEQ\" /* NEQ */, value: \"<>\", position: pos });\n      i += 2;\n      continue;\n    }\n    if (input[i] === \">\" && input[i + 1] === \"=\") {\n      tokens.push({ type: \"GTE\" /* GTE */, value: \">=\", position: pos });\n      i += 2;\n      continue;\n    }\n    if (input[i] === \"<\" && input[i + 1] === \"=\") {\n      tokens.push({ type: \"LTE\" /* LTE */, value: \"<=\", position: pos });\n      i += 2;\n      continue;\n    }\n    if (input[i] === \">\") {\n      tokens.push({ type: \"GT\" /* GT */, value: \">\", position: pos });\n      i++;\n      continue;\n    }\n    if (input[i] === \"<\") {\n      tokens.push({ type: \"LT\" /* LT */, value: \"<\", position: pos });\n      i++;\n      continue;\n    }\n    if (input[i] === \"=\") {\n      tokens.push({ type: \"EQ\" /* EQ */, value: \"=\", position: pos });\n      i++;\n      continue;\n    }\n    if (/[a-zA-Z_]/.test(input[i])) {\n      let value = \"\";\n      while (i < input.length && /[a-zA-Z0-9_]/.test(input[i])) {\n        value += input[i];\n        i++;\n      }\n      const upper = value.toUpperCase();\n      if (KEYWORDS.has(upper)) {\n        tokens.push({ type: upper, value: upper, position: pos });\n      } else {\n        tokens.push({ type: \"IDENTIFIER\" /* IDENTIFIER */, value, position: pos });\n      }\n      continue;\n    }\n    throw new ParseError(`Unexpected character '${input[i]}' at position ${pos}`);\n  }\n  tokens.push({ type: \"EOF\" /* EOF */, value: \"\", position: i });\n  return tokens;\n}\nvar Parser = class {\n  tokens;\n  pos;\n  _selectItems = [];\n  constructor(tokens) {\n    this.tokens = tokens;\n    this.pos = 0;\n  }\n  current() {\n    return this.tokens[this.pos];\n  }\n  peek() {\n    return this.tokens[this.pos];\n  }\n  advance() {\n    const token = this.tokens[this.pos];\n    this.pos++;\n    return token;\n  }\n  expect(type) {\n    const token = this.current();\n    if (token.type !== type) {\n      throw new ParseError(\n        `Expected ${type} but got '${token.value}' at position ${token.position}`\n      );\n    }\n    return this.advance();\n  }\n  match(type) {\n    if (this.current().type === type) {\n      this.advance();\n      return true;\n    }\n    return false;\n  }\n  parse() {\n    this.expect(\"SELECT\" /* SELECT */);\n    let selectAll = false;\n    const selectItems = [];\n    if (this.current().type === \"STAR\" /* STAR */) {\n      selectAll = true;\n      this.advance();\n    } else {\n      selectItems.push(this.parseSelectItem());\n      while (this.match(\"COMMA\" /* COMMA */)) {\n        selectItems.push(this.parseSelectItem());\n      }\n    }\n    this._selectItems = selectItems;\n    this.expect(\"FROM\" /* FROM */);\n    const fromToken = this.expect(\"IDENTIFIER\" /* IDENTIFIER */);\n    if (fromToken.value !== \"this\") {\n      throw new ParseError(\n        `FROM clause must reference 'this', got '${fromToken.value}' at position ${fromToken.position}`\n      );\n    }\n    let whereExpr;\n    if (this.current().type === \"WHERE\" /* WHERE */) {\n      this.advance();\n      whereExpr = this.parseOrExpr();\n    }\n    const groupByColumns = [];\n    if (this.current().type === \"GROUP\" /* GROUP */) {\n      this.advance();\n      this.expect(\"BY\" /* BY */);\n      groupByColumns.push(this.expect(\"IDENTIFIER\" /* IDENTIFIER */).value);\n      while (this.match(\"COMMA\" /* COMMA */)) {\n        groupByColumns.push(this.expect(\"IDENTIFIER\" /* IDENTIFIER */).value);\n      }\n    }\n    let havingExpr;\n    if (this.current().type === \"HAVING\" /* HAVING */) {\n      this.advance();\n      havingExpr = this.parseOrExpr();\n    }\n    const orderByItems = [];\n    if (this.current().type === \"ORDER\" /* ORDER */) {\n      this.advance();\n      this.expect(\"BY\" /* BY */);\n      orderByItems.push(this.parseOrderByItem());\n      while (this.match(\"COMMA\" /* COMMA */)) {\n        orderByItems.push(this.parseOrderByItem());\n      }\n    }\n    let limit;\n    if (this.current().type === \"LIMIT\" /* LIMIT */) {\n      this.advance();\n      const num = this.expect(\"NUMBER\" /* NUMBER */);\n      limit = parseInt(num.value, 10);\n    }\n    if (this.current().type !== \"EOF\" /* EOF */) {\n      throw new ParseError(\n        `Unexpected token '${this.current().value}' at position ${this.current().position}`\n      );\n    }\n    return { selectItems, selectAll, whereExpr, groupByColumns, havingExpr, orderByItems, limit };\n  }\n  parseSelectItem() {\n    const token = this.current();\n    const upperVal = token.value.toUpperCase();\n    if (token.type === \"IDENTIFIER\" /* IDENTIFIER */ && [\"SUM\", \"AVG\", \"COUNT\", \"MIN\", \"MAX\"].includes(upperVal) && this.tokens[this.pos + 1]?.type === \"LPAREN\" /* LPAREN */) {\n      const aggName = upperVal;\n      this.advance();\n      this.advance();\n      let columnName;\n      if (this.current().type === \"STAR\" /* STAR */) {\n        columnName = \"*\";\n        this.advance();\n      } else {\n        columnName = this.expect(\"IDENTIFIER\" /* IDENTIFIER */).value;\n      }\n      this.expect(\"RPAREN\" /* RPAREN */);\n      let alias2;\n      if (this.current().type === \"AS\" /* AS */) {\n        this.advance();\n        alias2 = this.expect(\"IDENTIFIER\" /* IDENTIFIER */).value;\n      }\n      return { column: columnName, alias: alias2, aggregate: aggName };\n    }\n    const colName = this.expect(\"IDENTIFIER\" /* IDENTIFIER */).value;\n    let alias;\n    if (this.current().type === \"AS\" /* AS */) {\n      this.advance();\n      alias = this.expect(\"IDENTIFIER\" /* IDENTIFIER */).value;\n    }\n    return { column: colName, alias, aggregate: void 0 };\n  }\n  parseOrderByItem() {\n    const column = this.expect(\"IDENTIFIER\" /* IDENTIFIER */).value;\n    let direction = \"asc\";\n    if (this.current().type === \"ASC\" /* ASC */) {\n      this.advance();\n      direction = \"asc\";\n    } else if (this.current().type === \"DESC\" /* DESC */) {\n      this.advance();\n      direction = \"desc\";\n    }\n    return { column, direction };\n  }\n  // â”€â”€ Expression parsing (WHERE / HAVING) â”€â”€\n  parseOrExpr() {\n    let left = this.parseAndExpr();\n    while (this.current().type === \"OR\" /* OR */) {\n      this.advance();\n      const right = this.parseAndExpr();\n      left = left.or(right);\n    }\n    return left;\n  }\n  parseAndExpr() {\n    let left = this.parseComparison();\n    while (this.current().type === \"AND\" /* AND */) {\n      this.advance();\n      const right = this.parseComparison();\n      left = left.and(right);\n    }\n    return left;\n  }\n  parseComparison() {\n    if (this.current().type === \"LPAREN\" /* LPAREN */) {\n      this.advance();\n      const expr = this.parseOrExpr();\n      this.expect(\"RPAREN\" /* RPAREN */);\n      return expr;\n    }\n    if (this.current().type === \"NOT\" /* NOT */) {\n      this.advance();\n      const expr = this.parseComparison();\n      return expr.not();\n    }\n    const leftToken = this.current();\n    const upperVal = leftToken.value.toUpperCase();\n    if (leftToken.type === \"IDENTIFIER\" /* IDENTIFIER */ && [\"SUM\", \"AVG\", \"COUNT\", \"MIN\", \"MAX\"].includes(upperVal) && this.tokens[this.pos + 1]?.type === \"LPAREN\" /* LPAREN */) {\n      return this.parseAggregateComparison();\n    }\n    const columnName = this.expect(\"IDENTIFIER\" /* IDENTIFIER */).value;\n    const colExpr = col(columnName);\n    if (this.current().type === \"IS\" /* IS */) {\n      this.advance();\n      if (this.current().type === \"NOT\" /* NOT */) {\n        this.advance();\n        this.expect(\"NULL\" /* NULL */);\n        return new IsNullExpr2(columnName, true);\n      }\n      this.expect(\"NULL\" /* NULL */);\n      return new IsNullExpr2(columnName, false);\n    }\n    if (this.current().type === \"NOT\" /* NOT */) {\n      this.advance();\n      if (this.current().type === \"IN\" /* IN */) {\n        this.advance();\n        const values = this.parseValueList();\n        let inExpr = colExpr.eq(lit(values[0]));\n        for (let i = 1; i < values.length; i++) {\n          inExpr = inExpr.or(colExpr.eq(lit(values[i])));\n        }\n        return inExpr.not();\n      }\n      if (this.current().type === \"LIKE\" /* LIKE */) {\n        this.advance();\n        const pattern = this.expect(\"STRING\" /* STRING */).value;\n        return this.buildLikeExpr(columnName, pattern).not();\n      }\n      throw new ParseError(`Expected IN or LIKE after NOT at position ${this.current().position}`);\n    }\n    if (this.current().type === \"IN\" /* IN */) {\n      this.advance();\n      const values = this.parseValueList();\n      let inExpr = colExpr.eq(lit(values[0]));\n      for (let i = 1; i < values.length; i++) {\n        inExpr = inExpr.or(colExpr.eq(lit(values[i])));\n      }\n      return inExpr;\n    }\n    if (this.current().type === \"LIKE\" /* LIKE */) {\n      this.advance();\n      const pattern = this.expect(\"STRING\" /* STRING */).value;\n      return this.buildLikeExpr(columnName, pattern);\n    }\n    const op = this.current();\n    this.advance();\n    const rightValue = this.parseLiteralValue();\n    switch (op.type) {\n      case \"EQ\" /* EQ */:\n        return colExpr.eq(lit(rightValue));\n      case \"NEQ\" /* NEQ */:\n        return colExpr.neq(lit(rightValue));\n      case \"GT\" /* GT */:\n        return colExpr.gt(lit(rightValue));\n      case \"GTE\" /* GTE */:\n        return colExpr.gte(lit(rightValue));\n      case \"LT\" /* LT */:\n        return colExpr.lt(lit(rightValue));\n      case \"LTE\" /* LTE */:\n        return colExpr.lte(lit(rightValue));\n      default:\n        throw new ParseError(`Expected comparison operator at position ${op.position}, got '${op.value}'`);\n    }\n  }\n  parseAggregateComparison() {\n    const aggName = this.advance().value.toUpperCase();\n    this.expect(\"LPAREN\" /* LPAREN */);\n    let columnName;\n    if (this.current().type === \"STAR\" /* STAR */) {\n      columnName = \"*\";\n      this.advance();\n    } else {\n      columnName = this.expect(\"IDENTIFIER\" /* IDENTIFIER */).value;\n    }\n    this.expect(\"RPAREN\" /* RPAREN */);\n    const matchingSelect = this._selectItems.find(\n      (item) => item.aggregate === aggName && item.column === columnName\n    );\n    const aggAlias = matchingSelect?.alias ?? (columnName === \"*\" ? `${aggName.toLowerCase()}` : `${aggName.toLowerCase()}_${columnName}`);\n    const aggColExpr = col(aggAlias);\n    const op = this.current();\n    this.advance();\n    const rightValue = this.parseLiteralValue();\n    switch (op.type) {\n      case \"EQ\" /* EQ */:\n        return aggColExpr.eq(lit(rightValue));\n      case \"NEQ\" /* NEQ */:\n        return aggColExpr.neq(lit(rightValue));\n      case \"GT\" /* GT */:\n        return aggColExpr.gt(lit(rightValue));\n      case \"GTE\" /* GTE */:\n        return aggColExpr.gte(lit(rightValue));\n      case \"LT\" /* LT */:\n        return aggColExpr.lt(lit(rightValue));\n      case \"LTE\" /* LTE */:\n        return aggColExpr.lte(lit(rightValue));\n      default:\n        throw new ParseError(`Expected comparison operator at position ${op.position}, got '${op.value}'`);\n    }\n  }\n  parseLiteralValue() {\n    const token = this.current();\n    if (token.type === \"NUMBER\" /* NUMBER */) {\n      this.advance();\n      return parseFloat(token.value);\n    }\n    if (token.type === \"STRING\" /* STRING */) {\n      this.advance();\n      return token.value;\n    }\n    if (token.type === \"NULL\" /* NULL */) {\n      this.advance();\n      return null;\n    }\n    if (token.type === \"IDENTIFIER\" /* IDENTIFIER */) {\n      const upper = token.value.toUpperCase();\n      if (upper === \"TRUE\") {\n        this.advance();\n        return true;\n      }\n      if (upper === \"FALSE\") {\n        this.advance();\n        return false;\n      }\n    }\n    throw new ParseError(`Expected literal value at position ${token.position}, got '${token.value}'`);\n  }\n  parseValueList() {\n    this.expect(\"LPAREN\" /* LPAREN */);\n    const values = [];\n    values.push(this.parseLiteralValue());\n    while (this.match(\"COMMA\" /* COMMA */)) {\n      values.push(this.parseLiteralValue());\n    }\n    this.expect(\"RPAREN\" /* RPAREN */);\n    return values;\n  }\n  buildLikeExpr(columnName, pattern) {\n    const regexStr = \"^\" + pattern.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\").replace(/%/g, \".*\").replace(/_/g, \".\") + \"$\";\n    return new LikeExpr(columnName, regexStr);\n  }\n};\nvar LikeExpr = class extends Expr {\n  _columnName;\n  _regexStr;\n  constructor(columnName, regexStr) {\n    super();\n    this._columnName = columnName;\n    this._regexStr = regexStr;\n  }\n  get dependencies() {\n    return [this._columnName];\n  }\n  evaluate(df2) {\n    const series = df2.col(this._columnName);\n    const regex = new RegExp(this._regexStr);\n    const results = [];\n    for (let i = 0; i < series.length; i++) {\n      const val = series.column.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(regex.test(typeof val === \"string\" ? val : `${val}`));\n      }\n    }\n    return new Series(\"like_result\", BooleanColumn.from(results));\n  }\n  toString() {\n    return `LIKE(${this._columnName}, ${this._regexStr})`;\n  }\n};\nvar IsNullExpr2 = class extends Expr {\n  _columnName;\n  _invert;\n  constructor(columnName, invert) {\n    super();\n    this._columnName = columnName;\n    this._invert = invert;\n  }\n  get dependencies() {\n    return [this._columnName];\n  }\n  evaluate(df2) {\n    const series = df2.col(this._columnName);\n    return this._invert ? series.isNotNull() : series.isNull();\n  }\n  toString() {\n    return `${this._columnName} IS ${this._invert ? \"NOT \" : \"\"}NULL`;\n  }\n};\nfunction buildAggSpec(selectItems, groupByColumns) {\n  const specs = {};\n  for (const item of selectItems) {\n    if (groupByColumns.includes(item.column)) continue;\n    if (item.aggregate === void 0) continue;\n    const alias = item.alias ?? (item.column === \"*\" ? `${item.aggregate.toLowerCase()}` : `${item.aggregate.toLowerCase()}_${item.column}`);\n    const sourceCol = item.column === \"*\" ? groupByColumns[0] : item.column;\n    const colRef = col(sourceCol);\n    switch (item.aggregate) {\n      case \"SUM\":\n        specs[alias] = colRef.sum();\n        break;\n      case \"AVG\":\n        specs[alias] = colRef.mean();\n        break;\n      case \"COUNT\":\n        specs[alias] = colRef.count();\n        break;\n      case \"MIN\":\n        specs[alias] = colRef.min();\n        break;\n      case \"MAX\":\n        specs[alias] = colRef.max();\n        break;\n    }\n  }\n  return specs;\n}\nfunction executeQuery(df2, queryStr) {\n  const tokens = tokenize(queryStr);\n  const parser = new Parser(tokens);\n  const query = parser.parse();\n  let result = df2;\n  if (query.whereExpr !== void 0) {\n    result = result.filter(query.whereExpr);\n  }\n  if (query.groupByColumns.length > 0) {\n    const aggSpec = buildAggSpec(query.selectItems, query.groupByColumns);\n    const group = result.groupBy(...query.groupByColumns);\n    result = group.agg(aggSpec);\n    if (query.havingExpr !== void 0) {\n      result = result.filter(query.havingExpr);\n    }\n    if (!query.selectAll) {\n      const selectedCols = [];\n      for (const item of query.selectItems) {\n        if (item.aggregate !== void 0) {\n          const alias = item.alias ?? (item.column === \"*\" ? `${item.aggregate.toLowerCase()}` : `${item.aggregate.toLowerCase()}_${item.column}`);\n          selectedCols.push(alias);\n        } else {\n          selectedCols.push(item.alias ?? item.column);\n        }\n      }\n      result = result.select(...selectedCols);\n    }\n  } else {\n    if (!query.selectAll) {\n      const columnNames = query.selectItems.map((item) => item.column);\n      result = result.select(...columnNames);\n      const renameMap = {};\n      for (const item of query.selectItems) {\n        if (item.alias !== void 0) {\n          renameMap[item.column] = item.alias;\n        }\n      }\n      if (Object.keys(renameMap).length > 0) {\n        result = result.rename(renameMap);\n      }\n    }\n  }\n  if (query.orderByItems.length > 0) {\n    const columns = query.orderByItems.map((item) => item.column);\n    const orders = query.orderByItems.map((item) => item.direction);\n    result = result.sortBy(columns, orders);\n  }\n  if (query.limit !== void 0) {\n    result = result.head(query.limit);\n  }\n  return result;\n}\n\n// src/dataframe.ts\nvar DataFrame = class _DataFrame {\n  static _readers = /* @__PURE__ */ new Map();\n  static _writers = /* @__PURE__ */ new Map();\n  _columns;\n  _columnOrder;\n  constructor(columns, columnOrder) {\n    this._columns = columns;\n    this._columnOrder = columnOrder;\n    for (const col2 of columns.values()) {\n      col2.addRef();\n    }\n  }\n  get shape() {\n    return [this.length, this._columnOrder.length];\n  }\n  get columns() {\n    return [...this._columnOrder];\n  }\n  get dtypes() {\n    const result = {};\n    for (const name of this._columnOrder) {\n      result[name] = this._columns.get(name).dtype;\n    }\n    return result;\n  }\n  get length() {\n    if (this._columnOrder.length === 0) return 0;\n    return this._columns.get(this._columnOrder[0]).length;\n  }\n  col(name) {\n    const column = this._columns.get(name);\n    if (!column) {\n      throw new ColumnNotFoundError(name, this._columnOrder);\n    }\n    return new Series(name, column);\n  }\n  row(index) {\n    if (index < 0 || index >= this.length) {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `Row index ${index} out of bounds for DataFrame with ${this.length} rows`\n      );\n    }\n    const result = {};\n    for (const name of this._columnOrder) {\n      result[name] = this._columns.get(name).get(index);\n    }\n    return result;\n  }\n  *[Symbol.iterator]() {\n    for (let i = 0; i < this.length; i++) {\n      yield this.row(i);\n    }\n  }\n  rows() {\n    return this[Symbol.iterator]();\n  }\n  toArray() {\n    const result = [];\n    for (let i = 0; i < this.length; i++) {\n      result.push(this.row(i));\n    }\n    return result;\n  }\n  clone() {\n    const clonedColumns = /* @__PURE__ */ new Map();\n    for (const [name, col2] of this._columns) {\n      clonedColumns.set(name, col2.clone());\n    }\n    return new _DataFrame(clonedColumns, [...this._columnOrder]);\n  }\n  reify() {\n    return this.clone();\n  }\n  lazy() {\n    return createLazyFrame(this);\n  }\n  select(...columns) {\n    for (const name of columns) {\n      if (!this._columns.has(name)) {\n        throw new ColumnNotFoundError(name, this._columnOrder);\n      }\n    }\n    const newColumns = /* @__PURE__ */ new Map();\n    for (const name of columns) {\n      newColumns.set(name, this._columns.get(name));\n    }\n    return new _DataFrame(newColumns, [...columns]);\n  }\n  drop(...columns) {\n    for (const name of columns) {\n      if (!this._columns.has(name)) {\n        throw new ColumnNotFoundError(name, this._columnOrder);\n      }\n    }\n    const dropSet = new Set(columns);\n    const newColumns = /* @__PURE__ */ new Map();\n    const newOrder = [];\n    for (const name of this._columnOrder) {\n      if (!dropSet.has(name)) {\n        newColumns.set(name, this._columns.get(name));\n        newOrder.push(name);\n      }\n    }\n    return new _DataFrame(newColumns, newOrder);\n  }\n  head(n = 5) {\n    return this.slice(0, Math.min(n, this.length));\n  }\n  tail(n = 5) {\n    const start = Math.max(0, this.length - n);\n    return this.slice(start, this.length);\n  }\n  slice(start, end) {\n    const resolvedEnd = end === void 0 ? this.length : Math.min(end, this.length);\n    const resolvedStart = Math.max(0, start);\n    const newColumns = /* @__PURE__ */ new Map();\n    for (const name of this._columnOrder) {\n      newColumns.set(name, this._columns.get(name).slice(resolvedStart, resolvedEnd));\n    }\n    return new _DataFrame(newColumns, [...this._columnOrder]);\n  }\n  withColumn(name, valuesOrFnOrExpr) {\n    if (valuesOrFnOrExpr instanceof Expr) {\n      const series = valuesOrFnOrExpr.evaluate(this);\n      const newColumns2 = new Map(this._columns);\n      newColumns2.set(name, series.column);\n      const newOrder2 = this._columnOrder.includes(name) ? [...this._columnOrder] : [...this._columnOrder, name];\n      return new _DataFrame(newColumns2, newOrder2);\n    }\n    let columnValues;\n    if (typeof valuesOrFnOrExpr === \"function\") {\n      const fn = valuesOrFnOrExpr;\n      columnValues = [];\n      for (let i = 0; i < this.length; i++) {\n        columnValues.push(fn(this.row(i)));\n      }\n    } else {\n      columnValues = valuesOrFnOrExpr;\n      if (columnValues.length !== this.length) {\n        throw new ShapeMismatchError(\n          `Column '${name}' has length ${columnValues.length}, expected ${this.length}`\n        );\n      }\n    }\n    const dtype = detectDType3(columnValues);\n    const newCol = buildColumn(dtype, columnValues);\n    const newColumns = new Map(this._columns);\n    newColumns.set(name, newCol);\n    const newOrder = this._columnOrder.includes(name) ? [...this._columnOrder] : [...this._columnOrder, name];\n    return new _DataFrame(newColumns, newOrder);\n  }\n  assign(other) {\n    if (other.length !== this.length && other.columns.length > 0 && this._columnOrder.length > 0) {\n      throw new ShapeMismatchError(\n        `Cannot assign DataFrame with ${other.length} rows to DataFrame with ${this.length} rows`\n      );\n    }\n    const newColumns = new Map(this._columns);\n    const newOrder = [...this._columnOrder];\n    for (const name of other.columns) {\n      newColumns.set(name, other._columns.get(name));\n      if (!this._columnOrder.includes(name)) {\n        newOrder.push(name);\n      }\n    }\n    return new _DataFrame(newColumns, newOrder);\n  }\n  derive(exprs) {\n    let result = this;\n    for (const [name, fn] of Object.entries(exprs)) {\n      if (this.length === 0) {\n        result = result.withColumn(name, []);\n        continue;\n      }\n      const first = fn(this.row(0));\n      if (first instanceof Expr) {\n        result = result.withColumn(name, first.evaluate(this).toArray());\n        continue;\n      }\n      const values = [first];\n      for (let i = 1; i < this.length; i++) {\n        values.push(fn(this.row(i)));\n      }\n      result = result.withColumn(name, values);\n    }\n    return result;\n  }\n  lookup(other, on, values) {\n    return lookup(this, other, on, values);\n  }\n  spread(column, options) {\n    return spread(this, column, options);\n  }\n  unroll(columns, options) {\n    return unroll(this, columns, options);\n  }\n  impute(values, options) {\n    return impute(this, values, options);\n  }\n  relocate(columns, options) {\n    const { before, after } = options;\n    if (before !== void 0 && after !== void 0) {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        'Cannot specify both \"before\" and \"after\" in relocate'\n      );\n    }\n    if (before === void 0 && after === void 0) {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        'Must specify either \"before\" or \"after\" in relocate'\n      );\n    }\n    for (const col2 of columns) {\n      if (!this._columns.has(col2)) {\n        throw new ColumnNotFoundError(col2, this._columnOrder);\n      }\n    }\n    const anchor = before ?? after;\n    if (!this._columns.has(anchor)) {\n      throw new ColumnNotFoundError(anchor, this._columnOrder);\n    }\n    const remaining = this._columnOrder.filter((c) => !columns.includes(c));\n    const anchorIdx = remaining.indexOf(anchor);\n    const insertIdx = before !== void 0 ? anchorIdx : anchorIdx + 1;\n    const newOrder = [...remaining.slice(0, insertIdx), ...columns, ...remaining.slice(insertIdx)];\n    return new _DataFrame(new Map(this._columns), newOrder);\n  }\n  rename(mapping) {\n    for (const oldName of Object.keys(mapping)) {\n      if (!this._columns.has(oldName)) {\n        throw new ColumnNotFoundError(oldName, this._columnOrder);\n      }\n    }\n    const newColumns = /* @__PURE__ */ new Map();\n    const newOrder = [];\n    for (const name of this._columnOrder) {\n      const newName = mapping[name] ?? name;\n      newColumns.set(newName, this._columns.get(name));\n      newOrder.push(newName);\n    }\n    return new _DataFrame(newColumns, newOrder);\n  }\n  filter(predicateOrExpr) {\n    if (predicateOrExpr instanceof Expr) {\n      const maybeCmp = predicateOrExpr;\n      const cmpAny = maybeCmp;\n      if (cmpAny._op !== void 0 && cmpAny._left instanceof ColumnExpr && cmpAny._right instanceof LiteralExpr) {\n        const columnName = cmpAny._left.dependencies[0];\n        const literal = cmpAny._right._value;\n        const source = this._columns.get(columnName);\n        if (source) {\n          let count3 = 0;\n          for (let i = 0; i < this.length; i++) {\n            const v = source.get(i);\n            if (v === null || literal === null) continue;\n            let keep = false;\n            switch (cmpAny._op) {\n              case \"eq\":\n                keep = v === literal;\n                break;\n              case \"neq\":\n                keep = v !== literal;\n                break;\n              case \"gt\":\n                keep = v > literal;\n                break;\n              case \"gte\":\n                keep = v >= literal;\n                break;\n              case \"lt\":\n                keep = v < literal;\n                break;\n              case \"lte\":\n                keep = v <= literal;\n                break;\n            }\n            if (keep) count3++;\n          }\n          if (count3 === this.length) {\n            return this;\n          }\n          if (count3 === 0) {\n            return this.slice(0, 0);\n          }\n          const indices3 = new Int32Array(count3);\n          let pos3 = 0;\n          for (let i = 0; i < this.length; i++) {\n            const v = source.get(i);\n            if (v === null || literal === null) continue;\n            let keep = false;\n            switch (cmpAny._op) {\n              case \"eq\":\n                keep = v === literal;\n                break;\n              case \"neq\":\n                keep = v !== literal;\n                break;\n              case \"gt\":\n                keep = v > literal;\n                break;\n              case \"gte\":\n                keep = v >= literal;\n                break;\n              case \"lt\":\n                keep = v < literal;\n                break;\n              case \"lte\":\n                keep = v <= literal;\n                break;\n            }\n            if (keep) indices3[pos3++] = i;\n          }\n          return this._takeByInt32Indices(indices3);\n        }\n      }\n      const boolSeries = predicateOrExpr.evaluate(this);\n      let count2 = 0;\n      for (let i = 0; i < this.length; i++) {\n        if (boolSeries.get(i) === true) {\n          count2++;\n        }\n      }\n      if (count2 === this.length) {\n        return this;\n      }\n      if (count2 === 0) {\n        return this.slice(0, 0);\n      }\n      const indices2 = new Int32Array(count2);\n      let pos2 = 0;\n      for (let i = 0; i < this.length; i++) {\n        if (boolSeries.get(i) === true) {\n          indices2[pos2++] = i;\n        }\n      }\n      return this._takeByInt32Indices(indices2);\n    }\n    const predicate = predicateOrExpr;\n    let count = 0;\n    for (let i = 0; i < this.length; i++) {\n      if (predicate(this.row(i))) {\n        count++;\n      }\n    }\n    if (count === this.length) {\n      return this;\n    }\n    if (count === 0) {\n      return this.slice(0, 0);\n    }\n    const indices = new Int32Array(count);\n    let pos = 0;\n    for (let i = 0; i < this.length; i++) {\n      if (predicate(this.row(i))) {\n        indices[pos++] = i;\n      }\n    }\n    return this._takeByInt32Indices(indices);\n  }\n  apply(fn) {\n    if (this.length === 0) {\n      return new _DataFrame(/* @__PURE__ */ new Map(), [...this._columnOrder]);\n    }\n    const rows = [];\n    for (let i = 0; i < this.length; i++) {\n      rows.push(fn(this.row(i)));\n    }\n    return _DataFrame.fromRows(rows);\n  }\n  where(column, op, value) {\n    const colExpr = col(column);\n    const litValue = value;\n    let expr;\n    switch (op) {\n      case \"=\":\n        expr = colExpr.eq(litValue);\n        break;\n      case \"!=\":\n        expr = colExpr.neq(litValue);\n        break;\n      case \">\":\n        expr = colExpr.gt(litValue);\n        break;\n      case \">=\":\n        expr = colExpr.gte(litValue);\n        break;\n      case \"<\":\n        expr = colExpr.lt(litValue);\n        break;\n      case \"<=\":\n        expr = colExpr.lte(litValue);\n        break;\n    }\n    return this.filter(expr);\n  }\n  sortBy(columns, order) {\n    const cols = Array.isArray(columns) ? columns : [columns];\n    const orders = Array.isArray(order) ? order : cols.map(() => order ?? \"asc\");\n    for (const name of cols) {\n      if (!this._columns.has(name)) {\n        throw new ColumnNotFoundError(name, this._columnOrder);\n      }\n    }\n    if (cols.length === 1) {\n      const sortCol = this._columns.get(cols[0]);\n      const vals = new Array(this.length);\n      for (let i = 0; i < this.length; i++) vals[i] = sortCol.get(i);\n      const desc = orders[0] === \"desc\";\n      const indices2 = Array.from({ length: this.length }, (_, i) => i);\n      indices2.sort((a, b) => {\n        const va = vals[a];\n        const vb = vals[b];\n        const aIsNull = va === null || va === void 0;\n        const bIsNull = vb === null || vb === void 0;\n        if (aIsNull && bIsNull) return 0;\n        if (aIsNull) return 1;\n        if (bIsNull) return -1;\n        let cmp = 0;\n        if (typeof va === \"number\" && typeof vb === \"number\") {\n          cmp = va - vb;\n        } else if (typeof va === \"string\" && typeof vb === \"string\") {\n          cmp = va < vb ? -1 : va > vb ? 1 : 0;\n        } else if (typeof va === \"boolean\" && typeof vb === \"boolean\") {\n          cmp = (va ? 1 : 0) - (vb ? 1 : 0);\n        } else if (va instanceof Date && vb instanceof Date) {\n          cmp = va.getTime() - vb.getTime();\n        }\n        return desc ? -cmp : cmp;\n      });\n      const int32Indices2 = new Int32Array(indices2);\n      const newColumns2 = /* @__PURE__ */ new Map();\n      for (const name of this._columnOrder) {\n        newColumns2.set(name, this._columns.get(name).take(int32Indices2));\n      }\n      return new _DataFrame(newColumns2, [...this._columnOrder]);\n    }\n    if (cols.length === 2 && this._columns.get(cols[0]).dtype === \"utf8\" /* Utf8 */ && (this._columns.get(cols[1]).dtype === \"f64\" /* Float64 */ || this._columns.get(cols[1]).dtype === \"i32\" /* Int32 */)) {\n      const c0 = this._columns.get(cols[0]);\n      const c1 = this._columns.get(cols[1]);\n      const v0 = new Array(this.length);\n      const v1 = new Array(this.length);\n      for (let i = 0; i < this.length; i++) {\n        v0[i] = c0.get(i);\n        v1[i] = c1.get(i);\n      }\n      const d0 = orders[0] === \"desc\";\n      const d1 = orders[1] === \"desc\";\n      const indices2 = Array.from({ length: this.length }, (_, i) => i);\n      indices2.sort((a, b) => {\n        const a0 = v0[a];\n        const b0 = v0[b];\n        const a0Null = a0 === null;\n        const b0Null = b0 === null;\n        if (!a0Null || !b0Null) {\n          if (a0Null) return 1;\n          if (b0Null) return -1;\n          const cmp0 = a0 < b0 ? -1 : a0 > b0 ? 1 : 0;\n          if (cmp0 !== 0) return d0 ? -cmp0 : cmp0;\n        }\n        const a1 = v1[a];\n        const b1 = v1[b];\n        const a1Null = a1 === null;\n        const b1Null = b1 === null;\n        if (a1Null && b1Null) return 0;\n        if (a1Null) return 1;\n        if (b1Null) return -1;\n        const cmp1 = a1 - b1;\n        return d1 ? -cmp1 : cmp1;\n      });\n      const int32Indices2 = new Int32Array(indices2);\n      return this._takeByInt32Indices(int32Indices2);\n    }\n    const sortValues = cols.map((name) => {\n      const col2 = this._columns.get(name);\n      const vals = new Array(this.length);\n      for (let i = 0; i < this.length; i++) {\n        vals[i] = col2.get(i);\n      }\n      return vals;\n    });\n    const indices = Array.from({ length: this.length }, (_, i) => i);\n    indices.sort((a, b) => {\n      for (let c = 0; c < cols.length; c++) {\n        const va = sortValues[c][a];\n        const vb = sortValues[c][b];\n        const aIsNull = va === null || va === void 0;\n        const bIsNull = vb === null || vb === void 0;\n        if (aIsNull && bIsNull) continue;\n        if (aIsNull) return 1;\n        if (bIsNull) return -1;\n        let cmp = 0;\n        if (va instanceof Date && vb instanceof Date) {\n          cmp = va.getTime() - vb.getTime();\n        } else if (typeof va === \"string\" && typeof vb === \"string\") {\n          cmp = va < vb ? -1 : va > vb ? 1 : 0;\n        } else if (typeof va === \"number\" && typeof vb === \"number\") {\n          cmp = va - vb;\n        } else if (typeof va === \"boolean\" && typeof vb === \"boolean\") {\n          cmp = (va ? 1 : 0) - (vb ? 1 : 0);\n        }\n        if (cmp !== 0) {\n          return orders[c] === \"desc\" ? -cmp : cmp;\n        }\n      }\n      return 0;\n    });\n    const int32Indices = new Int32Array(indices);\n    const newColumns = /* @__PURE__ */ new Map();\n    for (const name of this._columnOrder) {\n      newColumns.set(name, this._columns.get(name).take(int32Indices));\n    }\n    return new _DataFrame(newColumns, [...this._columnOrder]);\n  }\n  unique(columns, keep = \"first\") {\n    const cols = columns === void 0 ? this._columnOrder : Array.isArray(columns) ? columns : [columns];\n    for (const name of cols) {\n      if (!this._columns.has(name)) {\n        throw new ColumnNotFoundError(name, this._columnOrder);\n      }\n    }\n    const seen = /* @__PURE__ */ new Set();\n    const indices = [];\n    if (keep === \"first\") {\n      for (let i = 0; i < this.length; i++) {\n        const key = this._rowKey(i, cols);\n        if (!seen.has(key)) {\n          seen.add(key);\n          indices.push(i);\n        }\n      }\n    } else {\n      const lastIndex = /* @__PURE__ */ new Map();\n      const order = [];\n      for (let i = 0; i < this.length; i++) {\n        const key = this._rowKey(i, cols);\n        if (!lastIndex.has(key)) {\n          order.push(key);\n        }\n        lastIndex.set(key, i);\n      }\n      for (const key of order) {\n        indices.push(lastIndex.get(key));\n      }\n    }\n    return this._takeByIndices(indices);\n  }\n  sample(n, options) {\n    if (this.length === 0) {\n      return this.clone();\n    }\n    let count;\n    if (n >= 1) {\n      count = Math.min(Math.floor(n), this.length);\n    } else if (n > 0 && n < 1) {\n      count = Math.max(1, Math.round(n * this.length));\n    } else {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `sample size must be positive, got ${n}`\n      );\n    }\n    const rng = options?.seed !== void 0 ? seededRandom(options.seed) : Math.random;\n    const indices = Array.from({ length: this.length }, (_, i) => i);\n    for (let i = indices.length - 1; i > 0; i--) {\n      const j = Math.floor(rng() * (i + 1));\n      const tmp = indices[i];\n      indices[i] = indices[j];\n      indices[j] = tmp;\n    }\n    return this._takeByIndices(indices.slice(0, count));\n  }\n  groupBy(...keys) {\n    return new GroupBy(this, keys);\n  }\n  join(other, on, how = \"inner\", options) {\n    return hashJoin(this, other, on, how, options);\n  }\n  pivot(options) {\n    return pivot(this, options);\n  }\n  melt(options) {\n    return melt(this, options);\n  }\n  explode(column) {\n    if (!this._columns.has(column)) {\n      throw new ColumnNotFoundError(column, this._columnOrder);\n    }\n    const explodeCol = this._columns.get(column);\n    const otherColNames = this._columnOrder.filter((n) => n !== column);\n    const resultArrays = {};\n    for (const name of this._columnOrder) {\n      resultArrays[name] = [];\n    }\n    for (let i = 0; i < this.length; i++) {\n      const val = explodeCol.get(i);\n      if (val === null) {\n        resultArrays[column].push(null);\n        for (const name of otherColNames) {\n          resultArrays[name].push(this._columns.get(name).get(i));\n        }\n      } else if (Array.isArray(val)) {\n        if (val.length === 0) {\n          continue;\n        }\n        for (const item of val) {\n          resultArrays[column].push(item === void 0 ? null : item);\n          for (const name of otherColNames) {\n            resultArrays[name].push(this._columns.get(name).get(i));\n          }\n        }\n      } else {\n        resultArrays[column].push(val);\n        for (const name of otherColNames) {\n          resultArrays[name].push(this._columns.get(name).get(i));\n        }\n      }\n    }\n    return _DataFrame.fromColumns(resultArrays);\n  }\n  transpose(headerColumn) {\n    return transpose(this, headerColumn);\n  }\n  static concat(...frames) {\n    return concat(...frames);\n  }\n  _rowKey(index, cols) {\n    const parts = [];\n    for (const name of cols) {\n      const v = this._columns.get(name).get(index);\n      if (v === null) {\n        parts.push(\"\\0null\");\n      } else if (v instanceof Date) {\n        parts.push(`\\0d${v.getTime()}`);\n      } else if (typeof v === \"number\" || typeof v === \"string\" || typeof v === \"boolean\") {\n        parts.push(`\\0${typeof v}${String(v)}`);\n      } else {\n        parts.push(`\\0obj${JSON.stringify(v)}`);\n      }\n    }\n    return parts.join(\"\u0001\");\n  }\n  _takeByIndices(indices) {\n    const int32Indices = new Int32Array(indices);\n    return this._takeByInt32Indices(int32Indices);\n  }\n  _takeByInt32Indices(int32Indices) {\n    const newColumns = /* @__PURE__ */ new Map();\n    for (const name of this._columnOrder) {\n      newColumns.set(name, this._columns.get(name).take(int32Indices));\n    }\n    return new _DataFrame(newColumns, [...this._columnOrder]);\n  }\n  dropNull(columns) {\n    const cols = columns === void 0 ? this._columnOrder : Array.isArray(columns) ? columns : [columns];\n    for (const name of cols) {\n      if (!this._columns.has(name)) {\n        throw new ColumnNotFoundError(name, this._columnOrder);\n      }\n    }\n    const indices = [];\n    for (let i = 0; i < this.length; i++) {\n      let hasNull = false;\n      for (const name of cols) {\n        if (this._columns.get(name).get(i) === null) {\n          hasNull = true;\n          break;\n        }\n      }\n      if (!hasNull) {\n        indices.push(i);\n      }\n    }\n    return this._takeByIndices(indices);\n  }\n  fillNull(strategy) {\n    if (typeof strategy === \"string\") {\n      return this._fillNullDirectional(strategy);\n    }\n    for (const colName of Object.keys(strategy)) {\n      if (!this._columns.has(colName)) {\n        throw new ColumnNotFoundError(colName, this._columnOrder);\n      }\n    }\n    const newColumns = /* @__PURE__ */ new Map();\n    for (const name of this._columnOrder) {\n      const col2 = this._columns.get(name);\n      const fillValue = strategy[name];\n      if (fillValue !== void 0) {\n        const values = [];\n        for (let i = 0; i < col2.length; i++) {\n          const v = col2.get(i);\n          values.push(v === null ? fillValue : v);\n        }\n        newColumns.set(name, buildColumn(col2.dtype, values));\n      } else {\n        newColumns.set(name, col2);\n      }\n    }\n    return new _DataFrame(newColumns, [...this._columnOrder]);\n  }\n  _fillNullDirectional(direction) {\n    const newColumns = /* @__PURE__ */ new Map();\n    for (const name of this._columnOrder) {\n      const col2 = this._columns.get(name);\n      if (col2.nullCount === 0) {\n        newColumns.set(name, col2);\n        continue;\n      }\n      const values = [];\n      for (let i = 0; i < col2.length; i++) {\n        values.push(col2.get(i));\n      }\n      if (direction === \"forward\") {\n        for (let i = 1; i < values.length; i++) {\n          if (values[i] === null && values[i - 1] !== null) {\n            values[i] = values[i - 1];\n          }\n        }\n      } else {\n        for (let i = values.length - 2; i >= 0; i--) {\n          if (values[i] === null && values[i + 1] !== null) {\n            values[i] = values[i + 1];\n          }\n        }\n      }\n      newColumns.set(name, buildColumn(col2.dtype, values));\n    }\n    return new _DataFrame(newColumns, [...this._columnOrder]);\n  }\n  cast(dtypes) {\n    for (const colName of Object.keys(dtypes)) {\n      if (!this._columns.has(colName)) {\n        throw new ColumnNotFoundError(colName, this._columnOrder);\n      }\n    }\n    const newColumns = /* @__PURE__ */ new Map();\n    for (const name of this._columnOrder) {\n      const targetDType = dtypes[name];\n      if (targetDType) {\n        const series = new Series(name, this._columns.get(name));\n        const casted = series.cast(targetDType);\n        newColumns.set(name, casted.column);\n      } else {\n        newColumns.set(name, this._columns.get(name));\n      }\n    }\n    return new _DataFrame(newColumns, [...this._columnOrder]);\n  }\n  toString(options) {\n    const maxRows = options?.maxRows ?? 10;\n    const maxCols = options?.maxCols ?? 10;\n    const [nRows, nCols] = this.shape;\n    if (nCols === 0 || nRows === 0) {\n      return `Empty DataFrame\n0 rows x ${nCols} columns`;\n    }\n    const allCols = this._columnOrder;\n    let displayCols;\n    if (allCols.length > maxCols) {\n      const half = Math.floor(maxCols / 2);\n      displayCols = [...allCols.slice(0, half), \"...\", ...allCols.slice(allCols.length - half)];\n    } else {\n      displayCols = [...allCols];\n    }\n    let rowIndices;\n    if (nRows > maxRows) {\n      const half = Math.floor(maxRows / 2);\n      rowIndices = [\n        ...Array.from({ length: half }, (_, i) => i),\n        -1,\n        // separator\n        ...Array.from({ length: half }, (_, i) => nRows - half + i)\n      ];\n    } else {\n      rowIndices = Array.from({ length: nRows }, (_, i) => i);\n    }\n    const formatValue = (v) => {\n      if (v === null) return \"null\";\n      if (v instanceof Date) return v.toISOString();\n      if (typeof v === \"number\" || typeof v === \"string\" || typeof v === \"boolean\") {\n        return String(v);\n      }\n      return JSON.stringify(v);\n    };\n    const headerRow = [\"\", ...displayCols];\n    const dataRows = [];\n    for (const idx of rowIndices) {\n      if (idx === -1) {\n        dataRows.push(headerRow.map(() => \"...\"));\n        continue;\n      }\n      const cells = [String(idx)];\n      for (const colName of displayCols) {\n        if (colName === \"...\") {\n          cells.push(\"...\");\n        } else {\n          cells.push(formatValue(this._columns.get(colName).get(idx)));\n        }\n      }\n      dataRows.push(cells);\n    }\n    const colWidths = headerRow.map((h, ci) => {\n      let maxW = h.length;\n      for (const row of dataRows) {\n        maxW = Math.max(maxW, row[ci].length);\n      }\n      return maxW;\n    });\n    const pad = (s, w, ci) => {\n      if (ci === 0) return s.padStart(w);\n      return s.padEnd(w);\n    };\n    const sep = \"\\u2500\";\n    const lines = [];\n    const headerLine = \"\\u2502 \" + headerRow.map((h, ci) => pad(h, colWidths[ci], ci)).join(\" \\u2502 \") + \" \\u2502\";\n    const topBorder = \"\\u250C\\u2500\" + colWidths.map((w) => sep.repeat(w)).join(\"\\u2500\\u252C\\u2500\") + \"\\u2500\\u2510\";\n    const headerSep = \"\\u251C\\u2500\" + colWidths.map((w) => sep.repeat(w)).join(\"\\u2500\\u253C\\u2500\") + \"\\u2500\\u2524\";\n    const bottomBorder = \"\\u2514\\u2500\" + colWidths.map((w) => sep.repeat(w)).join(\"\\u2500\\u2534\\u2500\") + \"\\u2500\\u2518\";\n    lines.push(topBorder);\n    lines.push(headerLine);\n    lines.push(headerSep);\n    for (const row of dataRows) {\n      lines.push(\"\\u2502 \" + row.map((cell, ci) => pad(cell, colWidths[ci], ci)).join(\" \\u2502 \") + \" \\u2502\");\n    }\n    lines.push(bottomBorder);\n    lines.push(`${nRows} rows x ${nCols} columns`);\n    return lines.join(\"\\n\");\n  }\n  print(options) {\n    console.log(this.toString(options));\n  }\n  describe() {\n    const statNames = [\"count\", \"mean\", \"std\", \"min\", \"max\"];\n    const resultColumns = { stat: statNames };\n    for (const name of this._columnOrder) {\n      const colObj = this._columns.get(name);\n      const dtype = colObj.dtype;\n      if (dtype === \"f64\" /* Float64 */ || dtype === \"i32\" /* Int32 */) {\n        const series = new Series(name, colObj);\n        const count = series.length - series.nullCount;\n        const mean = series.mean();\n        const std = series.std();\n        const min = series.min();\n        const max = series.max();\n        resultColumns[name] = [count, mean, std, min, max];\n      }\n    }\n    return _DataFrame.fromColumns(resultColumns);\n  }\n  memoryUsage() {\n    let total = 0;\n    for (const name of this._columnOrder) {\n      total += this._columns.get(name).estimatedMemoryBytes();\n    }\n    return total;\n  }\n  info() {\n    const [nRows, nCols] = this.shape;\n    const lines = [];\n    lines.push(`DataFrame: ${nRows} rows x ${nCols} columns`);\n    lines.push(\"\");\n    const colNameWidth = Math.max(6, ...this._columnOrder.map((n) => n.length));\n    const header = `${\"Column\".padEnd(colNameWidth)}  ${\"DType\".padEnd(10)}  ${\"Null Count\".padEnd(10)}  Memory`;\n    lines.push(header);\n    lines.push(\"\\u2500\".repeat(header.length));\n    let totalMemory = 0;\n    for (const name of this._columnOrder) {\n      const colObj = this._columns.get(name);\n      const dtype = colObj.dtype;\n      const nullCount = colObj.nullCount;\n      const mem = colObj.estimatedMemoryBytes();\n      totalMemory += mem;\n      lines.push(\n        `${name.padEnd(colNameWidth)}  ${dtype.padEnd(10)}  ${String(nullCount).padEnd(10)}  ${formatBytes(mem)}`\n      );\n    }\n    lines.push(\"\\u2500\".repeat(header.length));\n    lines.push(`Total memory: ${formatBytes(totalMemory)}`);\n    console.log(lines.join(\"\\n\"));\n  }\n  static fromColumns(data) {\n    const keys = Object.keys(data);\n    if (keys.length === 0) {\n      return _DataFrame.empty();\n    }\n    const firstKey = keys[0];\n    const rowCount = data[firstKey].length;\n    for (const key of keys) {\n      if (data[key].length !== rowCount) {\n        throw new ShapeMismatchError(\n          `Column '${key}' has length ${data[key].length}, expected ${rowCount}`\n        );\n      }\n    }\n    const columns = /* @__PURE__ */ new Map();\n    for (const key of keys) {\n      const values = data[key];\n      const dtype = detectDType3(values);\n      const col2 = buildColumn(dtype, values);\n      columns.set(key, col2);\n    }\n    return new _DataFrame(columns, keys);\n  }\n  static fromRows(rows) {\n    if (rows.length === 0) {\n      return _DataFrame.empty();\n    }\n    const columnSet = /* @__PURE__ */ new Set();\n    for (const row of rows) {\n      for (const key of Object.keys(row)) {\n        columnSet.add(key);\n      }\n    }\n    const columnNames = [...columnSet];\n    const data = {};\n    for (const name of columnNames) {\n      data[name] = [];\n    }\n    for (const row of rows) {\n      const r = row;\n      for (const name of columnNames) {\n        const value = name in r ? r[name] : null;\n        data[name].push(value === void 0 ? null : value);\n      }\n    }\n    return _DataFrame.fromColumns(data);\n  }\n  static empty() {\n    return new _DataFrame(/* @__PURE__ */ new Map(), []);\n  }\n  static range(name, start, end, step = 1) {\n    if (step === 0) {\n      throw new FrameKitError(\"INVALID_OPERATION\" /* INVALID_OPERATION */, \"step must not be zero\");\n    }\n    if (start >= end) {\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `start (${start}) must be less than end (${end})`\n      );\n    }\n    const length = Math.ceil((end - start) / step);\n    const data = new Float64Array(length);\n    for (let i = 0; i < length; i++) {\n      data[i] = start + i * step;\n    }\n    const mask = new BitArray(length, true);\n    const col2 = new Float64Column(data, mask);\n    const columns = /* @__PURE__ */ new Map();\n    columns.set(name, col2);\n    return new _DataFrame(columns, [name]);\n  }\n  static linspace(name, start, end, count) {\n    if (count < 2) {\n      throw new FrameKitError(\"INVALID_OPERATION\" /* INVALID_OPERATION */, \"count must be at least 2\");\n    }\n    const data = new Float64Array(count);\n    const step = (end - start) / (count - 1);\n    for (let i = 0; i < count; i++) {\n      data[i] = start + i * step;\n    }\n    const mask = new BitArray(count, true);\n    const col2 = new Float64Column(data, mask);\n    const columns = /* @__PURE__ */ new Map();\n    columns.set(name, col2);\n    return new _DataFrame(columns, [name]);\n  }\n  static async fromCSV(input, options = {}) {\n    let content;\n    if (typeof input !== \"string\") {\n      try {\n        const chunks = [];\n        for await (const chunk of input) {\n          chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));\n        }\n        content = Buffer.concat(chunks).toString(options.encoding ?? \"utf-8\");\n      } catch (err) {\n        if (err instanceof IOError) throw err;\n        const message = err instanceof Error ? err.message : String(err);\n        throw new IOError(`Failed to read CSV from stream: ${message}`);\n      }\n    } else if (options.parse === \"string\") {\n      content = input;\n    } else if (input.startsWith(\"http://\") || input.startsWith(\"https://\")) {\n      try {\n        const response = await fetch(input);\n        if (!response.ok) {\n          throw new IOError(\n            `Failed to fetch CSV from '${input}': HTTP ${String(response.status)} ${response.statusText}`\n          );\n        }\n        content = await response.text();\n      } catch (err) {\n        if (err instanceof IOError) throw err;\n        const message = err instanceof Error ? err.message : String(err);\n        throw new IOError(`Failed to fetch CSV from '${input}': ${message}`);\n      }\n    } else {\n      try {\n        const fs = await import(\"fs/promises\");\n        content = await fs.readFile(input, options.encoding ?? \"utf-8\");\n      } catch (err) {\n        if (err instanceof IOError) throw err;\n        const message = err instanceof Error ? err.message : String(err);\n        throw new IOError(`Failed to read CSV file '${input}': ${message}`);\n      }\n    }\n    const parsed = parseCSV(content, options);\n    return buildDataFrameFromParsed(parsed.header, parsed.columns, parsed.inferredTypes);\n  }\n  static async *streamCSV(path, options = {}) {\n    for await (const chunk of streamCSVFile(path, options)) {\n      yield buildDataFrameFromParsed(chunk.header, chunk.rawColumns, chunk.inferredTypes);\n    }\n  }\n  static scanCSV(path, options = {}) {\n    const placeholder = _DataFrame.empty();\n    const lazy = createLazyFrame(placeholder);\n    const originalCollect = lazy.collect.bind(lazy);\n    void originalCollect;\n    lazy.collect = async () => {\n      const chunks = [];\n      for await (const chunk of _DataFrame.streamCSV(path, options)) {\n        chunks.push(chunk);\n      }\n      if (chunks.length === 0) return _DataFrame.empty();\n      if (chunks.length === 1) return chunks[0];\n      return concat(...chunks);\n    };\n    return lazy;\n  }\n  static async *streamNDJSON(path, options = {}) {\n    for await (const chunk of streamNDJSONFile(path, options)) {\n      yield _DataFrame.fromRows(chunk);\n    }\n  }\n  static scanNDJSON(path, options = {}) {\n    const placeholder = _DataFrame.empty();\n    const lazy = createLazyFrame(placeholder);\n    const originalCollect = lazy.collect.bind(lazy);\n    void originalCollect;\n    lazy.collect = async () => {\n      const chunks = [];\n      for await (const chunk of _DataFrame.streamNDJSON(path, options)) {\n        chunks.push(chunk);\n      }\n      if (chunks.length === 0) return _DataFrame.empty();\n      if (chunks.length === 1) return chunks[0];\n      return concat(...chunks);\n    };\n    return lazy;\n  }\n  toCSV(filePathOrOptions, maybeOptions) {\n    let filePath;\n    let writable;\n    let options;\n    if (typeof filePathOrOptions === \"string\") {\n      filePath = filePathOrOptions;\n      options = maybeOptions ?? {};\n    } else if (filePathOrOptions != null && typeof filePathOrOptions === \"object\" && \"write\" in filePathOrOptions && typeof filePathOrOptions.write === \"function\") {\n      writable = filePathOrOptions;\n      options = maybeOptions ?? {};\n    } else {\n      options = filePathOrOptions ?? {};\n    }\n    const { header, rows } = this._extractRows();\n    const csvString = writeCSV(header, rows, options);\n    if (writable) {\n      const stream = writable;\n      return new Promise((resolve, reject) => {\n        let settled = false;\n        const fail = (err) => {\n          if (settled) return;\n          settled = true;\n          reject(new IOError(`Failed to write CSV to stream: ${err.message}`));\n        };\n        stream.once(\"error\", fail);\n        stream.write(csvString, \"utf-8\", (err) => {\n          if (err) {\n            fail(err);\n          } else {\n            if (settled) return;\n            settled = true;\n            stream.removeListener(\"error\", fail);\n            resolve();\n          }\n        });\n      });\n    }\n    if (filePath) {\n      return import(\"fs/promises\").then(\n        (fs) => fs.writeFile(filePath, csvString, \"utf-8\").catch((err) => {\n          const message = err instanceof Error ? err.message : String(err);\n          throw new IOError(`Failed to write CSV file '${filePath}': ${message}`);\n        })\n      );\n    }\n    return csvString;\n  }\n  static async fromJSON(input, options = {}) {\n    let content;\n    if (options.parse === \"string\") {\n      content = input;\n    } else {\n      try {\n        const fs = await import(\"fs/promises\");\n        content = await fs.readFile(input, \"utf-8\");\n      } catch (err) {\n        if (err instanceof IOError) throw err;\n        const message = err instanceof Error ? err.message : String(err);\n        throw new IOError(`Failed to read JSON file '${input}': ${message}`);\n      }\n    }\n    let parsed = JSON.parse(content);\n    if (options.path) {\n      const parts = options.path.split(\".\");\n      for (const part of parts) {\n        if (parsed !== null && typeof parsed === \"object\" && !Array.isArray(parsed)) {\n          parsed = parsed[part];\n        } else {\n          throw new IOError(`JSON path '${options.path}' not found: '${part}' is not an object`);\n        }\n      }\n    }\n    if (!Array.isArray(parsed)) {\n      throw new IOError(\"JSON content must be an array of objects\");\n    }\n    return _DataFrame.fromRows(parsed);\n  }\n  toJSON(filePathOrOptions, maybeOptions) {\n    let filePath;\n    let options;\n    if (typeof filePathOrOptions === \"string\") {\n      filePath = filePathOrOptions;\n      options = maybeOptions ?? {};\n    } else {\n      options = filePathOrOptions ?? {};\n    }\n    const { header, rows } = this._extractRows();\n    const jsonString = writeJSON(header, rows, options);\n    if (filePath) {\n      return import(\"fs/promises\").then(\n        (fs) => fs.writeFile(filePath, jsonString, \"utf-8\").catch((err) => {\n          const message = err instanceof Error ? err.message : String(err);\n          throw new IOError(`Failed to write JSON file '${filePath}': ${message}`);\n        })\n      );\n    }\n    return jsonString;\n  }\n  static async fromNDJSON(input, options = {}) {\n    let content;\n    if (options.parse === \"string\") {\n      content = input;\n    } else {\n      try {\n        const fs = await import(\"fs/promises\");\n        content = await fs.readFile(input, \"utf-8\");\n      } catch (err) {\n        if (err instanceof IOError) throw err;\n        const message = err instanceof Error ? err.message : String(err);\n        throw new IOError(`Failed to read NDJSON file '${input}': ${message}`);\n      }\n    }\n    const lines = content.split(\"\\n\").filter((line) => line.trim() !== \"\");\n    const rows = lines.map((line) => JSON.parse(line));\n    return _DataFrame.fromRows(rows);\n  }\n  static async fromExcel(filePath, options = {}) {\n    const parsed = await readExcelFile(filePath, options);\n    if (parsed.header.length === 0) {\n      return _DataFrame.empty();\n    }\n    const columns = /* @__PURE__ */ new Map();\n    for (const name of parsed.header) {\n      const dtype = parsed.inferredTypes[name] ?? \"f64\" /* Float64 */;\n      const values = parsed.columns[name];\n      columns.set(name, buildColumn(dtype, values));\n    }\n    return new _DataFrame(columns, [...parsed.header]);\n  }\n  static async fromParquet(filePath, options = {}) {\n    const parsed = await readParquetFile(filePath, options);\n    if (parsed.header.length === 0) {\n      return _DataFrame.empty();\n    }\n    const columns = /* @__PURE__ */ new Map();\n    for (const name of parsed.header) {\n      const dtype = parsed.inferredTypes[name] ?? \"f64\" /* Float64 */;\n      const values = parsed.columns[name];\n      columns.set(name, buildColumn(dtype, values));\n    }\n    return new _DataFrame(columns, [...parsed.header]);\n  }\n  async toExcel(filePath, options = {}) {\n    const { header, rows } = this._extractRows();\n    await writeExcelFile(filePath, header, rows, options);\n  }\n  async toParquet(filePath, options = {}) {\n    const header = this._columnOrder;\n    const columns = {};\n    for (const name of header) {\n      const col2 = this._columns.get(name);\n      const values = [];\n      for (let i = 0; i < col2.length; i++) {\n        values.push(col2.get(i));\n      }\n      columns[name] = { values, dtype: col2.dtype };\n    }\n    await writeParquetFile(filePath, header, columns, options);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async toArrow() {\n    return toArrowTable({\n      columnOrder: this._columnOrder,\n      getColumnValues: (name) => {\n        const col2 = this._columns.get(name);\n        const values = [];\n        for (let i = 0; i < col2.length; i++) {\n          values.push(col2.get(i));\n        }\n        return { values, dtype: col2.dtype };\n      }\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static fromArrow(table) {\n    const parsed = fromArrowTable(table);\n    if (parsed.header.length === 0) {\n      return _DataFrame.empty();\n    }\n    const columns = /* @__PURE__ */ new Map();\n    for (const name of parsed.header) {\n      const dtype = parsed.inferredTypes[name] ?? \"f64\" /* Float64 */;\n      const values = parsed.columns[name];\n      columns.set(name, buildColumn(dtype, values));\n    }\n    return new _DataFrame(columns, [...parsed.header]);\n  }\n  async toArrowIPC() {\n    let arrow;\n    try {\n      const moduleName = \"apache-arrow\";\n      arrow = await import(moduleName);\n    } catch {\n      throw new IOError(\n        \"apache-arrow is required for Arrow IPC serialization but is not installed. Run: npm install apache-arrow\"\n      );\n    }\n    const table = await this.toArrow();\n    return arrow.tableToIPC(table, \"stream\");\n  }\n  static async fromArrowIPC(buffer) {\n    let arrow;\n    try {\n      const moduleName = \"apache-arrow\";\n      arrow = await import(moduleName);\n    } catch {\n      throw new IOError(\n        \"apache-arrow is required for Arrow IPC deserialization but is not installed. Run: npm install apache-arrow\"\n      );\n    }\n    const table = arrow.tableFromIPC(buffer);\n    return _DataFrame.fromArrow(table);\n  }\n  toNDJSON(filePath) {\n    const { header, rows } = this._extractRows();\n    const ndjsonString = writeNDJSON(header, rows);\n    if (filePath) {\n      return import(\"fs/promises\").then(\n        (fs) => fs.writeFile(filePath, ndjsonString, \"utf-8\").catch((err) => {\n          const message = err instanceof Error ? err.message : String(err);\n          throw new IOError(`Failed to write NDJSON file '${filePath}': ${message}`);\n        })\n      );\n    }\n    return ndjsonString;\n  }\n  toSQL(tableName, options) {\n    const { header, rows } = this._extractRows();\n    return writeSQL(tableName, header, rows, options);\n  }\n  _extractRows() {\n    const header = this._columnOrder;\n    const rows = [];\n    for (let i = 0; i < this.length; i++) {\n      const row = [];\n      for (const name of this._columnOrder) {\n        row.push(this._columns.get(name).get(i));\n      }\n      rows.push(row);\n    }\n    return { header, rows };\n  }\n  union(other) {\n    return union(this, other);\n  }\n  intersection(other) {\n    return intersection(this, other);\n  }\n  difference(other) {\n    return difference(this, other);\n  }\n  query(queryStr) {\n    return executeQuery(this, queryStr);\n  }\n  static registerReader(extension, readerFn) {\n    const ext = extension.startsWith(\".\") ? extension.slice(1) : extension;\n    _DataFrame._readers.set(ext.toLowerCase(), readerFn);\n  }\n  static registerWriter(extension, writerFn) {\n    const ext = extension.startsWith(\".\") ? extension.slice(1) : extension;\n    _DataFrame._writers.set(ext.toLowerCase(), writerFn);\n  }\n  static async fromFile(filePath, options) {\n    const ext = filePath.split(\".\").pop()?.toLowerCase();\n    if (!ext) {\n      throw new IOError(`Cannot determine file extension from path: '${filePath}'`);\n    }\n    const reader = _DataFrame._readers.get(ext);\n    if (!reader) {\n      throw new IOError(\n        `No reader registered for extension '.${ext}'. Use DataFrame.registerReader('${ext}', readerFn) to register one.`\n      );\n    }\n    const fs = await import(\"fs/promises\");\n    let source;\n    try {\n      source = await fs.readFile(filePath);\n    } catch (err) {\n      const message = err instanceof Error ? err.message : String(err);\n      throw new IOError(`Failed to read file '${filePath}': ${message}`);\n    }\n    return reader(source, options);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async toFile(filePath, options) {\n    const ext = filePath.split(\".\").pop()?.toLowerCase();\n    if (!ext) {\n      throw new IOError(`Cannot determine file extension from path: '${filePath}'`);\n    }\n    const writer = _DataFrame._writers.get(ext);\n    if (!writer) {\n      throw new IOError(\n        `No writer registered for extension '.${ext}'. Use DataFrame.registerWriter('${ext}', writerFn) to register one.`\n      );\n    }\n    await writer(this, filePath, options);\n  }\n};\nfunction seededRandom(seed) {\n  let s = seed | 0;\n  return () => {\n    s = s + 1831565813 | 0;\n    let t = Math.imul(s ^ s >>> 15, 1 | s);\n    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;\n    return ((t ^ t >>> 14) >>> 0) / 4294967296;\n  };\n}\nfunction buildDataFrameFromParsed(header, rawColumns, inferredTypes) {\n  if (header.length === 0) {\n    return DataFrame.empty();\n  }\n  const columns = /* @__PURE__ */ new Map();\n  for (const name of header) {\n    const dtype = inferredTypes[name] ?? \"utf8\" /* Utf8 */;\n    const rawValues = rawColumns[name];\n    const typedValues = convertColumnValues(rawValues, dtype);\n    columns.set(name, buildColumn(dtype, typedValues));\n  }\n  return new DataFrame(columns, [...header]);\n}\nfunction convertColumnValues(values, dtype) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n    case \"i32\" /* Int32 */:\n      return values.map((v) => v === null ? null : Number(v));\n    case \"bool\" /* Boolean */:\n      return values.map((v) => {\n        if (v === null) return null;\n        return v.toLowerCase() === \"true\";\n      });\n    case \"date\" /* Date */:\n      return values.map((v) => v === null ? null : new Date(v));\n    case \"utf8\" /* Utf8 */:\n    default:\n      return values;\n  }\n}\nfunction detectDType3(values) {\n  for (const v of values) {\n    if (v === null || v === void 0) continue;\n    if (typeof v === \"number\") return \"f64\" /* Float64 */;\n    if (typeof v === \"string\") return \"utf8\" /* Utf8 */;\n    if (typeof v === \"boolean\") return \"bool\" /* Boolean */;\n    if (v instanceof Date) return \"date\" /* Date */;\n    if (Array.isArray(v) || typeof v === \"object\") return \"object\" /* Object */;\n  }\n  return \"f64\" /* Float64 */;\n}\nfunction buildColumn(dtype, values) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n      return Float64Column.from(values);\n    case \"i32\" /* Int32 */:\n      return Int32Column.from(values);\n    case \"utf8\" /* Utf8 */:\n      return Utf8Column.from(values);\n    case \"bool\" /* Boolean */:\n      return BooleanColumn.from(values);\n    case \"date\" /* Date */:\n      return DateColumn.from(values);\n    case \"object\" /* Object */:\n      return ObjectColumn.from(values);\n    default:\n      throw new FrameKitError(\n        \"INVALID_OPERATION\" /* INVALID_OPERATION */,\n        `Unsupported dtype for column construction: ${dtype}`\n      );\n  }\n}\nfunction formatBytes(bytes) {\n  if (bytes < 1024) return `${bytes} B`;\n  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;\n  if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;\n  return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n}\n_registerDataFrameFactory((columns, columnOrder) => new DataFrame(columns, columnOrder));\n\n// src/expr/conditional-expr.ts\nfunction detectValueDType(value) {\n  if (typeof value === \"number\") return \"f64\" /* Float64 */;\n  if (typeof value === \"string\") return \"utf8\" /* Utf8 */;\n  if (typeof value === \"boolean\") return \"bool\" /* Boolean */;\n  if (value instanceof Date) return \"date\" /* Date */;\n  return \"f64\" /* Float64 */;\n}\nfunction buildColumnForValues2(dtype, values) {\n  switch (dtype) {\n    case \"f64\" /* Float64 */:\n      return Float64Column.from(values);\n    case \"utf8\" /* Utf8 */:\n      return Utf8Column.from(values);\n    case \"bool\" /* Boolean */:\n      return BooleanColumn.from(values);\n    case \"date\" /* Date */:\n      return DateColumn.from(values);\n    default:\n      return Float64Column.from(values);\n  }\n}\nvar WhenExpr = class extends Expr {\n  _clauses;\n  _otherwise;\n  constructor(clauses, otherwise) {\n    super();\n    this._clauses = clauses;\n    this._otherwise = otherwise;\n  }\n  get dependencies() {\n    const deps = /* @__PURE__ */ new Set();\n    for (const clause of this._clauses) {\n      for (const d of clause.condition.dependencies) deps.add(d);\n      for (const d of clause.value.dependencies) deps.add(d);\n    }\n    if (this._otherwise) {\n      for (const d of this._otherwise.dependencies) deps.add(d);\n    }\n    return [...deps];\n  }\n  toString() {\n    const parts = this._clauses.map((c) => `WHEN ${c.condition.toString()} THEN ${c.value.toString()}`);\n    if (this._otherwise) {\n      parts.push(`ELSE ${this._otherwise.toString()}`);\n    }\n    return `CASE ${parts.join(\" \")} END`;\n  }\n  evaluate(df2) {\n    const len = df2.length;\n    const conditionResults = this._clauses.map((c) => c.condition.evaluate(df2));\n    const valueResults = this._clauses.map((c) => c.value.evaluate(df2));\n    const otherwiseResult = this._otherwise ? this._otherwise.evaluate(df2) : null;\n    const results = [];\n    let detectedDType = null;\n    for (let i = 0; i < len; i++) {\n      let matched = false;\n      for (let j = 0; j < this._clauses.length; j++) {\n        const cond = conditionResults[j].get(i);\n        if (cond === true) {\n          const val = valueResults[j].get(i);\n          results.push(val);\n          if (detectedDType === null && val !== null) {\n            detectedDType = detectValueDType(val);\n          }\n          matched = true;\n          break;\n        }\n      }\n      if (!matched) {\n        if (otherwiseResult) {\n          const val = otherwiseResult.get(i);\n          results.push(val);\n          if (detectedDType === null && val !== null) {\n            detectedDType = detectValueDType(val);\n          }\n        } else {\n          results.push(null);\n        }\n      }\n    }\n    const dtype = detectedDType ?? \"f64\" /* Float64 */;\n    const col2 = buildColumnForValues2(dtype, results);\n    return new Series(\"\", col2);\n  }\n};\nvar WhenBuilder = class {\n  _condition;\n  constructor(condition) {\n    this._condition = condition;\n  }\n  then(value) {\n    const expr = value instanceof Expr ? value : new LiteralExpr(value);\n    return new ThenBuilder([{ condition: this._condition, value: expr }]);\n  }\n};\nvar ThenBuilder = class {\n  _clauses;\n  constructor(clauses) {\n    this._clauses = clauses;\n  }\n  when(condition) {\n    return new ChainedWhenBuilder(this._clauses, condition);\n  }\n  otherwise(value) {\n    const expr = value instanceof Expr ? value : new LiteralExpr(value);\n    return new WhenExpr(this._clauses, expr);\n  }\n};\nvar ChainedWhenBuilder = class {\n  _clauses;\n  _condition;\n  constructor(clauses, condition) {\n    this._clauses = clauses;\n    this._condition = condition;\n  }\n  then(value) {\n    const expr = value instanceof Expr ? value : new LiteralExpr(value);\n    return new ThenBuilder([...this._clauses, { condition: this._condition, value: expr }]);\n  }\n};\nfunction when(condition) {\n  return new WhenBuilder(condition);\n}\n\n// src/expr/string-expr.ts\nvar StringUnaryExpr = class extends Expr {\n  _inner;\n  _op;\n  constructor(inner, op) {\n    super();\n    this._inner = inner;\n    this._op = op;\n  }\n  get dependencies() {\n    return this._inner.dependencies;\n  }\n  toString() {\n    return `${this._inner.toString()}.str.${this._op}()`;\n  }\n  evaluate(df2) {\n    const series = this._inner.evaluate(df2);\n    const results = [];\n    for (let i = 0; i < series.length; i++) {\n      const val = series.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        switch (this._op) {\n          case \"toLowerCase\":\n            results.push(val.toLowerCase());\n            break;\n          case \"toUpperCase\":\n            results.push(val.toUpperCase());\n            break;\n          case \"trim\":\n            results.push(val.trim());\n            break;\n        }\n      }\n    }\n    return new Series(\"\", Utf8Column.from(results));\n  }\n};\nvar StringContainsExpr = class extends Expr {\n  _inner;\n  _pattern;\n  constructor(inner, pattern) {\n    super();\n    this._inner = inner;\n    this._pattern = pattern;\n  }\n  get dependencies() {\n    return this._inner.dependencies;\n  }\n  toString() {\n    return `${this._inner.toString()}.str.contains(\"${this._pattern}\")`;\n  }\n  evaluate(df2) {\n    const series = this._inner.evaluate(df2);\n    const results = [];\n    for (let i = 0; i < series.length; i++) {\n      const val = series.get(i);\n      results.push(val === null ? null : val.includes(this._pattern));\n    }\n    return new Series(\"\", BooleanColumn.from(results));\n  }\n};\nvar StringStartsWithExpr = class extends Expr {\n  _inner;\n  _prefix;\n  constructor(inner, prefix) {\n    super();\n    this._inner = inner;\n    this._prefix = prefix;\n  }\n  get dependencies() {\n    return this._inner.dependencies;\n  }\n  toString() {\n    return `${this._inner.toString()}.str.startsWith(\"${this._prefix}\")`;\n  }\n  evaluate(df2) {\n    const series = this._inner.evaluate(df2);\n    const results = [];\n    for (let i = 0; i < series.length; i++) {\n      const val = series.get(i);\n      results.push(val === null ? null : val.startsWith(this._prefix));\n    }\n    return new Series(\"\", BooleanColumn.from(results));\n  }\n};\nvar StringEndsWithExpr = class extends Expr {\n  _inner;\n  _suffix;\n  constructor(inner, suffix) {\n    super();\n    this._inner = inner;\n    this._suffix = suffix;\n  }\n  get dependencies() {\n    return this._inner.dependencies;\n  }\n  toString() {\n    return `${this._inner.toString()}.str.endsWith(\"${this._suffix}\")`;\n  }\n  evaluate(df2) {\n    const series = this._inner.evaluate(df2);\n    const results = [];\n    for (let i = 0; i < series.length; i++) {\n      const val = series.get(i);\n      results.push(val === null ? null : val.endsWith(this._suffix));\n    }\n    return new Series(\"\", BooleanColumn.from(results));\n  }\n};\nvar StringReplaceExpr = class extends Expr {\n  _inner;\n  _pattern;\n  _replacement;\n  constructor(inner, pattern, replacement) {\n    super();\n    this._inner = inner;\n    this._pattern = pattern;\n    this._replacement = replacement;\n  }\n  get dependencies() {\n    return this._inner.dependencies;\n  }\n  toString() {\n    return `${this._inner.toString()}.str.replace(\"${this._pattern}\", \"${this._replacement}\")`;\n  }\n  evaluate(df2) {\n    const series = this._inner.evaluate(df2);\n    const results = [];\n    for (let i = 0; i < series.length; i++) {\n      const val = series.get(i);\n      results.push(val === null ? null : val.replaceAll(this._pattern, this._replacement));\n    }\n    return new Series(\"\", Utf8Column.from(results));\n  }\n};\nvar StringSliceExpr = class extends Expr {\n  _inner;\n  _start;\n  _end;\n  constructor(inner, start, end) {\n    super();\n    this._inner = inner;\n    this._start = start;\n    this._end = end;\n  }\n  get dependencies() {\n    return this._inner.dependencies;\n  }\n  toString() {\n    return `${this._inner.toString()}.str.slice(${this._start}${this._end !== void 0 ? `, ${this._end}` : \"\"})`;\n  }\n  evaluate(df2) {\n    const series = this._inner.evaluate(df2);\n    const results = [];\n    for (let i = 0; i < series.length; i++) {\n      const val = series.get(i);\n      results.push(val === null ? null : val.slice(this._start, this._end));\n    }\n    return new Series(\"\", Utf8Column.from(results));\n  }\n};\nvar StringLengthExpr = class extends Expr {\n  _inner;\n  constructor(inner) {\n    super();\n    this._inner = inner;\n  }\n  get dependencies() {\n    return this._inner.dependencies;\n  }\n  toString() {\n    return `${this._inner.toString()}.str.length()`;\n  }\n  evaluate(df2) {\n    const series = this._inner.evaluate(df2);\n    const results = [];\n    for (let i = 0; i < series.length; i++) {\n      const val = series.get(i);\n      results.push(val === null ? null : val.length);\n    }\n    return new Series(\"\", Float64Column.from(results));\n  }\n};\nvar StringConcatExpr = class extends Expr {\n  _parts;\n  constructor(parts) {\n    super();\n    this._parts = parts;\n  }\n  get dependencies() {\n    const deps = /* @__PURE__ */ new Set();\n    for (const part of this._parts) {\n      if (part instanceof Expr) {\n        for (const d of part.dependencies) deps.add(d);\n      }\n    }\n    return [...deps];\n  }\n  toString() {\n    const parts = this._parts.map((p) => p instanceof Expr ? p.toString() : `\"${p}\"`);\n    return `concat(${parts.join(\", \")})`;\n  }\n  evaluate(df2) {\n    const len = df2.length;\n    const evaluatedParts = this._parts.map((part) => {\n      if (part instanceof Expr) return part.evaluate(df2);\n      return part;\n    });\n    const results = [];\n    for (let i = 0; i < len; i++) {\n      let hasNull = false;\n      let result = \"\";\n      for (const part of evaluatedParts) {\n        if (typeof part === \"string\") {\n          result += part;\n        } else {\n          const val = part.get(i);\n          if (val === null) {\n            hasNull = true;\n            break;\n          }\n          result += val;\n        }\n      }\n      results.push(hasNull ? null : result);\n    }\n    return new Series(\"\", Utf8Column.from(results));\n  }\n};\nvar StringExprAccessor = class {\n  _expr;\n  constructor(expr) {\n    this._expr = expr;\n  }\n  toLowerCase() {\n    return new StringUnaryExpr(this._expr, \"toLowerCase\");\n  }\n  toUpperCase() {\n    return new StringUnaryExpr(this._expr, \"toUpperCase\");\n  }\n  trim() {\n    return new StringUnaryExpr(this._expr, \"trim\");\n  }\n  contains(pattern) {\n    return new StringContainsExpr(this._expr, pattern);\n  }\n  startsWith(prefix) {\n    return new StringStartsWithExpr(this._expr, prefix);\n  }\n  endsWith(suffix) {\n    return new StringEndsWithExpr(this._expr, suffix);\n  }\n  replace(pattern, replacement) {\n    return new StringReplaceExpr(this._expr, pattern, replacement);\n  }\n  slice(start, end) {\n    return new StringSliceExpr(this._expr, start, end);\n  }\n  length() {\n    return new StringLengthExpr(this._expr);\n  }\n  concat(...parts) {\n    return new StringConcatExpr([this._expr, ...parts]);\n  }\n};\n\n// src/expr/date-expr.ts\nfunction extractDateComponent(date, op) {\n  switch (op) {\n    case \"year\":\n      return date.getFullYear();\n    case \"month\":\n      return date.getMonth() + 1;\n    case \"day\":\n      return date.getDate();\n    case \"hour\":\n      return date.getHours();\n    case \"minute\":\n      return date.getMinutes();\n    case \"second\":\n      return date.getSeconds();\n    case \"dayOfWeek\":\n      return date.getDay();\n    case \"dayOfYear\": {\n      const start = new Date(date.getFullYear(), 0, 0);\n      const diff = date.getTime() - start.getTime();\n      const oneDay = 1e3 * 60 * 60 * 24;\n      return Math.floor(diff / oneDay);\n    }\n    case \"weekNumber\": {\n      const target = new Date(date.getTime());\n      target.setHours(0, 0, 0, 0);\n      target.setDate(target.getDate() + 3 - (target.getDay() + 6) % 7);\n      const jan4 = new Date(target.getFullYear(), 0, 4);\n      const dayDiff = (target.getTime() - jan4.getTime()) / (1e3 * 60 * 60 * 24);\n      return 1 + Math.round((dayDiff - 3 + (jan4.getDay() + 6) % 7) / 7);\n    }\n    case \"quarter\":\n      return Math.floor(date.getMonth() / 3) + 1;\n    case \"timestamp\":\n      return date.getTime();\n  }\n}\nvar DateComponentExpr = class extends Expr {\n  _inner;\n  _op;\n  constructor(inner, op) {\n    super();\n    this._inner = inner;\n    this._op = op;\n  }\n  get dependencies() {\n    return this._inner.dependencies;\n  }\n  toString() {\n    return `${this._inner.toString()}.dt.${this._op}()`;\n  }\n  evaluate(df2) {\n    const series = this._inner.evaluate(df2);\n    const results = [];\n    for (let i = 0; i < series.length; i++) {\n      const val = series.get(i);\n      results.push(val === null ? null : extractDateComponent(val, this._op));\n    }\n    return new Series(\"\", Float64Column.from(results));\n  }\n};\nvar DateTruncateExpr = class extends Expr {\n  _inner;\n  _unit;\n  constructor(inner, unit) {\n    super();\n    this._inner = inner;\n    this._unit = unit;\n  }\n  get dependencies() {\n    return this._inner.dependencies;\n  }\n  toString() {\n    return `${this._inner.toString()}.dt.truncate(\"${this._unit}\")`;\n  }\n  evaluate(df2) {\n    const series = this._inner.evaluate(df2);\n    const results = [];\n    for (let i = 0; i < series.length; i++) {\n      const val = series.get(i);\n      if (val === null) {\n        results.push(null);\n      } else {\n        results.push(truncateDate2(val, this._unit));\n      }\n    }\n    return new Series(\"\", DateColumn.from(results));\n  }\n};\nvar DateDiffExpr = class extends Expr {\n  _left;\n  _right;\n  _unit;\n  constructor(left, right, unit) {\n    super();\n    this._left = left;\n    this._right = right;\n    this._unit = unit;\n  }\n  get dependencies() {\n    return [.../* @__PURE__ */ new Set([...this._left.dependencies, ...this._right.dependencies])];\n  }\n  toString() {\n    return `dateDiff(${this._left.toString()}, ${this._right.toString()}, \"${this._unit}\")`;\n  }\n  evaluate(df2) {\n    const leftSeries = this._left.evaluate(df2);\n    const rightSeries = this._right.evaluate(df2);\n    const len = leftSeries.length;\n    const results = [];\n    for (let i = 0; i < len; i++) {\n      const a = leftSeries.get(i);\n      const b = rightSeries.get(i);\n      if (a === null || b === null) {\n        results.push(null);\n      } else {\n        const diffMs = a.getTime() - b.getTime();\n        results.push(convertMsToDiffUnit(diffMs, this._unit));\n      }\n    }\n    return new Series(\"\", Float64Column.from(results));\n  }\n};\nfunction convertMsToDiffUnit(ms, unit) {\n  switch (unit) {\n    case \"milliseconds\":\n      return ms;\n    case \"seconds\":\n      return ms / 1e3;\n    case \"minutes\":\n      return ms / (1e3 * 60);\n    case \"hours\":\n      return ms / (1e3 * 60 * 60);\n    case \"days\":\n      return ms / (1e3 * 60 * 60 * 24);\n  }\n}\nfunction truncateDate2(date, unit) {\n  switch (unit) {\n    case \"year\":\n      return new Date(date.getFullYear(), 0, 1);\n    case \"month\":\n      return new Date(date.getFullYear(), date.getMonth(), 1);\n    case \"day\":\n      return new Date(date.getFullYear(), date.getMonth(), date.getDate());\n    case \"hour\":\n      return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours());\n    case \"minute\":\n      return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes());\n    case \"second\":\n      return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds());\n  }\n}\nvar DateExprAccessor = class {\n  _expr;\n  constructor(expr) {\n    this._expr = expr;\n  }\n  year() {\n    return new DateComponentExpr(this._expr, \"year\");\n  }\n  month() {\n    return new DateComponentExpr(this._expr, \"month\");\n  }\n  day() {\n    return new DateComponentExpr(this._expr, \"day\");\n  }\n  hour() {\n    return new DateComponentExpr(this._expr, \"hour\");\n  }\n  minute() {\n    return new DateComponentExpr(this._expr, \"minute\");\n  }\n  second() {\n    return new DateComponentExpr(this._expr, \"second\");\n  }\n  dayOfWeek() {\n    return new DateComponentExpr(this._expr, \"dayOfWeek\");\n  }\n  dayOfYear() {\n    return new DateComponentExpr(this._expr, \"dayOfYear\");\n  }\n  weekNumber() {\n    return new DateComponentExpr(this._expr, \"weekNumber\");\n  }\n  quarter() {\n    return new DateComponentExpr(this._expr, \"quarter\");\n  }\n  timestamp() {\n    return new DateComponentExpr(this._expr, \"timestamp\");\n  }\n  truncate(unit) {\n    return new DateTruncateExpr(this._expr, unit);\n  }\n  diff(other, unit = \"days\") {\n    return new DateDiffExpr(this._expr, other, unit);\n  }\n};\n\n// src/ops/window.ts\nvar WindowRankingExpr = class extends Expr {\n  _source;\n  _descending;\n  constructor(source, descending = false) {\n    super();\n    this._source = source;\n    this._descending = descending;\n  }\n  get dependencies() {\n    return this._source.dependencies;\n  }\n  _sortCompare(a, b) {\n    return this._descending ? -compareValues(a, b) : compareValues(a, b);\n  }\n};\nvar WindowRankExpr = class _WindowRankExpr extends WindowRankingExpr {\n  toString() {\n    return `rank(${this._source.toString()})`;\n  }\n  withDescending(desc) {\n    return new _WindowRankExpr(this._source, desc);\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const indexed = [];\n    for (let i = 0; i < len; i++) {\n      indexed.push({ value: series.get(i), idx: i });\n    }\n    indexed.sort((a, b) => this._sortCompare(a.value, b.value));\n    const ranks = new Array(len);\n    let rank = 1;\n    for (let i = 0; i < indexed.length; i++) {\n      if (i > 0 && compareValues(indexed[i].value, indexed[i - 1].value) !== 0) {\n        rank = i + 1;\n      }\n      ranks[indexed[i].idx] = rank;\n    }\n    return new Series(\"rank\", Float64Column.from(ranks));\n  }\n};\nvar WindowDenseRankExpr = class _WindowDenseRankExpr extends WindowRankingExpr {\n  toString() {\n    return `dense_rank(${this._source.toString()})`;\n  }\n  withDescending(desc) {\n    return new _WindowDenseRankExpr(this._source, desc);\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const indexed = [];\n    for (let i = 0; i < len; i++) {\n      indexed.push({ value: series.get(i), idx: i });\n    }\n    indexed.sort((a, b) => this._sortCompare(a.value, b.value));\n    const ranks = new Array(len);\n    let rank = 1;\n    for (let i = 0; i < indexed.length; i++) {\n      if (i > 0 && compareValues(indexed[i].value, indexed[i - 1].value) !== 0) {\n        rank++;\n      }\n      ranks[indexed[i].idx] = rank;\n    }\n    return new Series(\"dense_rank\", Float64Column.from(ranks));\n  }\n};\nvar WindowRowNumberExpr = class _WindowRowNumberExpr extends WindowRankingExpr {\n  toString() {\n    return `row_number(${this._source.toString()})`;\n  }\n  withDescending(desc) {\n    return new _WindowRowNumberExpr(this._source, desc);\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const values = new Array(len);\n    for (let i = 0; i < len; i++) values[i] = series.get(i);\n    const indexed = Array.from({ length: len }, (_, i) => i);\n    indexed.sort((a, b) => this._sortCompare(values[a], values[b]));\n    const ranks = new Array(len);\n    for (let i = 0; i < indexed.length; i++) {\n      ranks[indexed[i]] = i + 1;\n    }\n    return new Series(\"row_number\", Float64Column.from(ranks));\n  }\n};\nvar WindowPercentRankExpr = class _WindowPercentRankExpr extends WindowRankingExpr {\n  toString() {\n    return `percent_rank(${this._source.toString()})`;\n  }\n  withDescending(desc) {\n    return new _WindowPercentRankExpr(this._source, desc);\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    if (len <= 1) {\n      const results = new Array(len).fill(0);\n      return new Series(\"percent_rank\", Float64Column.from(results));\n    }\n    const indexed = [];\n    for (let i = 0; i < len; i++) {\n      indexed.push({ value: series.get(i), idx: i });\n    }\n    indexed.sort((a, b) => this._sortCompare(a.value, b.value));\n    const ranks = new Array(len);\n    let rank = 1;\n    for (let i = 0; i < indexed.length; i++) {\n      if (i > 0 && compareValues(indexed[i].value, indexed[i - 1].value) !== 0) {\n        rank = i + 1;\n      }\n      ranks[indexed[i].idx] = (rank - 1) / (len - 1);\n    }\n    return new Series(\"percent_rank\", Float64Column.from(ranks));\n  }\n};\nvar WindowNtileExpr = class _WindowNtileExpr extends WindowRankingExpr {\n  _n;\n  constructor(source, n, descending = false) {\n    super(source, descending);\n    this._n = n;\n  }\n  toString() {\n    return `ntile(${this._source.toString()}, ${this._n})`;\n  }\n  withDescending(desc) {\n    return new _WindowNtileExpr(this._source, this._n, desc);\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const indexed = [];\n    for (let i = 0; i < len; i++) {\n      indexed.push({ value: series.get(i), idx: i });\n    }\n    indexed.sort((a, b) => this._sortCompare(a.value, b.value));\n    const results = new Array(len);\n    for (let i = 0; i < indexed.length; i++) {\n      results[indexed[i].idx] = Math.floor(i * this._n / len) + 1;\n    }\n    return new Series(\"ntile\", Float64Column.from(results));\n  }\n};\nfunction compareValues(a, b) {\n  if (a === null && b === null) return 0;\n  if (a === null) return 1;\n  if (b === null) return -1;\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return a - b;\n  }\n  if (typeof a === \"string\" && typeof b === \"string\") {\n    return a < b ? -1 : a > b ? 1 : 0;\n  }\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() - b.getTime();\n  }\n  const sa = typeof a === \"string\" ? a : typeof a === \"number\" ? `${a}` : typeof a === \"boolean\" ? `${a}` : \"object\";\n  const sb = typeof b === \"string\" ? b : typeof b === \"number\" ? `${b}` : typeof b === \"boolean\" ? `${b}` : \"object\";\n  return sa < sb ? -1 : sa > sb ? 1 : 0;\n}\nvar CumulativeExpr = class extends Expr {\n  _source;\n  constructor(source) {\n    super();\n    this._source = source;\n  }\n  get dependencies() {\n    return this._source.dependencies;\n  }\n};\nvar CumSumExpr = class extends CumulativeExpr {\n  toString() {\n    return `cumSum(${this._source.toString()})`;\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const results = new Array(len);\n    let sum = 0;\n    for (let i = 0; i < len; i++) {\n      const v = series.get(i);\n      if (v !== null && typeof v === \"number\") {\n        sum += v;\n      }\n      results[i] = sum;\n    }\n    return new Series(\"cumSum\", Float64Column.from(results));\n  }\n};\nvar CumMaxExpr = class extends CumulativeExpr {\n  toString() {\n    return `cumMax(${this._source.toString()})`;\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const results = new Array(len);\n    let max = null;\n    for (let i = 0; i < len; i++) {\n      const v = series.get(i);\n      if (v !== null && typeof v === \"number\") {\n        max = max === null ? v : Math.max(max, v);\n      }\n      results[i] = max;\n    }\n    return new Series(\"cumMax\", Float64Column.from(results));\n  }\n};\nvar CumMinExpr = class extends CumulativeExpr {\n  toString() {\n    return `cumMin(${this._source.toString()})`;\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const results = new Array(len);\n    let min = null;\n    for (let i = 0; i < len; i++) {\n      const v = series.get(i);\n      if (v !== null && typeof v === \"number\") {\n        min = min === null ? v : Math.min(min, v);\n      }\n      results[i] = min;\n    }\n    return new Series(\"cumMin\", Float64Column.from(results));\n  }\n};\nvar CumProdExpr = class extends CumulativeExpr {\n  toString() {\n    return `cumProd(${this._source.toString()})`;\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const results = new Array(len);\n    let prod = 1;\n    for (let i = 0; i < len; i++) {\n      const v = series.get(i);\n      if (v !== null && typeof v === \"number\") {\n        prod *= v;\n      }\n      results[i] = prod;\n    }\n    return new Series(\"cumProd\", Float64Column.from(results));\n  }\n};\nvar CumCountExpr = class extends CumulativeExpr {\n  toString() {\n    return `cumCount(${this._source.toString()})`;\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const results = new Array(len);\n    let count = 0;\n    for (let i = 0; i < len; i++) {\n      const v = series.get(i);\n      if (v !== null) {\n        count++;\n      }\n      results[i] = count;\n    }\n    return new Series(\"cumCount\", Float64Column.from(results));\n  }\n};\nvar OffsetExpr = class extends Expr {\n  _source;\n  _offset;\n  constructor(source, offset) {\n    super();\n    this._source = source;\n    this._offset = offset;\n  }\n  get dependencies() {\n    return this._source.dependencies;\n  }\n};\nvar ShiftExpr = class extends OffsetExpr {\n  toString() {\n    return `shift(${this._source.toString()}, ${this._offset})`;\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const results = new Array(len);\n    for (let i = 0; i < len; i++) {\n      const srcIdx = i - this._offset;\n      if (srcIdx < 0 || srcIdx >= len) {\n        results[i] = null;\n      } else {\n        const v = series.get(srcIdx);\n        results[i] = v !== null && typeof v === \"number\" ? v : null;\n      }\n    }\n    return new Series(\"shift\", Float64Column.from(results));\n  }\n};\nvar DiffExpr = class extends OffsetExpr {\n  toString() {\n    return `diff(${this._source.toString()}, ${this._offset})`;\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const results = new Array(len);\n    for (let i = 0; i < len; i++) {\n      const prevIdx = i - this._offset;\n      if (prevIdx < 0 || prevIdx >= len) {\n        results[i] = null;\n      } else {\n        const curr = series.get(i);\n        const prev = series.get(prevIdx);\n        if (curr !== null && typeof curr === \"number\" && prev !== null && typeof prev === \"number\") {\n          results[i] = curr - prev;\n        } else {\n          results[i] = null;\n        }\n      }\n    }\n    return new Series(\"diff\", Float64Column.from(results));\n  }\n};\nvar PctChangeExpr = class extends OffsetExpr {\n  toString() {\n    return `pctChange(${this._source.toString()}, ${this._offset})`;\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const results = new Array(len);\n    for (let i = 0; i < len; i++) {\n      const prevIdx = i - this._offset;\n      if (prevIdx < 0 || prevIdx >= len) {\n        results[i] = null;\n      } else {\n        const curr = series.get(i);\n        const prev = series.get(prevIdx);\n        if (curr !== null && typeof curr === \"number\" && prev !== null && typeof prev === \"number\" && prev !== 0) {\n          results[i] = (curr - prev) / prev;\n        } else {\n          results[i] = null;\n        }\n      }\n    }\n    return new Series(\"pctChange\", Float64Column.from(results));\n  }\n};\nvar RollingExpr = class extends Expr {\n  _source;\n  _windowSize;\n  constructor(source, windowSize) {\n    super();\n    this._source = source;\n    this._windowSize = windowSize;\n  }\n  get dependencies() {\n    return this._source.dependencies;\n  }\n  _getNumericValues(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const values = [];\n    for (let i = 0; i < len; i++) {\n      const v = series.get(i);\n      values.push(v !== null && typeof v === \"number\" ? v : null);\n    }\n    return values;\n  }\n};\nvar RollingMeanExpr = class extends RollingExpr {\n  toString() {\n    return `rollingMean(${this._source.toString()}, ${this._windowSize})`;\n  }\n  evaluate(df2) {\n    const values = this._getNumericValues(df2);\n    const len = values.length;\n    const results = new Array(len);\n    for (let i = 0; i < len; i++) {\n      if (i < this._windowSize - 1) {\n        results[i] = null;\n      } else {\n        let sum = 0;\n        let count = 0;\n        for (let j = i - this._windowSize + 1; j <= i; j++) {\n          const v = values[j];\n          if (v !== null) {\n            sum += v;\n            count++;\n          }\n        }\n        results[i] = count > 0 ? sum / count : null;\n      }\n    }\n    return new Series(\"rollingMean\", Float64Column.from(results));\n  }\n};\nvar RollingSumExpr = class extends RollingExpr {\n  toString() {\n    return `rollingSum(${this._source.toString()}, ${this._windowSize})`;\n  }\n  evaluate(df2) {\n    const values = this._getNumericValues(df2);\n    const len = values.length;\n    const results = new Array(len);\n    for (let i = 0; i < len; i++) {\n      if (i < this._windowSize - 1) {\n        results[i] = null;\n      } else {\n        let sum = 0;\n        for (let j = i - this._windowSize + 1; j <= i; j++) {\n          const v = values[j];\n          if (v !== null) {\n            sum += v;\n          }\n        }\n        results[i] = sum;\n      }\n    }\n    return new Series(\"rollingSum\", Float64Column.from(results));\n  }\n};\nvar RollingStdExpr = class extends RollingExpr {\n  toString() {\n    return `rollingStd(${this._source.toString()}, ${this._windowSize})`;\n  }\n  evaluate(df2) {\n    const values = this._getNumericValues(df2);\n    const len = values.length;\n    const results = new Array(len);\n    for (let i = 0; i < len; i++) {\n      if (i < this._windowSize - 1) {\n        results[i] = null;\n      } else {\n        const windowVals = [];\n        for (let j = i - this._windowSize + 1; j <= i; j++) {\n          const v = values[j];\n          if (v !== null) {\n            windowVals.push(v);\n          }\n        }\n        if (windowVals.length < 2) {\n          results[i] = null;\n        } else {\n          let sum = 0;\n          for (const v of windowVals) sum += v;\n          const mean = sum / windowVals.length;\n          let sqDiffSum = 0;\n          for (const v of windowVals) sqDiffSum += (v - mean) * (v - mean);\n          results[i] = Math.sqrt(sqDiffSum / (windowVals.length - 1));\n        }\n      }\n    }\n    return new Series(\"rollingStd\", Float64Column.from(results));\n  }\n};\nvar RollingMinExpr = class extends RollingExpr {\n  toString() {\n    return `rollingMin(${this._source.toString()}, ${this._windowSize})`;\n  }\n  evaluate(df2) {\n    const values = this._getNumericValues(df2);\n    const len = values.length;\n    const results = new Array(len);\n    for (let i = 0; i < len; i++) {\n      if (i < this._windowSize - 1) {\n        results[i] = null;\n      } else {\n        let min = null;\n        for (let j = i - this._windowSize + 1; j <= i; j++) {\n          const v = values[j];\n          if (v !== null) {\n            min = min === null ? v : Math.min(min, v);\n          }\n        }\n        results[i] = min;\n      }\n    }\n    return new Series(\"rollingMin\", Float64Column.from(results));\n  }\n};\nvar RollingMaxExpr = class extends RollingExpr {\n  toString() {\n    return `rollingMax(${this._source.toString()}, ${this._windowSize})`;\n  }\n  evaluate(df2) {\n    const values = this._getNumericValues(df2);\n    const len = values.length;\n    const results = new Array(len);\n    for (let i = 0; i < len; i++) {\n      if (i < this._windowSize - 1) {\n        results[i] = null;\n      } else {\n        let max = null;\n        for (let j = i - this._windowSize + 1; j <= i; j++) {\n          const v = values[j];\n          if (v !== null) {\n            max = max === null ? v : Math.max(max, v);\n          }\n        }\n        results[i] = max;\n      }\n    }\n    return new Series(\"rollingMax\", Float64Column.from(results));\n  }\n};\nvar EwmExpr = class extends Expr {\n  _source;\n  _alpha;\n  constructor(source, alpha) {\n    super();\n    this._source = source;\n    this._alpha = alpha;\n  }\n  get dependencies() {\n    return this._source.dependencies;\n  }\n  toString() {\n    return `ewm(${this._source.toString()}, ${this._alpha})`;\n  }\n  evaluate(df2) {\n    const series = this._source.evaluate(df2);\n    const len = series.length;\n    const results = new Array(len);\n    let ewma = null;\n    for (let i = 0; i < len; i++) {\n      const v = series.get(i);\n      if (v !== null && typeof v === \"number\") {\n        if (ewma === null) {\n          ewma = v;\n        } else {\n          ewma = this._alpha * v + (1 - this._alpha) * ewma;\n        }\n        results[i] = ewma;\n      } else {\n        results[i] = ewma;\n      }\n    }\n    return new Series(\"ewm\", Float64Column.from(results));\n  }\n};\nvar PartitionedWindowExpr = class extends Expr {\n  _inner;\n  _partitionCols;\n  constructor(inner, partitionCols) {\n    super();\n    this._inner = inner;\n    this._partitionCols = partitionCols;\n  }\n  get dependencies() {\n    return [.../* @__PURE__ */ new Set([...this._inner.dependencies, ...this._partitionCols])];\n  }\n  toString() {\n    return `${this._inner.toString()}.over(${this._partitionCols.join(\", \")})`;\n  }\n  evaluate(df2) {\n    const len = df2.length;\n    const results = new Array(len);\n    const partitionMap = /* @__PURE__ */ new Map();\n    const partCols = this._partitionCols.map((name) => df2.col(name).column);\n    for (let i = 0; i < len; i++) {\n      const key = serializeKey4(partCols, i);\n      const group = partitionMap.get(key);\n      if (group) {\n        group.push(i);\n      } else {\n        partitionMap.set(key, [i]);\n      }\n    }\n    const columnOrder = df2.columns;\n    for (const indices of partitionMap.values()) {\n      const int32Indices = new Int32Array(indices);\n      const newColumns = /* @__PURE__ */ new Map();\n      for (const name of columnOrder) {\n        newColumns.set(name, df2.col(name).column.take(int32Indices));\n      }\n      const subDf = new DataFrame(newColumns, columnOrder);\n      const subResult = this._inner.evaluate(subDf);\n      for (let i = 0; i < indices.length; i++) {\n        results[indices[i]] = subResult.get(i);\n      }\n    }\n    return new Series(\"over\", Float64Column.from(results));\n  }\n};\nfunction serializeKey4(columns, index) {\n  const parts = [];\n  for (const column of columns) {\n    const v = column.get(index);\n    if (v === null) {\n      parts.push(\"\\0null\");\n    } else if (v instanceof Date) {\n      parts.push(`\\0d${v.getTime()}`);\n    } else if (typeof v === \"number\" || typeof v === \"string\" || typeof v === \"boolean\") {\n      parts.push(`\\0${typeof v}${String(v)}`);\n    } else {\n      parts.push(`\\0obj${JSON.stringify(v)}`);\n    }\n  }\n  return parts.join(\"\u0001\");\n}\nvar OrderedWindowExpr = class extends Expr {\n  _inner;\n  _orderCol;\n  _direction;\n  constructor(inner, orderCol, direction = \"asc\") {\n    super();\n    this._inner = inner;\n    this._orderCol = orderCol;\n    this._direction = direction;\n  }\n  get dependencies() {\n    return [.../* @__PURE__ */ new Set([...this._inner.dependencies, this._orderCol])];\n  }\n  toString() {\n    return `${this._inner.toString()}.orderBy(${this._orderCol}, ${this._direction})`;\n  }\n  evaluate(df2) {\n    const len = df2.length;\n    const descending = this._direction === \"desc\";\n    const directedInner = applyRankingDirection(this._inner, descending);\n    const orderCol = df2.col(this._orderCol).column;\n    const indices = [];\n    for (let i = 0; i < len; i++) indices.push(i);\n    const dir = descending ? -1 : 1;\n    indices.sort((a, b) => dir * compareValues(orderCol.get(a), orderCol.get(b)));\n    const int32Indices = new Int32Array(indices);\n    const columnOrder = df2.columns;\n    const newColumns = /* @__PURE__ */ new Map();\n    for (const name of columnOrder) {\n      newColumns.set(name, df2.col(name).column.take(int32Indices));\n    }\n    const sortedDf = new DataFrame(newColumns, columnOrder);\n    const sortedResult = directedInner.evaluate(sortedDf);\n    const results = new Array(len);\n    for (let i = 0; i < len; i++) {\n      results[indices[i]] = sortedResult.get(i);\n    }\n    return new Series(\"orderBy\", Float64Column.from(results));\n  }\n};\nfunction applyRankingDirection(expr, descending) {\n  if (expr instanceof WindowRankingExpr) {\n    return expr.withDescending(descending);\n  }\n  if (expr instanceof PartitionedWindowExpr) {\n    const directedInner = applyRankingDirection(expr._inner, descending);\n    return new PartitionedWindowExpr(directedInner, expr[\"_partitionCols\"]);\n  }\n  return expr;\n}\nExpr.prototype.rank = function() {\n  return new WindowRankExpr(this);\n};\nExpr.prototype.denseRank = function() {\n  return new WindowDenseRankExpr(this);\n};\nExpr.prototype.rowNumber = function() {\n  return new WindowRowNumberExpr(this);\n};\nExpr.prototype.percentRank = function() {\n  return new WindowPercentRankExpr(this);\n};\nExpr.prototype.ntile = function(n) {\n  return new WindowNtileExpr(this, n);\n};\nExpr.prototype.cumSum = function() {\n  return new CumSumExpr(this);\n};\nExpr.prototype.cumMax = function() {\n  return new CumMaxExpr(this);\n};\nExpr.prototype.cumMin = function() {\n  return new CumMinExpr(this);\n};\nExpr.prototype.cumProd = function() {\n  return new CumProdExpr(this);\n};\nExpr.prototype.cumCount = function() {\n  return new CumCountExpr(this);\n};\nExpr.prototype.shift = function(offset) {\n  return new ShiftExpr(this, offset);\n};\nExpr.prototype.diff = function(offset = 1) {\n  return new DiffExpr(this, offset);\n};\nExpr.prototype.pctChange = function(offset = 1) {\n  return new PctChangeExpr(this, offset);\n};\nExpr.prototype.rollingMean = function(windowSize) {\n  return new RollingMeanExpr(this, windowSize);\n};\nExpr.prototype.rollingSum = function(windowSize) {\n  return new RollingSumExpr(this, windowSize);\n};\nExpr.prototype.rollingStd = function(windowSize) {\n  return new RollingStdExpr(this, windowSize);\n};\nExpr.prototype.rollingMin = function(windowSize) {\n  return new RollingMinExpr(this, windowSize);\n};\nExpr.prototype.rollingMax = function(windowSize) {\n  return new RollingMaxExpr(this, windowSize);\n};\nExpr.prototype.ewm = function(alpha) {\n  return new EwmExpr(this, alpha);\n};\nExpr.prototype.over = function(...partitionCols) {\n  return new PartitionedWindowExpr(this, partitionCols);\n};\nExpr.prototype.orderBy = function(column, direction = \"asc\") {\n  return new OrderedWindowExpr(this, column, direction);\n};\n\n// src/browser.ts\nfunction df(rows) {\n  return DataFrame.fromRows(rows);\n}\nexport {\n  AggExpr,\n  BitArray,\n  BooleanColumn,\n  Column,\n  ColumnNotFoundError,\n  CountAggExpr,\n  CountDistinctAggExpr,\n  CumCountExpr,\n  CumMaxExpr,\n  CumMinExpr,\n  CumProdExpr,\n  CumSumExpr,\n  DType,\n  DataFrame,\n  DateAccessor,\n  DateColumn,\n  DateExprAccessor,\n  DiffExpr,\n  ErrorCode,\n  Expr,\n  FirstAggExpr,\n  Float64Column,\n  FrameKitError,\n  GroupBy,\n  IOError,\n  Int32Column,\n  LastAggExpr,\n  LazyFrame,\n  LazyGroupBy,\n  ListAggExpr,\n  MaxAggExpr,\n  MeanAggExpr,\n  MinAggExpr,\n  ModeAggExpr,\n  NamedExpr,\n  ObjectColumn,\n  OrderedWindowExpr,\n  ParseError,\n  PartitionedWindowExpr,\n  PctChangeExpr,\n  Series,\n  ShapeMismatchError,\n  ShiftExpr,\n  StdAggExpr,\n  StringAccessor,\n  StringExprAccessor,\n  SumAggExpr,\n  ThenBuilder,\n  TypeMismatchError,\n  Utf8Column,\n  WhenBuilder,\n  WindowDenseRankExpr,\n  WindowNtileExpr,\n  WindowPercentRankExpr,\n  WindowRankExpr,\n  WindowRowNumberExpr,\n  col,\n  df,\n  execute,\n  lit,\n  optimize,\n  when\n};\n//# sourceMappingURL=browser.js.map"],"names":["cpus","count","platform","arch","tmpdir","EOL","os","DType","DType2","ErrorCode","ErrorCode2","FrameKitError","code","message","ColumnNotFoundError","column","available","TypeMismatchError","ShapeMismatchError","ParseError","IOError","BitArray","_BitArray","length","initialValue","byteCount","index","byteIndex","bitIndex","value","i","other","result","Column","nullMask","Float64Column","_Float64Column","data","start","end","sliced","mask","indices","idx","total","validCount","val","values","hasNull","v","Int32Column","_Int32Column","Utf8Column","_Utf8Column","interned","len","slicedIndices","newIndices","bytes","s","uniqueSet","nonNullCount","dictionary","dictMap","d","BooleanColumn","_BooleanColumn","DateColumn","_DateColumn","ObjectColumn","_ObjectColumn","StringAccessor","series","prefix","suffix","pattern","replacement","separator","col2","ListColumn","Series","results","fillChar","source","match","fn","_ListColumn","arr","idxArray","DateAccessor","diff","oneDay","target","jan4","dayDiff","formatDate","unit","a","b","dateDiff","truncateDate","date","pad2","n","pad4","msA","diffMs","yearDiff","monthDiff","dayFrac","monthFrac","_createDataFrame","_registerDataFrameFactory","factory","_Series","name","m","sumSqDiff","mid","low","high","running","decimals","factor","set","filled","seen","key","counts","order","entry","countValues","valueCol","countCol","columns","dtype","converted","buildColumnFromDType","resultDType","r","predicate","targetDType","Expr","_Expr","NamedExpr","ArithmeticExpr","wrapNum","ComparisonExpr","wrap","LogicalExpr","wrapBool","NotExpr","deps","SumAggExpr","MeanAggExpr","CountAggExpr","CountDistinctAggExpr","MinAggExpr","MaxAggExpr","StdAggExpr","FirstAggExpr","LastAggExpr","ListAggExpr","ModeAggExpr","others","exprs","o","LiteralExpr","CoalesceExpr","valExpr","FillNullExpr","IsNullExpr","IsNotNullExpr","expr","buildColumnForValues","detectLiteralDType","df2","ColumnExpr","ARITH_OP_SYMBOLS","left","right","op","leftSeries","rightSeries","applyArithOp","CMP_OP_SYMBOLS","columnName","literal","len2","results2","applyCmpOp","inner","innerSeries","col","lit","toComparableKey","AggExpr","mean","acc","best","bestCount","e","evaluated","found","fill","fillSeries","DEFAULT_NULL_VALUES","parseCSV","content","options","lines","splitLines","delimiter","detectDelimiter","hasHeader","nullValues","allRows","line","parseLine","dataStart","header","rowStart","h","firstRow","rowEnd","selectedColumns","activeHeader","headerIndexMap","row","colIdx","colName","raw","inferredTypes","inferColumnTypes","comment","current","inQuotes","ch","fields","candidates","bestDelimiter","bestScore","delim","avg","score","c","types","parseNumbers","parseDates","sample","isNumericString","isIntegerString","isBooleanString","isDateString","lower","ISO_DATE_RE","writeCSV","rows","quoteStyle","nullValue","includeHeader","bom","quoteField","DEFAULT_NULL_VALUES2","streamCSVFile","filePath","chunkSize","fs","createReadStream","stream","err","skipRows","schema","buffer","pendingLines","linesSkipped","headerConsumed","chunkRows","rowCount","totalRowsEmitted","nRows","parseLine2","quoted","detectDelimiter2","q","inferTypes","opts","isNumericString2","isIntegerString2","isBooleanString2","isDateString2","initChunkRows","cols","addRowToChunk","schema2","parsedHeader","detectedDelimiter","processLine","_","tempCols","pl","fields2","rawChunk","lineStart","finalSchema","remaining","ISO_DATE_RE2","streamNDJSONFile","chunk","totalEmitted","writeJSON","objects","obj","writeNDJSON","detectCellDType","parseCellRef","ref","colStr","rowNum","colNum","parseRange","range","parts","getWorksheet","workbook","sheet","ws2","ws","normalizeCellValue","parseExcelWorksheet","worksheet","rangeDef","startRow","endRow","startCol","endCol","rawRows","rowValues","cell","dataStartIdx","colCount","j","colValues","detected","readExcelFile","ExcelJS","arrowTypeToDType","field","extractColumnValues","readParquetFile","parquetWasm","uint8","arrowTable","numFields","numRows","allFields","selectedFields","f","arrowCol","parseCellRef2","columnNumberToLetter","remainder","writeExcelFile","sheetName","startCell","cellRef","lastColLetter","lastRow","freezeRow","freezeCol","width","dtypeToArrowType","arrow","coerceValues","resolveCompression","compression","Compression","writeParquetFile","arrowColumns","arrowType","coerced","ipcBytes","wasmTable","resolvedCompression","builder","writerProperties","parquetBytes","dtypeToArrowType2","coerceValue","toArrowTable","input","columnOrder","getColumnValues","tableData","arrowTypeToDType2","typeId","typeStr","fromArrowTable","table","WORKER_CODE","DEFAULT_THRESHOLD","defaultWorkerCount","workerThreadsAvailable","isWorkerThreadsAvailableSync","shouldUseParallel","threshold","serializeColumn","maskBytes","partitionGroups","groupEntries","workerCount","partitions","parallelAgg","keyColumnNames","keyColumns","aggSpecs","sourceColumns","wt","Worker","neededColumns","keyName","spec","serializedColumns","workerPromises","partition","resolve","reject","worker","allResults","workerResult","GroupBy","keys","k","keyStr","group","specs","resolvedSpecs","aggExpr","aggType","keyCols","nGroups","resultColumns","ki","vals","aggNames","Ctor","keyValues","aggValues","onlyAggName","onlyAgg","sourceCol","firstIndex","sum","hasValue","ii","resultColumns2","columnOrder2","Ctor2","int32Indices","subColumns","sourceName","subFrame","method","colExpr","_length","nonKeyColumns","newColumns","serializeKey","normalizeSingleKey","buildColumnFromValues","resolveKeys","on","leftKeys","rightKeys","crossJoin","resultLength","rightColRenames","rc","srcCol","li","ri","outputName","semiAntiJoin","anti","rightKeyCols","leftKeyCols","rightKeySet","rightKeyCol","matchedIndices","leftKeyCol","hasMatch","hashJoin","how","rightIndexByKey","rightKeyUnique","rightNonKeyCols2","rightColRenames2","hashTable","bucket","leftIndices","rightIndices","rightMatched","matches","mi","rightNonKeyCols","leftNonKeyCols","leftKey","rightKey","leftCol","rightCol","serializeKey2","buildColumnFromValues2","lookup","valueCols","lookupMap","spread","limit","nameFn","drop","isObject","maxArrayLen","objectKeys","effectiveKeys","outName","unroll","nonUnrollCols","rowCounts","maxLen","totalRows","resultData","indexData","outIdx","rowKey","cartesian","out","next","item","impute","expandKeys","sourceRows","workingRows","keyDomains","normalized","combos","existing","combo","comboRow","existingRow","generated","columnData","resolvedValues","resultRows","fillValue","aggregate","aggFunc","serializeKey3","indexCols","buildColumnFromValues3","pivot","columnsCol","valuesCol","indexKeyOrder","indexKeyToRowIndices","pivotColValues","pivotColSet","pivotColumnSeries","str","cellData","indexKey","pivotVal","pivotStr","cellKey","valuesDtype","resultDtype","idxCol","cellValues","buildColumnFromValues4","detectDType","melt","idVars","varName","valueName","valueVars","idSet","nValueVars","idCol","sourceSeries","varValues","valueValues","valueDtype","detectDType2","buildColumnFromValues5","serializeValue","transpose","headerColumn","newHeaders","headerSeries","rowIdx","concat","frames","first","allColumns","columnSet","frame","dtypeMap","dtypes","offset","frameLen","serializeRow","validateMatchingSchemas","leftCols","rightCols","leftDtypes","rightDtypes","buildColumnFromValues6","collectRows","union","valueArrays","intersection","difference","escapeIdentifier","escapeSQLValue","writeSQL","tableName","batchSize","columnList","statements","valueRows","nextNodeId","createScanNode","explainPlan","node","indent","pad","exprStrs","aggStrs","execute","plan","run","gb","agg","optimize","optimized","pushDown","merged","mergeFilters","pushProjectionDown","filter","pushFilterDown","child","needed","projection","childNeeded","dep","onCols","leftNeeded","rightNeeded","LazyGroupBy","LazyFrame","_LazyFrame","by","descending","subset","original","optimizedPlan","ext","createLazyFrame","KEYWORDS","tokenize","tokens","pos","upper","Parser","token","type","selectAll","selectItems","fromToken","whereExpr","groupByColumns","havingExpr","orderByItems","num","upperVal","aggName","alias2","alias","direction","leftToken","IsNullExpr2","inExpr","rightValue","aggAlias","aggColExpr","regexStr","LikeExpr","regex","invert","buildAggSpec","colRef","executeQuery","queryStr","query","aggSpec","selectedCols","columnNames","renameMap","orders","DataFrame","_DataFrame","clonedColumns","dropSet","newOrder","resolvedEnd","resolvedStart","valuesOrFnOrExpr","newColumns2","newOrder2","columnValues","detectDType3","newCol","buildColumn","before","after","anchor","anchorIdx","insertIdx","mapping","oldName","newName","predicateOrExpr","cmpAny","count3","keep","indices3","pos3","boolSeries","count2","indices2","pos2","litValue","sortCol","desc","va","vb","aIsNull","bIsNull","cmp","int32Indices2","c0","c1","v0","v1","d0","d1","a0","b0","a0Null","b0Null","cmp0","a1","b1","a1Null","b1Null","cmp1","sortValues","lastIndex","rng","seededRandom","tmp","explodeCol","otherColNames","resultArrays","strategy","casted","maxRows","maxCols","nCols","allCols","displayCols","half","rowIndices","formatValue","headerRow","dataRows","cells","colWidths","ci","maxW","w","sep","headerLine","topBorder","headerSep","bottomBorder","colObj","std","min","max","colNameWidth","totalMemory","nullCount","mem","formatBytes","firstKey","step","chunks","response","parsed","buildDataFrameFromParsed","path","placeholder","lazy","filePathOrOptions","maybeOptions","writable","csvString","settled","fail","part","jsonString","ndjsonString","extension","readerFn","writerFn","reader","writer","seed","t","rawColumns","rawValues","typedValues","convertColumnValues","detectValueDType","buildColumnForValues2","WhenExpr","clauses","otherwise","clause","conditionResults","valueResults","otherwiseResult","detectedDType","matched","WhenBuilder","condition","ThenBuilder","ChainedWhenBuilder","when","StringUnaryExpr","StringContainsExpr","StringStartsWithExpr","StringEndsWithExpr","StringReplaceExpr","StringSliceExpr","StringLengthExpr","StringConcatExpr","p","evaluatedParts","StringExprAccessor","extractDateComponent","DateComponentExpr","DateTruncateExpr","truncateDate2","DateDiffExpr","convertMsToDiffUnit","ms","DateExprAccessor","WindowRankingExpr","compareValues","WindowRankExpr","_WindowRankExpr","indexed","ranks","rank","WindowDenseRankExpr","_WindowDenseRankExpr","WindowRowNumberExpr","_WindowRowNumberExpr","WindowPercentRankExpr","_WindowPercentRankExpr","WindowNtileExpr","_WindowNtileExpr","sa","sb","CumulativeExpr","CumSumExpr","CumMaxExpr","CumMinExpr","CumProdExpr","prod","CumCountExpr","OffsetExpr","ShiftExpr","srcIdx","DiffExpr","prevIdx","curr","prev","PctChangeExpr","RollingExpr","windowSize","RollingMeanExpr","RollingSumExpr","RollingStdExpr","windowVals","sqDiffSum","RollingMinExpr","RollingMaxExpr","EwmExpr","alpha","ewma","PartitionedWindowExpr","partitionCols","partitionMap","partCols","serializeKey4","subDf","subResult","OrderedWindowExpr","orderCol","directedInner","applyRankingDirection","dir","sortedDf","sortedResult","df"],"mappings":"AAGO,SAASA,IAA4B,CAC1C,MAAMC,EACJ,OAAO,UAAc,KAAe,UAAU,oBAC1C,UAAU,oBACV,EACN,OAAO,MAAM,KAAK,CAAE,OAAQA,CAAA,EAAS,KAAO,CAAE,MAAO,SAAA,EAAY,CACnE,CAEO,SAASC,IAAmB,CACjC,MAAO,SACT,CAEO,SAASC,IAAe,CAC7B,MAAO,SACT,CAEO,SAASC,IAAiB,CAC/B,MAAO,MACT,CAEO,MAAMC,GAAM;AAAA,EAEnB,IAAAC,GAAe,CAAE,KAAAN,GAAM,SAAAE,GAAU,KAAAC,GAAM,OAAAC,GAAQ,IAAAC,EAAA,ECxB3CE,IAA0BC,IAC5BA,EAAO,QAAa,MACpBA,EAAO,MAAW,MAClBA,EAAO,MAAW,MAClBA,EAAO,KAAU,OACjBA,EAAO,QAAa,OACpBA,EAAO,KAAU,OACjBA,EAAO,SAAc,WACrBA,EAAO,KAAU,OACjBA,EAAO,OAAY,SACnBA,EAAO,OAAY,SACZA,IACND,IAAS,CAAA,CAAE,EAGVE,IAA8BC,IAChCA,EAAW,iBAAsB,mBACjCA,EAAW,cAAmB,gBAC9BA,EAAW,eAAoB,iBAC/BA,EAAW,YAAiB,cAC5BA,EAAW,SAAc,WACzBA,EAAW,cAAmB,gBAC9BA,EAAW,kBAAuB,oBAC3BA,IACND,IAAa,CAAA,CAAE,EACdE,EAAgB,cAAc,KAAM,CACtC,KACA,YAAYC,EAAMC,EAAS,CACzB,MAAMA,CAAO,EACb,KAAK,KAAO,gBACZ,KAAK,KAAOD,CACd,CACF,EACIE,EAAsB,cAAcH,CAAc,CACpD,YAAYI,EAAQC,EAAW,CAC7B,MACE,mBACA,WAAWD,CAAM,oCAAoCC,EAAU,KAAK,IAAI,CAAC,GAC/E,EACI,KAAK,KAAO,qBACd,CACF,EACIC,GAAoB,cAAcN,CAAc,CAClD,YAAYE,EAAS,CACnB,MAAM,gBAAqCA,CAAO,EAClD,KAAK,KAAO,mBACd,CACF,EACIK,GAAqB,cAAcP,CAAc,CACnD,YAAYE,EAAS,CACnB,MAAM,iBAAuCA,CAAO,EACpD,KAAK,KAAO,oBACd,CACF,EACIM,GAAa,cAAcR,CAAc,CAC3C,YAAYE,EAAS,CACnB,MAAM,cAAiCA,CAAO,EAC9C,KAAK,KAAO,YACd,CACF,EACIO,EAAU,cAAcT,CAAc,CACxC,YAAYE,EAAS,CACnB,MAAM,WAA2BA,CAAO,EACxC,KAAK,KAAO,SACd,CACF,EAGIQ,EAAW,MAAMC,EAAU,CAC7B,QACA,QACA,YAAYC,EAAQC,EAAe,GAAO,CACxC,GAAID,EAAS,EACX,MAAM,IAAIZ,EACR,oBACA,6CAA6CY,CAAM,EAC3D,EAEI,KAAK,QAAUA,EACf,MAAME,EAAY,KAAK,KAAKF,EAAS,CAAC,EACtC,KAAK,QAAU,IAAI,WAAWE,CAAS,EACnCD,GACF,KAAK,QAAQ,KAAK,GAAG,CAEzB,CACA,IAAI,QAAS,CACX,OAAO,KAAK,OACd,CACA,IAAI,YAAa,CACf,OAAO,KAAK,QAAQ,UACtB,CACA,IAAIE,EAAO,CACT,YAAK,aAAaA,CAAK,EAChB,KAAK,UAAUA,CAAK,CAC7B,CACA,UAAUA,EAAO,CACf,MAAMC,EAAYD,GAAS,EACrBE,EAAWF,EAAQ,EACzB,OAAQ,KAAK,QAAQC,CAAS,EAAI,GAAKC,KAAc,CACvD,CACA,IAAIF,EAAOG,EAAO,CAChB,KAAK,aAAaH,CAAK,EACvB,KAAK,UAAUA,EAAOG,CAAK,CAC7B,CACA,UAAUH,EAAOG,EAAO,CACtB,MAAMF,EAAYD,GAAS,EACrBE,EAAWF,EAAQ,EACrBG,EACF,KAAK,QAAQF,CAAS,EAAI,KAAK,QAAQA,CAAS,EAAI,GAAKC,EAEzD,KAAK,QAAQD,CAAS,EAAI,KAAK,QAAQA,CAAS,EAAI,EAAE,GAAKC,EAE/D,CACA,WAAY,CACV,IAAI3B,EAAQ,EACZ,QAAS6B,EAAI,EAAGA,EAAI,KAAK,QAASA,IAC5B,KAAK,IAAIA,CAAC,GACZ7B,IAGJ,OAAOA,CACT,CACA,YAAa,CACX,OAAO,KAAK,QAAU,KAAK,UAAS,CACtC,CACA,IAAI8B,EAAO,CACT,KAAK,aAAaA,CAAK,EACvB,MAAMC,EAAS,IAAIV,GAAU,KAAK,OAAO,EACzC,QAASQ,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IACvCE,EAAO,QAAQF,CAAC,EAAI,KAAK,QAAQA,CAAC,EAAIC,EAAM,QAAQD,CAAC,EAEvD,OAAOE,CACT,CACA,GAAGD,EAAO,CACR,KAAK,aAAaA,CAAK,EACvB,MAAMC,EAAS,IAAIV,GAAU,KAAK,OAAO,EACzC,QAASQ,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IACvCE,EAAO,QAAQF,CAAC,EAAI,KAAK,QAAQA,CAAC,EAAIC,EAAM,QAAQD,CAAC,EAEvD,OAAOE,CACT,CACA,OAAQ,CACN,MAAMA,EAAS,IAAIV,GAAU,KAAK,OAAO,EACzC,OAAAU,EAAO,QAAQ,IAAI,KAAK,OAAO,EACxBA,CACT,CACA,KAAM,CACJ,MAAMA,EAAS,IAAIV,GAAU,KAAK,OAAO,EACzC,QAASQ,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IACvCE,EAAO,QAAQF,CAAC,EAAI,CAAC,KAAK,QAAQA,CAAC,EAAI,IAEzC,OAAOE,CACT,CACA,aAAaN,EAAO,CAClB,GAAIA,EAAQ,GAAKA,GAAS,KAAK,QAC7B,MAAM,IAAIf,EACR,oBACA,kBAAkBe,CAAK,6BAA6B,KAAK,OAAO,EACxE,CAEE,CACA,aAAaK,EAAO,CAClB,GAAI,KAAK,UAAYA,EAAM,QACzB,MAAM,IAAIpB,EACR,iBACA,6BAA6B,KAAK,OAAO,OAAOoB,EAAM,OAAO,EACrE,CAEE,CACF,EAGIE,GAAS,KAAM,CACjB,UACA,QACA,UAAY,EACZ,YAAYV,EAAQW,EAAU,CAC5B,KAAK,QAAUX,EACf,KAAK,UAAYW,GAAY,IAAIb,EAASE,EAAQ,EAAI,CACxD,CACA,IAAI,QAAS,CACX,OAAO,KAAK,OACd,CACA,IAAI,WAAY,CACd,OAAO,KAAK,UAAU,WAAU,CAClC,CACA,QAAS,CACP,KAAK,WACP,CACA,SAAU,CACJ,KAAK,UAAY,GACnB,KAAK,WAET,CACA,IAAI,UAAW,CACb,OAAO,KAAK,SACd,CACA,IAAI,UAAW,CACb,OAAO,KAAK,UAAY,CAC1B,CACF,EAGIY,EAAgB,MAAMC,WAAuBH,EAAO,CACtD,MAAQ,MACR,MACA,UACA,YAAYI,EAAMH,EAAU,CAC1B,MAAMG,EAAK,OAAQH,CAAQ,EAC3B,KAAK,MAAQG,EACb,KAAK,UAAYH,IAAa,MAChC,CACA,IAAIR,EAAO,CAET,OADA,KAAK,aAAaA,CAAK,EACnB,KAAK,UACA,KAAK,MAAMA,CAAK,EAEpB,KAAK,UAAU,UAAUA,CAAK,EAG5B,KAAK,MAAMA,CAAK,EAFd,IAGX,CACA,MAAMY,EAAOC,EAAK,CAChB,MAAMC,EAAS,KAAK,MAAM,SAASF,EAAOC,CAAG,EAC7C,GAAI,KAAK,UACP,OAAO,IAAIH,GAAeI,CAAM,EAElC,MAAMC,EAAO,IAAIpB,EAASmB,EAAO,MAAM,EACvC,QAASV,EAAI,EAAGA,EAAIU,EAAO,OAAQV,IACjCW,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUQ,EAAQR,CAAC,CAAC,EAEvD,OAAO,IAAIM,GAAeI,EAAQC,CAAI,CACxC,CACA,OAAQ,CACN,OAAI,KAAK,UACA,IAAIL,GAAe,IAAI,aAAa,KAAK,KAAK,CAAC,EAEjD,IAAIA,GAAe,IAAI,aAAa,KAAK,KAAK,EAAG,KAAK,UAAU,OAAO,CAChF,CACA,OAAOK,EAAM,CACX,GAAIA,EAAK,SAAW,KAAK,QACvB,MAAM,IAAI9B,EACR,iBACA,sBAAsB8B,EAAK,MAAM,iCAAiC,KAAK,OAAO,EACtF,EAEI,MAAMC,EAAU,CAAA,EAChB,QAASZ,EAAI,EAAGA,EAAIW,EAAK,OAAQX,IAC3BW,EAAK,IAAIX,CAAC,IAAM,IAClBY,EAAQ,KAAKZ,CAAC,EAGlB,OAAO,KAAK,eAAeY,CAAO,CACpC,CACA,KAAKA,EAAS,CACZ,MAAML,EAAO,IAAI,aAAaK,EAAQ,MAAM,EACtCD,EAAO,KAAK,UAAY,OAAS,IAAIpB,EAASqB,EAAQ,MAAM,EAClE,QAASZ,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAAK,CACvC,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAKP,CAAC,EAAI,KAAK,MAAMa,CAAG,EACpBF,GACFA,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUa,CAAG,CAAC,CAEnD,CACA,OAAO,IAAIP,GAAeC,EAAMI,CAAI,CACtC,CACA,KAAM,CACJ,IAAIG,EAAQ,EACZ,QAASd,EAAI,EAAGA,EAAI,KAAK,QAASA,IAC5B,KAAK,UAAU,UAAUA,CAAC,IAC5Bc,GAAS,KAAK,MAAMd,CAAC,GAGzB,OAAOc,CACT,CACA,MAAO,CACL,MAAMC,EAAa,KAAK,QAAU,KAAK,UACvC,OAAIA,IAAe,EAAU,KACtB,KAAK,IAAG,EAAKA,CACtB,CACA,KAAM,CACJ,IAAIb,EAAS,KACb,QAASF,EAAI,EAAGA,EAAI,KAAK,QAASA,IAChC,GAAI,KAAK,UAAU,UAAUA,CAAC,EAAG,CAC/B,MAAMgB,EAAM,KAAK,MAAMhB,CAAC,GACpBE,IAAW,MAAQc,EAAMd,KAC3BA,EAASc,EAEb,CAEF,OAAOd,CACT,CACA,KAAM,CACJ,IAAIA,EAAS,KACb,QAASF,EAAI,EAAGA,EAAI,KAAK,QAASA,IAChC,GAAI,KAAK,UAAU,UAAUA,CAAC,EAAG,CAC/B,MAAMgB,EAAM,KAAK,MAAMhB,CAAC,GACpBE,IAAW,MAAQc,EAAMd,KAC3BA,EAASc,EAEb,CAEF,OAAOd,CACT,CACA,sBAAuB,CACrB,OAAO,KAAK,QAAU,EAAI,KAAK,UAAU,UAC3C,CACA,OAAO,KAAKe,EAAQ,CAClB,MAAMV,EAAO,IAAI,aAAaU,EAAO,MAAM,EACrCN,EAAO,IAAIpB,EAAS0B,EAAO,MAAM,EACvC,IAAIC,EAAU,GACd,QAASlB,EAAI,EAAGA,EAAIiB,EAAO,OAAQjB,IAAK,CACtC,MAAMmB,EAAIF,EAAOjB,CAAC,EACdmB,GAAM,MACRZ,EAAKP,CAAC,EAAImB,EACVR,EAAK,UAAUX,EAAG,EAAI,GAEtBkB,EAAU,EAEd,CACA,OAAOA,EAAU,IAAIZ,GAAeC,EAAMI,CAAI,EAAI,IAAIL,GAAeC,CAAI,CAC3E,CACA,aAAaX,EAAO,CAClB,GAAIA,EAAQ,GAAKA,GAAS,KAAK,QAC7B,MAAM,IAAIf,EACR,oBACA,SAASe,CAAK,uCAAuC,KAAK,OAAO,EACzE,CAEE,CACA,eAAegB,EAAS,CACtB,MAAML,EAAO,IAAI,aAAaK,EAAQ,MAAM,EACtCD,EAAO,IAAIpB,EAASqB,EAAQ,MAAM,EACxC,QAASZ,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAAK,CACvC,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAKP,CAAC,EAAI,KAAK,MAAMa,CAAG,EACxBF,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUa,CAAG,CAAC,CACjD,CACA,OAAO,IAAIP,GAAeC,EAAMI,CAAI,CACtC,CACF,EACIS,GAAc,MAAMC,WAAqBlB,EAAO,CAClD,MAAQ,MACR,MACA,UACA,YAAYI,EAAMH,EAAU,CAC1B,MAAMG,EAAK,OAAQH,CAAQ,EAC3B,KAAK,MAAQG,EACb,KAAK,UAAYH,IAAa,MAChC,CACA,IAAIR,EAAO,CAET,OADA,KAAK,aAAaA,CAAK,EACnB,KAAK,UACA,KAAK,MAAMA,CAAK,EAEpB,KAAK,UAAU,UAAUA,CAAK,EAG5B,KAAK,MAAMA,CAAK,EAFd,IAGX,CACA,MAAMY,EAAOC,EAAK,CAChB,MAAMC,EAAS,KAAK,MAAM,SAASF,EAAOC,CAAG,EAC7C,GAAI,KAAK,UACP,OAAO,IAAIY,GAAaX,CAAM,EAEhC,MAAMC,EAAO,IAAIpB,EAASmB,EAAO,MAAM,EACvC,QAASV,EAAI,EAAGA,EAAIU,EAAO,OAAQV,IACjCW,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUQ,EAAQR,CAAC,CAAC,EAEvD,OAAO,IAAIqB,GAAaX,EAAQC,CAAI,CACtC,CACA,OAAQ,CACN,OAAI,KAAK,UACA,IAAIU,GAAa,IAAI,WAAW,KAAK,KAAK,CAAC,EAE7C,IAAIA,GAAa,IAAI,WAAW,KAAK,KAAK,EAAG,KAAK,UAAU,OAAO,CAC5E,CACA,OAAOV,EAAM,CACX,GAAIA,EAAK,SAAW,KAAK,QACvB,MAAM,IAAI9B,EACR,iBACA,sBAAsB8B,EAAK,MAAM,iCAAiC,KAAK,OAAO,EACtF,EAEI,MAAMC,EAAU,CAAA,EAChB,QAASZ,EAAI,EAAGA,EAAIW,EAAK,OAAQX,IAC3BW,EAAK,IAAIX,CAAC,IAAM,IAClBY,EAAQ,KAAKZ,CAAC,EAGlB,OAAO,KAAK,eAAeY,CAAO,CACpC,CACA,KAAKA,EAAS,CACZ,MAAML,EAAO,IAAI,WAAWK,EAAQ,MAAM,EACpCD,EAAO,KAAK,UAAY,OAAS,IAAIpB,EAASqB,EAAQ,MAAM,EAClE,QAASZ,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAAK,CACvC,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAKP,CAAC,EAAI,KAAK,MAAMa,CAAG,EACpBF,GACFA,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUa,CAAG,CAAC,CAEnD,CACA,OAAO,IAAIQ,GAAad,EAAMI,CAAI,CACpC,CACA,KAAM,CACJ,IAAIG,EAAQ,EACZ,QAASd,EAAI,EAAGA,EAAI,KAAK,QAASA,IAC5B,KAAK,UAAU,UAAUA,CAAC,IAC5Bc,GAAS,KAAK,MAAMd,CAAC,GAGzB,OAAOc,CACT,CACA,MAAO,CACL,MAAMC,EAAa,KAAK,QAAU,KAAK,UACvC,OAAIA,IAAe,EAAU,KACtB,KAAK,IAAG,EAAKA,CACtB,CACA,KAAM,CACJ,IAAIb,EAAS,KACb,QAASF,EAAI,EAAGA,EAAI,KAAK,QAASA,IAChC,GAAI,KAAK,UAAU,UAAUA,CAAC,EAAG,CAC/B,MAAMgB,EAAM,KAAK,MAAMhB,CAAC,GACpBE,IAAW,MAAQc,EAAMd,KAC3BA,EAASc,EAEb,CAEF,OAAOd,CACT,CACA,KAAM,CACJ,IAAIA,EAAS,KACb,QAASF,EAAI,EAAGA,EAAI,KAAK,QAASA,IAChC,GAAI,KAAK,UAAU,UAAUA,CAAC,EAAG,CAC/B,MAAMgB,EAAM,KAAK,MAAMhB,CAAC,GACpBE,IAAW,MAAQc,EAAMd,KAC3BA,EAASc,EAEb,CAEF,OAAOd,CACT,CACA,sBAAuB,CACrB,OAAO,KAAK,QAAU,EAAI,KAAK,UAAU,UAC3C,CACA,OAAO,KAAKe,EAAQ,CAClB,MAAMV,EAAO,IAAI,WAAWU,EAAO,MAAM,EACnCN,EAAO,IAAIpB,EAAS0B,EAAO,MAAM,EACvC,IAAIC,EAAU,GACd,QAASlB,EAAI,EAAGA,EAAIiB,EAAO,OAAQjB,IAAK,CACtC,MAAMmB,EAAIF,EAAOjB,CAAC,EACdmB,GAAM,MACRZ,EAAKP,CAAC,EAAImB,EACVR,EAAK,UAAUX,EAAG,EAAI,GAEtBkB,EAAU,EAEd,CACA,OAAOA,EAAU,IAAIG,GAAad,EAAMI,CAAI,EAAI,IAAIU,GAAad,CAAI,CACvE,CACA,aAAaX,EAAO,CAClB,GAAIA,EAAQ,GAAKA,GAAS,KAAK,QAC7B,MAAM,IAAIf,EACR,oBACA,SAASe,CAAK,uCAAuC,KAAK,OAAO,EACzE,CAEE,CACA,eAAegB,EAAS,CACtB,MAAML,EAAO,IAAI,WAAWK,EAAQ,MAAM,EACpCD,EAAO,IAAIpB,EAASqB,EAAQ,MAAM,EACxC,QAASZ,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAAK,CACvC,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAKP,CAAC,EAAI,KAAK,MAAMa,CAAG,EACxBF,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUa,CAAG,CAAC,CACjD,CACA,OAAO,IAAIQ,GAAad,EAAMI,CAAI,CACpC,CACF,EAGIW,EAAa,MAAMC,UAAoBpB,EAAO,CAChD,MAAQ,OACR,MACA,UACA,UACA,YAAYI,EAAMH,EAAUoB,EAAU,CACpC,MAAMjB,EAAK,OAAQH,CAAQ,EACvBoB,GACF,KAAK,MAAQ,KACb,KAAK,UAAYA,IAEjB,KAAK,MAAQjB,EACb,KAAK,UAAY,MAEnB,KAAK,UAAYH,IAAa,MAChC,CAEA,IAAI,YAAa,CACf,OAAO,KAAK,YAAc,IAC5B,CACA,IAAIR,EAAO,CAET,OADA,KAAK,aAAaA,CAAK,EACnB,KAAK,UACH,KAAK,UACA,KAAK,UAAU,WAAW,KAAK,UAAU,QAAQA,CAAK,CAAC,EAEzD,KAAK,MAAMA,CAAK,EAEpB,KAAK,UAAU,UAAUA,CAAK,EAG/B,KAAK,UACA,KAAK,UAAU,WAAW,KAAK,UAAU,QAAQA,CAAK,CAAC,EAEzD,KAAK,MAAMA,CAAK,EALd,IAMX,CACA,MAAMY,EAAOC,EAAK,CAChB,MAAMgB,EAAMhB,EAAMD,EAClB,GAAI,KAAK,UAAW,CAClB,GAAI,KAAK,UAAW,CAClB,MAAMkB,EAAgB,KAAK,UAAU,QAAQ,MAAMlB,EAAOC,CAAG,EAC7D,OAAO,IAAIc,EAAY,IAAI,MAAME,CAAG,EAAG,OAAQ,CAC7C,WAAY,KAAK,UAAU,WAC3B,QAASC,CACnB,CAAS,CACH,CACA,OAAO,IAAIH,EAAY,KAAK,MAAM,MAAMf,EAAOC,CAAG,CAAC,CACrD,CACA,MAAME,EAAO,IAAIpB,EAASkC,CAAG,EAC7B,QAAS,EAAI,EAAG,EAAIA,EAAK,IACvBd,EAAK,UAAU,EAAG,KAAK,UAAU,UAAUH,EAAQ,CAAC,CAAC,EAEvD,GAAI,KAAK,UAAW,CAClB,MAAMkB,EAAgB,KAAK,UAAU,QAAQ,MAAMlB,EAAOC,CAAG,EAC7D,OAAO,IAAIc,EAAY,IAAI,MAAME,CAAG,EAAGd,EAAM,CAC3C,WAAY,KAAK,UAAU,WAC3B,QAASe,CACjB,CAAO,CACH,CACA,MAAMhB,EAAS,KAAK,MAAM,MAAMF,EAAOC,CAAG,EAC1C,OAAO,IAAIc,EAAYb,EAAQC,CAAI,CACrC,CACA,OAAQ,CACN,OAAI,KAAK,UACH,KAAK,UACA,IAAIY,EAAY,IAAI,MAAM,KAAK,OAAO,EAAG,OAAQ,CACtD,WAAY,CAAC,GAAG,KAAK,UAAU,UAAU,EACzC,QAAS,IAAI,YAAY,KAAK,UAAU,OAAO,CACzD,CAAS,EAEI,IAAIA,EAAY,CAAC,GAAG,KAAK,KAAK,CAAC,EAEpC,KAAK,UACA,IAAIA,EAAY,IAAI,MAAM,KAAK,OAAO,EAAG,KAAK,UAAU,QAAS,CACtE,WAAY,CAAC,GAAG,KAAK,UAAU,UAAU,EACzC,QAAS,IAAI,YAAY,KAAK,UAAU,OAAO,CACvD,CAAO,EAEI,IAAIA,EAAY,CAAC,GAAG,KAAK,KAAK,EAAG,KAAK,UAAU,OAAO,CAChE,CACA,OAAOZ,EAAM,CACX,GAAIA,EAAK,SAAW,KAAK,QACvB,MAAM,IAAI9B,EACR,iBACA,sBAAsB8B,EAAK,MAAM,iCAAiC,KAAK,OAAO,EACtF,EAEI,MAAMC,EAAU,CAAA,EAChB,QAASZ,EAAI,EAAGA,EAAIW,EAAK,OAAQX,IAC3BW,EAAK,IAAIX,CAAC,IAAM,IAClBY,EAAQ,KAAKZ,CAAC,EAGlB,OAAO,KAAK,eAAeY,CAAO,CACpC,CACA,KAAKA,EAAS,CACZ,MAAMa,EAAMb,EAAQ,OACdD,EAAO,KAAK,UAAY,OAAS,IAAIpB,EAASkC,CAAG,EACvD,GAAI,KAAK,UAAW,CAClB,MAAME,EAAa,IAAI,YAAYF,CAAG,EACtC,QAAS,EAAI,EAAG,EAAIA,EAAK,IAAK,CAC5B,MAAMZ,EAAMD,EAAQ,CAAC,EACrBe,EAAW,CAAC,EAAI,KAAK,UAAU,QAAQd,CAAG,EACtCF,GACFA,EAAK,UAAU,EAAG,KAAK,UAAU,UAAUE,CAAG,CAAC,CAEnD,CACA,OAAO,IAAIU,EAAY,IAAI,MAAME,CAAG,EAAGd,EAAM,CAC3C,WAAY,KAAK,UAAU,WAC3B,QAASgB,CACjB,CAAO,CACH,CACA,MAAMpB,EAAO,IAAI,MAAMkB,CAAG,EAC1B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAKP,CAAC,EAAI,KAAK,MAAMa,CAAG,EACpBF,GACFA,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUa,CAAG,CAAC,CAEnD,CACA,OAAO,IAAIU,EAAYhB,EAAMI,CAAI,CACnC,CACA,sBAAuB,CACrB,IAAIiB,EAAQ,KAAK,UAAU,WAC3B,GAAI,KAAK,UAAW,CAClB,UAAWC,KAAK,KAAK,UAAU,WAC7BD,GAASC,EAAE,OAAS,EAEtBD,GAAS,KAAK,UAAU,QAAQ,UAClC,KACE,SAAS5B,EAAI,EAAGA,EAAI,KAAK,QAASA,IAC5B,KAAK,UAAU,IAAIA,CAAC,IACtB4B,GAAS,KAAK,MAAM5B,CAAC,EAAE,OAAS,GAItC,OAAO4B,CACT,CACA,OAAO,KAAKX,EAAQ,CAClB,MAAMQ,EAAMR,EAAO,OACbV,EAAO,IAAI,MAAMkB,CAAG,EACpBd,EAAO,IAAIpB,EAASkC,CAAG,EAC7B,IAAIP,EAAU,GACd,QAAS,EAAI,EAAG,EAAIO,EAAK,IAAK,CAC5B,MAAMN,EAAIF,EAAO,CAAC,EACdE,GAAM,MACRZ,EAAK,CAAC,EAAIY,EACVR,EAAK,IAAI,EAAG,EAAI,IAEhBJ,EAAK,CAAC,EAAI,GACVW,EAAU,GAEd,CACA,GAAIO,EAAM,EAAG,CACX,MAAMK,EAA4B,IAAI,IACtC,IAAIC,EAAe,EACnB,QAAS/B,EAAI,EAAGA,EAAIyB,EAAKzB,IACnBW,EAAK,UAAUX,CAAC,IAClB8B,EAAU,IAAIvB,EAAKP,CAAC,CAAC,EACrB+B,KAGJ,GAAIA,EAAe,GAAKD,EAAU,KAAOL,EAAM,GAAK,CAClD,MAAMO,EAAa,MAAM,KAAKF,CAAS,EACjCG,EAA0B,IAAI,IACpC,QAASC,EAAI,EAAGA,EAAIF,EAAW,OAAQE,IACrCD,EAAQ,IAAID,EAAWE,CAAC,EAAGA,CAAC,EAE9B,MAAMtB,EAAU,IAAI,YAAYa,CAAG,EACnC,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IACnBW,EAAK,UAAUX,CAAC,IAClBY,EAAQZ,CAAC,EAAIiC,EAAQ,IAAI1B,EAAKP,CAAC,CAAC,GAGpC,OAAOkB,EAAU,IAAIK,EAAYhB,EAAMI,EAAM,CAAE,WAAAqB,EAAY,QAAApB,CAAO,CAAE,EAAI,IAAIW,EAAYhB,EAAM,OAAQ,CAAE,WAAAyB,EAAY,QAAApB,EAAS,CAC/H,CACF,CACA,OAAOM,EAAU,IAAIK,EAAYhB,EAAMI,CAAI,EAAI,IAAIY,EAAYhB,CAAI,CACrE,CACA,aAAaX,EAAO,CAClB,GAAIA,EAAQ,GAAKA,GAAS,KAAK,QAC7B,MAAM,IAAIf,EACR,oBACA,SAASe,CAAK,uCAAuC,KAAK,OAAO,EACzE,CAEE,CACA,eAAegB,EAAS,CACtB,MAAMa,EAAMb,EAAQ,OACdD,EAAO,IAAIpB,EAASkC,CAAG,EAC7B,GAAI,KAAK,UAAW,CAClB,MAAME,EAAa,IAAI,YAAYF,CAAG,EACtC,QAAS,EAAI,EAAG,EAAIA,EAAK,IAAK,CAC5B,MAAMZ,EAAMD,EAAQ,CAAC,EACrBe,EAAW,CAAC,EAAI,KAAK,UAAU,QAAQd,CAAG,EAC1CF,EAAK,UAAU,EAAG,KAAK,UAAU,UAAUE,CAAG,CAAC,CACjD,CACA,OAAO,IAAIU,EAAY,IAAI,MAAME,CAAG,EAAGd,EAAM,CAC3C,WAAY,KAAK,UAAU,WAC3B,QAASgB,CACjB,CAAO,CACH,CACA,MAAMpB,EAAO,IAAI,MAAMkB,CAAG,EAC1B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAKP,CAAC,EAAI,KAAK,MAAMa,CAAG,EACxBF,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUa,CAAG,CAAC,CACjD,CACA,OAAO,IAAIU,EAAYhB,EAAMI,CAAI,CACnC,CACF,EAGIwB,EAAgB,MAAMC,WAAuBjC,EAAO,CACtD,MAAQ,OACR,MACA,YAAYI,EAAMH,EAAU,CAC1B,MAAMG,EAAK,OAAQH,CAAQ,EAC3B,KAAK,MAAQG,CACf,CACA,IAAIX,EAAO,CAET,OADA,KAAK,aAAaA,CAAK,EAClB,KAAK,UAAU,UAAUA,CAAK,EAG5B,KAAK,MAAMA,CAAK,IAAM,EAFpB,IAGX,CACA,MAAMY,EAAOC,EAAK,CAChB,MAAMC,EAAS,KAAK,MAAM,SAASF,EAAOC,CAAG,EACvCE,EAAO,IAAIpB,EAASmB,EAAO,MAAM,EACvC,QAASV,EAAI,EAAGA,EAAIU,EAAO,OAAQV,IACjCW,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUQ,EAAQR,CAAC,CAAC,EAEvD,OAAO,IAAIoC,GAAe1B,EAAQC,CAAI,CACxC,CACA,OAAQ,CACN,OAAO,IAAIyB,GAAe,IAAI,WAAW,KAAK,KAAK,EAAG,KAAK,UAAU,OAAO,CAC9E,CACA,OAAOzB,EAAM,CACX,GAAIA,EAAK,SAAW,KAAK,QACvB,MAAM,IAAI9B,EACR,iBACA,sBAAsB8B,EAAK,MAAM,iCAAiC,KAAK,OAAO,EACtF,EAEI,MAAMC,EAAU,CAAA,EAChB,QAASZ,EAAI,EAAGA,EAAIW,EAAK,OAAQX,IAC3BW,EAAK,IAAIX,CAAC,IAAM,IAClBY,EAAQ,KAAKZ,CAAC,EAGlB,OAAO,KAAK,eAAeY,CAAO,CACpC,CACA,KAAKA,EAAS,CACZ,MAAML,EAAO,IAAI,WAAWK,EAAQ,MAAM,EACpCD,EAAO,IAAIpB,EAASqB,EAAQ,MAAM,EACxC,QAASZ,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAAK,CACvC,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAKP,CAAC,EAAI,KAAK,MAAMa,CAAG,EACxBF,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUa,CAAG,CAAC,CACjD,CACA,OAAO,IAAIuB,GAAe7B,EAAMI,CAAI,CACtC,CACA,sBAAuB,CACrB,OAAO,KAAK,QAAU,KAAK,UAAU,UACvC,CACA,OAAO,KAAKM,EAAQ,CAClB,MAAMV,EAAO,IAAI,WAAWU,EAAO,MAAM,EACnCN,EAAO,IAAIpB,EAAS0B,EAAO,MAAM,EACvC,QAASjB,EAAI,EAAGA,EAAIiB,EAAO,OAAQjB,IAAK,CACtC,MAAMmB,EAAIF,EAAOjB,CAAC,EACdmB,GAAM,OACRZ,EAAKP,CAAC,EAAImB,EAAI,EAAI,EAClBR,EAAK,UAAUX,EAAG,EAAI,EAE1B,CACA,OAAO,IAAIoC,GAAe7B,EAAMI,CAAI,CACtC,CACA,aAAaf,EAAO,CAClB,GAAIA,EAAQ,GAAKA,GAAS,KAAK,QAC7B,MAAM,IAAIf,EACR,oBACA,SAASe,CAAK,uCAAuC,KAAK,OAAO,EACzE,CAEE,CACA,eAAegB,EAAS,CACtB,MAAML,EAAO,IAAI,WAAWK,EAAQ,MAAM,EACpCD,EAAO,IAAIpB,EAASqB,EAAQ,MAAM,EACxC,QAASZ,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAAK,CACvC,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAKP,CAAC,EAAI,KAAK,MAAMa,CAAG,EACxBF,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUa,CAAG,CAAC,CACjD,CACA,OAAO,IAAIuB,GAAe7B,EAAMI,CAAI,CACtC,CACF,EAGI0B,EAAa,MAAMC,WAAoBnC,EAAO,CAChD,MAAQ,OACR,MACA,YAAYI,EAAMH,EAAU,CAC1B,MAAMG,EAAK,OAAQH,CAAQ,EAC3B,KAAK,MAAQG,CACf,CACA,IAAIX,EAAO,CAET,OADA,KAAK,aAAaA,CAAK,EAClB,KAAK,UAAU,UAAUA,CAAK,EAG5B,IAAI,KAAK,KAAK,MAAMA,CAAK,CAAC,EAFxB,IAGX,CACA,MAAMY,EAAOC,EAAK,CAChB,MAAMC,EAAS,KAAK,MAAM,SAASF,EAAOC,CAAG,EACvCE,EAAO,IAAIpB,EAASmB,EAAO,MAAM,EACvC,QAASV,EAAI,EAAGA,EAAIU,EAAO,OAAQV,IACjCW,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUQ,EAAQR,CAAC,CAAC,EAEvD,OAAO,IAAIsC,GAAY5B,EAAQC,CAAI,CACrC,CACA,OAAQ,CACN,OAAO,IAAI2B,GAAY,IAAI,aAAa,KAAK,KAAK,EAAG,KAAK,UAAU,OAAO,CAC7E,CACA,OAAO3B,EAAM,CACX,GAAIA,EAAK,SAAW,KAAK,QACvB,MAAM,IAAI9B,EACR,iBACA,sBAAsB8B,EAAK,MAAM,iCAAiC,KAAK,OAAO,EACtF,EAEI,MAAMC,EAAU,CAAA,EAChB,QAASZ,EAAI,EAAGA,EAAIW,EAAK,OAAQX,IAC3BW,EAAK,IAAIX,CAAC,IAAM,IAClBY,EAAQ,KAAKZ,CAAC,EAGlB,OAAO,KAAK,eAAeY,CAAO,CACpC,CACA,KAAKA,EAAS,CACZ,MAAML,EAAO,IAAI,aAAaK,EAAQ,MAAM,EACtCD,EAAO,IAAIpB,EAASqB,EAAQ,MAAM,EACxC,QAASZ,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAAK,CACvC,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAKP,CAAC,EAAI,KAAK,MAAMa,CAAG,EACxBF,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUa,CAAG,CAAC,CACjD,CACA,OAAO,IAAIyB,GAAY/B,EAAMI,CAAI,CACnC,CACA,sBAAuB,CACrB,OAAO,KAAK,QAAU,EAAI,KAAK,UAAU,UAC3C,CACA,OAAO,KAAKM,EAAQ,CAClB,MAAMV,EAAO,IAAI,aAAaU,EAAO,MAAM,EACrCN,EAAO,IAAIpB,EAAS0B,EAAO,MAAM,EACvC,QAASjB,EAAI,EAAGA,EAAIiB,EAAO,OAAQjB,IAAK,CACtC,MAAMmB,EAAIF,EAAOjB,CAAC,EACdmB,GAAM,OACRZ,EAAKP,CAAC,EAAImB,EAAE,QAAO,EACnBR,EAAK,UAAUX,EAAG,EAAI,EAE1B,CACA,OAAO,IAAIsC,GAAY/B,EAAMI,CAAI,CACnC,CACA,aAAaf,EAAO,CAClB,GAAIA,EAAQ,GAAKA,GAAS,KAAK,QAC7B,MAAM,IAAIf,EACR,oBACA,SAASe,CAAK,uCAAuC,KAAK,OAAO,EACzE,CAEE,CACA,eAAegB,EAAS,CACtB,MAAML,EAAO,IAAI,aAAaK,EAAQ,MAAM,EACtCD,EAAO,IAAIpB,EAASqB,EAAQ,MAAM,EACxC,QAASZ,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAAK,CACvC,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAKP,CAAC,EAAI,KAAK,MAAMa,CAAG,EACxBF,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUa,CAAG,CAAC,CACjD,CACA,OAAO,IAAIyB,GAAY/B,EAAMI,CAAI,CACnC,CACF,EAGI4B,GAAe,MAAMC,WAAsBrC,EAAO,CACpD,MAAQ,SACR,MACA,YAAYI,EAAMH,EAAU,CAC1B,MAAMG,EAAK,OAAQH,CAAQ,EAC3B,KAAK,MAAQG,CACf,CACA,IAAIX,EAAO,CAET,OADA,KAAK,aAAaA,CAAK,EAClB,KAAK,UAAU,UAAUA,CAAK,EAG5B,KAAK,MAAMA,CAAK,EAFd,IAGX,CACA,MAAMY,EAAOC,EAAK,CAChB,MAAMC,EAAS,KAAK,MAAM,MAAMF,EAAOC,CAAG,EACpCE,EAAO,IAAIpB,EAASmB,EAAO,MAAM,EACvC,QAASV,EAAI,EAAGA,EAAIU,EAAO,OAAQV,IACjCW,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUQ,EAAQR,CAAC,CAAC,EAEvD,OAAO,IAAIwC,GAAc9B,EAAQC,CAAI,CACvC,CACA,OAAQ,CACN,OAAO,IAAI6B,GAAc,CAAC,GAAG,KAAK,KAAK,EAAG,KAAK,UAAU,OAAO,CAClE,CACA,OAAO7B,EAAM,CACX,GAAIA,EAAK,SAAW,KAAK,QACvB,MAAM,IAAI9B,EACR,iBACA,sBAAsB8B,EAAK,MAAM,iCAAiC,KAAK,OAAO,EACtF,EAEI,MAAMC,EAAU,CAAA,EAChB,QAASZ,EAAI,EAAGA,EAAIW,EAAK,OAAQX,IAC3BW,EAAK,IAAIX,CAAC,IAAM,IAClBY,EAAQ,KAAKZ,CAAC,EAGlB,OAAO,KAAK,eAAeY,CAAO,CACpC,CACA,KAAKA,EAAS,CACZ,MAAML,EAAO,IAAI,MAAMK,EAAQ,MAAM,EAC/BD,EAAO,IAAIpB,EAASqB,EAAQ,MAAM,EACxC,QAASZ,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAAK,CACvC,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAKP,CAAC,EAAI,KAAK,MAAMa,CAAG,EACxBF,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUa,CAAG,CAAC,CACjD,CACA,OAAO,IAAI2B,GAAcjC,EAAMI,CAAI,CACrC,CACA,sBAAuB,CACrB,OAAO,KAAK,QAAU,EAAI,KAAK,UAAU,UAC3C,CACA,OAAO,KAAKM,EAAQ,CAClB,MAAMV,EAAO,IAAI,MAAMU,EAAO,MAAM,EAC9BN,EAAO,IAAIpB,EAAS0B,EAAO,MAAM,EACvC,QAASjB,EAAI,EAAGA,EAAIiB,EAAO,OAAQjB,IAAK,CACtC,MAAMmB,EAAIF,EAAOjB,CAAC,EACdmB,GAAM,MACRZ,EAAKP,CAAC,EAAImB,EACVR,EAAK,UAAUX,EAAG,EAAI,GAEtBO,EAAKP,CAAC,EAAI,IAEd,CACA,OAAO,IAAIwC,GAAcjC,EAAMI,CAAI,CACrC,CACA,aAAaf,EAAO,CAClB,GAAIA,EAAQ,GAAKA,GAAS,KAAK,QAC7B,MAAM,IAAIf,EACR,oBACA,SAASe,CAAK,uCAAuC,KAAK,OAAO,EACzE,CAEE,CACA,eAAegB,EAAS,CACtB,MAAML,EAAO,IAAI,MAAMK,EAAQ,MAAM,EAC/BD,EAAO,IAAIpB,EAASqB,EAAQ,MAAM,EACxC,QAASZ,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAAK,CACvC,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAKP,CAAC,EAAI,KAAK,MAAMa,CAAG,EACxBF,EAAK,UAAUX,EAAG,KAAK,UAAU,UAAUa,CAAG,CAAC,CACjD,CACA,OAAO,IAAI2B,GAAcjC,EAAMI,CAAI,CACrC,CACF,EAGI8B,GAAiB,KAAM,CACzB,QACA,YAAYC,EAAQ,CAClB,GAAIA,EAAO,QAAU,OACnB,MAAM,IAAIvD,GACR,wDAAwDuD,EAAO,KAAK,GAC5E,EAEI,KAAK,QAAUA,CACjB,CACA,aAAc,CACZ,OAAO,KAAK,WAAYb,GAAMA,EAAE,YAAW,CAAE,CAC/C,CACA,aAAc,CACZ,OAAO,KAAK,WAAYA,GAAMA,EAAE,YAAW,CAAE,CAC/C,CACA,MAAO,CACL,OAAO,KAAK,WAAYA,GAAMA,EAAE,KAAI,CAAE,CACxC,CACA,WAAWc,EAAQ,CACjB,OAAO,KAAK,YAAad,GAAMA,EAAE,WAAWc,CAAM,CAAC,CACrD,CACA,SAASC,EAAQ,CACf,OAAO,KAAK,YAAaf,GAAMA,EAAE,SAASe,CAAM,CAAC,CACnD,CACA,SAASC,EAAS,CAChB,OAAO,KAAK,YAAahB,GAAMA,EAAE,SAASgB,CAAO,CAAC,CACpD,CACA,QAAQA,EAASC,EAAa,CAC5B,OAAO,KAAK,WAAYjB,GAAMA,EAAE,WAAWgB,EAASC,CAAW,CAAC,CAClE,CACA,MAAMC,EAAW,CACf,MAAMxC,EAAO,CAAA,EACPI,EAAO,IAAIpB,EAAS,KAAK,QAAQ,MAAM,EAC7C,QAASS,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EAC1BgB,IAAQ,KACVT,EAAK,KAAK,EAAE,GAEZA,EAAK,KAAKS,EAAI,MAAM+B,CAAS,CAAC,EAC9BpC,EAAK,IAAIX,EAAG,EAAI,EAEpB,CACA,MAAMgD,EAAO,IAAIC,GAAW1C,EAAMI,CAAI,EACtC,OAAO,IAAIuC,EAAO,KAAK,QAAQ,KAAMF,CAAI,CAC3C,CACA,MAAMxC,EAAOC,EAAK,CAChB,OAAO,KAAK,WAAYoB,GAAMA,EAAE,MAAMrB,EAAOC,CAAG,CAAC,CACnD,CACA,QAAS,CACP,MAAM0C,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EAC1BgB,IAAQ,KACVmC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAKnC,EAAI,MAAM,CAE3B,CACA,OAAO,IAAIkC,EAAO,KAAK,QAAQ,KAAM7C,EAAc,KAAK8C,CAAO,CAAC,CAClE,CACA,SAAS1D,EAAQ2D,EAAU,CACzB,OAAO,KAAK,WAAYvB,GAAMA,EAAE,SAASpC,EAAQ2D,CAAQ,CAAC,CAC5D,CACA,OAAO3D,EAAQ2D,EAAU,CACvB,OAAO,KAAK,WAAYvB,GAAMA,EAAE,OAAOpC,EAAQ2D,CAAQ,CAAC,CAC1D,CACA,QAAQP,EAAS,CACf,MAAMQ,EAASR,EAAQ,OACvB,GAAI,CAACQ,EAAO,SAAS,GAAG,GAAKA,EAAO,QAAQ,QAAS,EAAE,EAAE,QAAQ,GAAG,IAAM,GACxE,MAAM,IAAIlE,GACR,2DACR,EAEI,MAAMgE,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EAC9B,GAAIgB,IAAQ,KACVmC,EAAQ,KAAK,IAAI,MACZ,CACL,MAAMG,EAAQtC,EAAI,MAAM6B,CAAO,EAC3BS,GAASA,EAAM,CAAC,IAAM,OACxBH,EAAQ,KAAKG,EAAM,CAAC,CAAC,EAErBH,EAAQ,KAAK,IAAI,CAErB,CACF,CACA,OAAO,IAAID,EAAO,KAAK,QAAQ,KAAM5B,EAAW,KAAK6B,CAAO,CAAC,CAC/D,CACA,WAAWI,EAAI,CACb,MAAMJ,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EAC1BgB,IAAQ,KACVmC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAKI,EAAGvC,CAAG,CAAC,CAExB,CACA,OAAO,IAAIkC,EAAO,KAAK,QAAQ,KAAM5B,EAAW,KAAK6B,CAAO,CAAC,CAC/D,CACA,YAAYI,EAAI,CACd,MAAMJ,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EAC1BgB,IAAQ,KACVmC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAKI,EAAGvC,CAAG,CAAC,CAExB,CACA,OAAO,IAAIkC,EAAO,KAAK,QAAQ,KAAMf,EAAc,KAAKgB,CAAO,CAAC,CAClE,CACF,EACIF,GAAa,MAAMO,WAAoBrD,EAAO,CAChD,MAAQ,OACR,MACA,YAAYI,EAAMH,EAAU,CAC1B,MAAMG,EAAK,OAAQH,CAAQ,EAC3B,KAAK,MAAQG,CACf,CACA,IAAIX,EAAO,CACT,GAAIA,EAAQ,GAAKA,GAAS,KAAK,QAC7B,MAAM,IAAI,MAAM,SAASA,CAAK,uCAAuC,KAAK,OAAO,EAAE,EAErF,OAAK,KAAK,UAAU,IAAIA,CAAK,EACtB,KAAK,MAAMA,CAAK,EADgB,IAEzC,CACA,MAAMY,EAAOC,EAAK,CAChB,MAAMC,EAAS,KAAK,MAAM,MAAMF,EAAOC,CAAG,EACpCE,EAAO,IAAIpB,EAASmB,EAAO,MAAM,EACvC,QAASV,EAAI,EAAGA,EAAIU,EAAO,OAAQV,IACjCW,EAAK,IAAIX,EAAG,KAAK,UAAU,IAAIQ,EAAQR,CAAC,CAAC,EAE3C,OAAO,IAAIwD,GAAY9C,EAAQC,CAAI,CACrC,CACA,OAAQ,CACN,OAAO,IAAI6C,GACT,KAAK,MAAM,IAAKC,GAAQ,CAAC,GAAGA,CAAG,CAAC,EAChC,KAAK,UAAU,MAAK,CAC1B,CACE,CACA,OAAO9C,EAAM,CACX,MAAMC,EAAU,CAAA,EAChB,QAASZ,EAAI,EAAGA,EAAIW,EAAK,OAAQX,IAC3BW,EAAK,IAAIX,CAAC,IAAM,IAAMY,EAAQ,KAAKZ,CAAC,EAE1C,OAAO,KAAK,eAAeY,CAAO,CACpC,CACA,KAAKA,EAAS,CACZ,MAAM8C,EAAW,CAAA,EACjB,QAAS1D,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAClC0D,EAAS,KAAK9C,EAAQZ,CAAC,CAAC,EAE1B,OAAO,KAAK,eAAe0D,CAAQ,CACrC,CACA,sBAAuB,CACrB,IAAI9B,EAAQ,KAAK,UAAU,WAC3B,QAAS5B,EAAI,EAAGA,EAAI,KAAK,QAASA,IAChC,GAAI,KAAK,UAAU,IAAIA,CAAC,EACtB,UAAW,KAAK,KAAK,MAAMA,CAAC,EAC1B4B,GAAS,EAAE,OAAS,EAI1B,OAAOA,CACT,CACA,eAAehB,EAAS,CACtB,MAAML,EAAO,CAAA,EACPI,EAAO,IAAIpB,EAASqB,EAAQ,MAAM,EACxC,QAASZ,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAAK,CACvC,MAAMa,EAAMD,EAAQZ,CAAC,EACrBO,EAAK,KAAK,KAAK,MAAMM,CAAG,CAAC,EACzBF,EAAK,IAAIX,EAAG,KAAK,UAAU,IAAIa,CAAG,CAAC,CACrC,CACA,OAAO,IAAI2C,GAAYjD,EAAMI,CAAI,CACnC,CACF,EAGIgD,GAAe,KAAM,CACvB,QACA,YAAYjB,EAAQ,CAClB,GAAIA,EAAO,QAAU,OACnB,MAAM,IAAIvD,GACR,sDAAsDuD,EAAO,KAAK,GAC1E,EAEI,KAAK,QAAUA,CACjB,CACA,MAAO,CACL,OAAO,KAAK,WAAYR,GAAMA,EAAE,YAAW,CAAE,CAC/C,CACA,OAAQ,CACN,OAAO,KAAK,WAAYA,GAAMA,EAAE,SAAQ,EAAK,CAAC,CAChD,CACA,KAAM,CACJ,OAAO,KAAK,WAAYA,GAAMA,EAAE,QAAO,CAAE,CAC3C,CACA,MAAO,CACL,OAAO,KAAK,WAAYA,GAAMA,EAAE,SAAQ,CAAE,CAC5C,CACA,QAAS,CACP,OAAO,KAAK,WAAYA,GAAMA,EAAE,WAAU,CAAE,CAC9C,CACA,QAAS,CACP,OAAO,KAAK,WAAYA,GAAMA,EAAE,WAAU,CAAE,CAC9C,CACA,WAAY,CACV,OAAO,KAAK,WAAYA,GAAMA,EAAE,OAAM,CAAE,CAC1C,CACA,WAAY,CACV,OAAO,KAAK,WAAYA,GAAM,CAC5B,MAAM1B,EAAQ,IAAI,KAAK0B,EAAE,YAAW,EAAI,EAAG,CAAC,EACtC0B,EAAO1B,EAAE,QAAO,EAAK1B,EAAM,QAAO,EAClCqD,EAAS,IAAM,GAAK,GAAK,GAC/B,OAAO,KAAK,MAAMD,EAAOC,CAAM,CACjC,CAAC,CACH,CACA,YAAa,CACX,OAAO,KAAK,WAAY3B,GAAM,CAC5B,MAAM4B,EAAS,IAAI,KAAK5B,EAAE,QAAO,CAAE,EACnC4B,EAAO,SAAS,EAAG,EAAG,EAAG,CAAC,EAC1BA,EAAO,QAAQA,EAAO,UAAY,GAAKA,EAAO,OAAM,EAAK,GAAK,CAAC,EAC/D,MAAMC,EAAO,IAAI,KAAKD,EAAO,YAAW,EAAI,EAAG,CAAC,EAC1CE,GAAWF,EAAO,UAAYC,EAAK,QAAO,IAAO,IAAM,GAAK,GAAK,IACvE,MAAO,GAAI,KAAK,OAAOC,EAAU,GAAKD,EAAK,OAAM,EAAK,GAAK,GAAK,CAAC,CACnE,CAAC,CACH,CACA,SAAU,CACR,OAAO,KAAK,WAAY7B,GAAM,KAAK,MAAMA,EAAE,SAAQ,EAAK,CAAC,EAAI,CAAC,CAChE,CACA,WAAY,CACV,OAAO,KAAK,WAAYA,GAAMA,EAAE,QAAO,CAAE,CAC3C,CACA,OAAOW,EAAS,CACd,MAAMM,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EAC1BgB,IAAQ,KACVmC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAKc,GAAWjD,EAAK6B,CAAO,CAAC,CAEzC,CACA,OAAO,IAAIK,EAAO,KAAK,QAAQ,KAAM5B,EAAW,KAAK6B,CAAO,CAAC,CAC/D,CACA,KAAKlD,EAAOiE,EAAM,CAChB,GAAIjE,EAAM,QAAU,OAClB,MAAM,IAAId,GACR,uCAAuCc,EAAM,KAAK,GAC1D,EAEI,GAAIA,EAAM,SAAW,KAAK,QAAQ,OAChC,MAAM,IAAId,GACR,+CAA+C,KAAK,QAAQ,MAAM,QAAQc,EAAM,MAAM,EAC9F,EAEI,MAAMkD,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMmE,EAAI,KAAK,QAAQ,IAAInE,CAAC,EACtBoE,EAAInE,EAAM,IAAID,CAAC,EACjBmE,IAAM,MAAQC,IAAM,KACtBjB,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAKkB,GAASF,EAAGC,EAAGF,CAAI,CAAC,CAErC,CACA,OAAO,IAAIhB,EAAO,KAAK,QAAQ,KAAM7C,EAAc,KAAK8C,CAAO,CAAC,CAClE,CACA,SAASe,EAAM,CACb,MAAMf,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EAC1BgB,IAAQ,KACVmC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAKmB,GAAatD,EAAKkD,CAAI,CAAC,CAExC,CACA,OAAO,IAAIhB,EAAO,KAAK,QAAQ,KAAMb,EAAW,KAAKc,CAAO,CAAC,CAC/D,CACA,WAAWI,EAAI,CACb,MAAMJ,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EAC1BgB,IAAQ,KACVmC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAKI,EAAGvC,CAAG,CAAC,CAExB,CACA,OAAO,IAAIkC,EAAO,KAAK,QAAQ,KAAM7C,EAAc,KAAK8C,CAAO,CAAC,CAClE,CACF,EACA,SAASc,GAAWM,EAAM1B,EAAS,CACjC,MAAM2B,EAAQC,GAAM,OAAOA,CAAC,EAAE,SAAS,EAAG,GAAG,EACvCC,EAAQD,GAAM,OAAOA,CAAC,EAAE,SAAS,EAAG,GAAG,EAC7C,OAAO5B,EAAQ,QAAQ,OAAQ6B,EAAKH,EAAK,YAAW,CAAE,CAAC,EAAE,QAAQ,KAAMC,EAAKD,EAAK,SAAQ,EAAK,CAAC,CAAC,EAAE,QAAQ,KAAMC,EAAKD,EAAK,QAAO,CAAE,CAAC,EAAE,QAAQ,KAAMC,EAAKD,EAAK,SAAQ,CAAE,CAAC,EAAE,QAAQ,KAAMC,EAAKD,EAAK,YAAY,CAAC,EAAE,QAAQ,KAAMC,EAAKD,EAAK,WAAU,CAAE,CAAC,CACzP,CACA,SAASF,GAASF,EAAGC,EAAGF,EAAM,CAC5B,MAAMS,EAAMR,EAAE,QAAO,EAEfS,EADMR,EAAE,QAAO,EACAO,EACrB,OAAQT,EAAI,CACV,IAAK,SACH,OAAOU,EAAS,IAClB,IAAK,SACH,OAAOA,GAAU,IAAM,IACzB,IAAK,OACH,OAAOA,GAAU,IAAM,GAAK,IAC9B,IAAK,MACH,OAAOA,GAAU,IAAM,GAAK,GAAK,IACnC,IAAK,QAAS,CACZ,MAAMC,EAAWT,EAAE,YAAW,EAAKD,EAAE,YAAW,EAC1CW,EAAYV,EAAE,SAAQ,EAAKD,EAAE,SAAQ,EACrCY,GAAWX,EAAE,QAAO,EAAKD,EAAE,QAAO,GAAM,GAC9C,OAAOU,EAAW,GAAKC,EAAYC,CACrC,CACA,IAAK,OAAQ,CACX,MAAMF,EAAWT,EAAE,YAAW,EAAKD,EAAE,YAAW,EAC1Ca,GAAaZ,EAAE,SAAQ,EAAKD,EAAE,SAAQ,GAAM,GAC5CY,GAAWX,EAAE,QAAO,EAAKD,EAAE,QAAO,GAAM,IAC9C,OAAOU,EAAWG,EAAYD,CAChC,CACJ,CACA,CACA,SAAST,GAAaC,EAAML,EAAM,CAChC,OAAQA,EAAI,CACV,IAAK,OACH,OAAO,IAAI,KAAKK,EAAK,YAAW,EAAI,EAAG,CAAC,EAC1C,IAAK,QACH,OAAO,IAAI,KAAKA,EAAK,YAAW,EAAIA,EAAK,SAAQ,EAAI,CAAC,EACxD,IAAK,MACH,OAAO,IAAI,KAAKA,EAAK,YAAW,EAAIA,EAAK,SAAQ,EAAIA,EAAK,SAAS,EACrE,IAAK,OACH,OAAO,IAAI,KACTA,EAAK,YAAW,EAChBA,EAAK,SAAQ,EACbA,EAAK,QAAO,EACZA,EAAK,SAAQ,CACrB,EACI,IAAK,SACH,OAAO,IAAI,KACTA,EAAK,YAAW,EAChBA,EAAK,SAAQ,EACbA,EAAK,QAAO,EACZA,EAAK,SAAQ,EACbA,EAAK,WAAU,CACvB,EACI,IAAK,SACH,OAAO,IAAI,KACTA,EAAK,YAAW,EAChBA,EAAK,SAAQ,EACbA,EAAK,QAAO,EACZA,EAAK,SAAQ,EACbA,EAAK,WAAU,EACfA,EAAK,WAAU,CACvB,CACA,CACA,CAGA,IAAIU,GACJ,SAASC,GAA0BC,EAAS,CAC1CF,GAAmBE,CACrB,CACG,IAACjC,EAAS,MAAMkC,CAAQ,CACzB,MACA,QACA,YAAYC,EAAMpG,EAAQ,CACxB,KAAK,MAAQoG,EACb,KAAK,QAAUpG,CACjB,CACA,IAAI,MAAO,CACT,OAAO,KAAK,KACd,CACA,IAAI,OAAQ,CACV,OAAO,KAAK,QAAQ,KACtB,CACA,IAAI,QAAS,CACX,OAAO,KAAK,QAAQ,MACtB,CACA,IAAI,WAAY,CACd,OAAO,KAAK,QAAQ,SACtB,CACA,IAAI,QAAS,CACX,OAAO,KAAK,OACd,CACA,IAAI,KAAM,CACR,OAAO,IAAIwD,GAAe,IAAI,CAChC,CACA,IAAI,IAAK,CACP,OAAO,IAAIkB,GAAa,IAAI,CAC9B,CACA,IAAI/D,EAAO,CACT,OAAO,KAAK,QAAQ,IAAIA,CAAK,CAC/B,CACA,SAAU,CACR,MAAMM,EAAS,CAAA,EACf,QAASF,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IACvCE,EAAO,KAAK,KAAK,QAAQ,IAAIF,CAAC,CAAC,EAEjC,OAAOE,CACT,CAEA,KAAM,CAEJ,OADa,KAAK,iBAAgB,EACtB,IAAG,CACjB,CACA,MAAO,CAEL,OADa,KAAK,iBAAgB,EACtB,KAAI,CAClB,CACA,KAAM,CAEJ,OADa,KAAK,iBAAgB,EACtB,IAAG,CACjB,CACA,KAAM,CAEJ,OADa,KAAK,iBAAgB,EACtB,IAAG,CACjB,CACA,KAAM,CACJ,MAAM8C,EAAO,KAAK,iBAAgB,EAC5BsC,EAAItC,EAAK,KAAI,EACnB,GAAIsC,IAAM,KAAM,OAAO,KACvB,MAAMvE,EAAaiC,EAAK,OAASA,EAAK,UACtC,GAAIjC,EAAa,EAAG,OAAO,KAC3B,IAAIwE,EAAY,EAChB,QAASvF,EAAI,EAAGA,EAAIgD,EAAK,OAAQhD,IAAK,CACpC,MAAMgB,EAAMgC,EAAK,IAAIhD,CAAC,EACtB,GAAIgB,IAAQ,KAAM,CAChB,MAAM4C,EAAO5C,EAAMsE,EACnBC,GAAa3B,EAAOA,CACtB,CACF,CACA,OAAO,KAAK,KAAK2B,GAAaxE,EAAa,EAAE,CAC/C,CACA,QAAS,CACP,MAAMiC,EAAO,KAAK,iBAAgB,EAC5B/B,EAAS,CAAA,EACf,QAASjB,EAAI,EAAGA,EAAIgD,EAAK,OAAQhD,IAAK,CACpC,MAAMgB,EAAMgC,EAAK,IAAIhD,CAAC,EAClBgB,IAAQ,MACVC,EAAO,KAAKD,CAAG,CAEnB,CACA,GAAIC,EAAO,SAAW,EAAG,OAAO,KAChCA,EAAO,KAAK,CAACkD,EAAGC,IAAMD,EAAIC,CAAC,EAC3B,MAAMoB,EAAM,KAAK,MAAMvE,EAAO,OAAS,CAAC,EACxC,OAAIA,EAAO,OAAS,IAAM,GAChBA,EAAOuE,EAAM,CAAC,EAAIvE,EAAOuE,CAAG,GAAK,EAEpCvE,EAAOuE,CAAG,CACnB,CACA,QAAQC,EAAKC,EAAM,CACjB,MAAM1C,EAAO,KAAK,iBAAgB,EAC5BG,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAIgD,EAAK,OAAQhD,IAAK,CACpC,MAAMgB,EAAMgC,EAAK,IAAIhD,CAAC,EAClBgB,IAAQ,KACVmC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAKnC,GAAOyE,GAAOzE,GAAO0E,CAAI,CAE1C,CACA,OAAO,IAAIN,EAAQ,KAAK,MAAOjD,EAAc,KAAKgB,CAAO,CAAC,CAC5D,CACA,QAAS,CACP,MAAMH,EAAO,KAAK,iBAAgB,EAC5BG,EAAU,CAAA,EAChB,IAAIwC,EAAU,EACd,QAAS3F,EAAI,EAAGA,EAAIgD,EAAK,OAAQhD,IAAK,CACpC,MAAMgB,EAAMgC,EAAK,IAAIhD,CAAC,EAClBgB,IAAQ,KACVmC,EAAQ,KAAK,IAAI,GAEjBwC,GAAW3E,EACXmC,EAAQ,KAAKwC,CAAO,EAExB,CACA,OAAO,IAAIP,EAAQ,KAAK,MAAO/E,EAAc,KAAK8C,CAAO,CAAC,CAC5D,CACA,KAAM,CACJ,MAAMH,EAAO,KAAK,iBAAgB,EAC5BG,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAIgD,EAAK,OAAQhD,IAAK,CACpC,MAAMgB,EAAMgC,EAAK,IAAIhD,CAAC,EAClBgB,IAAQ,KACVmC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAK,KAAK,IAAInC,CAAG,CAAC,CAE9B,CACA,OAAO,IAAIoE,EAAQ,KAAK,MAAO/E,EAAc,KAAK8C,CAAO,CAAC,CAC5D,CACA,MAAMyC,EAAW,EAAG,CAClB,MAAM5C,EAAO,KAAK,iBAAgB,EAC5B6C,EAAS,KAAK,IAAI,GAAID,CAAQ,EAC9BzC,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAIgD,EAAK,OAAQhD,IAAK,CACpC,MAAMgB,EAAMgC,EAAK,IAAIhD,CAAC,EAClBgB,IAAQ,KACVmC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAK,KAAK,MAAMnC,EAAM6E,CAAM,EAAIA,CAAM,CAElD,CACA,OAAO,IAAIT,EAAQ,KAAK,MAAO/E,EAAc,KAAK8C,CAAO,CAAC,CAC5D,CAEA,GAAGpD,EAAO,CACR,OAAO,KAAK,eAAeA,EAAO,CAACoE,EAAGC,IAAMD,IAAMC,CAAC,CACrD,CACA,IAAIrE,EAAO,CACT,OAAO,KAAK,eAAeA,EAAO,CAACoE,EAAGC,IAAMD,IAAMC,CAAC,CACrD,CACA,GAAGrE,EAAO,CACR,OAAO,KAAK,eAAeA,EAAO,CAACoE,EAAGC,IAAMD,EAAIC,CAAC,CACnD,CACA,IAAIrE,EAAO,CACT,OAAO,KAAK,eAAeA,EAAO,CAACoE,EAAGC,IAAMD,GAAKC,CAAC,CACpD,CACA,GAAGrE,EAAO,CACR,OAAO,KAAK,eAAeA,EAAO,CAACoE,EAAGC,IAAMD,EAAIC,CAAC,CACnD,CACA,IAAIrE,EAAO,CACT,OAAO,KAAK,eAAeA,EAAO,CAACoE,EAAGC,IAAMD,GAAKC,CAAC,CACpD,CACA,KAAKnD,EAAQ,CACX,MAAM6E,EAAM,IAAI,IAAI7E,EAAO,IAAKE,GAAM,KAAK,cAAcA,CAAC,CAAC,CAAC,EACtDgC,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EAC1BgB,IAAQ,KACVmC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAK2C,EAAI,IAAI,KAAK,cAAc9E,CAAG,CAAC,CAAC,CAEjD,CACA,OAAO,IAAIoE,EAAQ,KAAK,MAAOjD,EAAc,KAAKgB,CAAO,CAAC,CAC5D,CACA,QAAS,CACP,MAAMA,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IACvCmD,EAAQ,KAAK,KAAK,QAAQ,IAAInD,CAAC,IAAM,IAAI,EAE3C,OAAO,IAAIoF,EAAQ,KAAK,MAAOjD,EAAc,KAAKgB,CAAO,CAAC,CAC5D,CACA,WAAY,CACV,MAAMA,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IACvCmD,EAAQ,KAAK,KAAK,QAAQ,IAAInD,CAAC,IAAM,IAAI,EAE3C,OAAO,IAAIoF,EAAQ,KAAK,MAAOjD,EAAc,KAAKgB,CAAO,CAAC,CAC5D,CACA,SAASpD,EAAO,CAEd,MAAMgG,EADS,KAAK,QAAO,EACL,IAAK5E,GAAMA,IAAM,KAAOpB,EAAQoB,CAAC,EACvD,OAAO,IAAIiE,EAAQ,KAAK,MAAO,KAAK,aAAaW,CAAM,CAAC,CAC1D,CACA,QAAS,CACP,MAAMC,EAAuB,IAAI,IAC3B/E,EAAS,CAAA,EACf,QAASjB,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EACxBiG,EAAMjF,IAAQ,KAAO,WAAa,OAAO,KAAK,cAAcA,CAAG,CAAC,EACjEgF,EAAK,IAAIC,CAAG,IACfD,EAAK,IAAIC,CAAG,EACZhF,EAAO,KAAKD,CAAG,EAEnB,CACA,OAAO,IAAIoE,EAAQ,KAAK,MAAO,KAAK,aAAanE,CAAM,CAAC,CAC1D,CACA,SAAU,CACR,MAAM+E,EAAuB,IAAI,IACjC,QAAShG,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EACxBiG,EAAMjF,IAAQ,KAAO,WAAa,OAAO,KAAK,cAAcA,CAAG,CAAC,EACtEgF,EAAK,IAAIC,CAAG,CACd,CACA,OAAOD,EAAK,IACd,CACA,aAAc,CACZ,GAAI,CAACf,GACH,MAAM,IAAIpG,EAAc,oBAA6C,kCAAkC,EAEzG,MAAMqH,EAAyB,IAAI,IAC7BC,EAAQ,CAAA,EACd,QAASnG,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EACxBiG,EAAMjF,IAAQ,KAAO,WAAa,OAAO,KAAK,cAAcA,CAAG,CAAC,EAChEoF,EAAQF,EAAO,IAAID,CAAG,EACxBG,EACFA,EAAM,SAENF,EAAO,IAAID,EAAK,CAAE,MAAOjF,EAAK,MAAO,EAAG,EACxCmF,EAAM,KAAKF,CAAG,EAElB,CACAE,EAAM,KAAK,CAAChC,EAAGC,IAAM8B,EAAO,IAAI9B,CAAC,EAAE,MAAQ8B,EAAO,IAAI/B,CAAC,EAAE,KAAK,EAC9D,MAAMlD,EAAS,CAAA,EACToF,EAAc,CAAA,EACpB,UAAWJ,KAAOE,EAAO,CACvB,MAAMC,EAAQF,EAAO,IAAID,CAAG,EAC5BhF,EAAO,KAAKmF,EAAM,KAAK,EACvBC,EAAY,KAAKD,EAAM,KAAK,CAC9B,CACA,MAAME,EAAW,KAAK,aAAarF,CAAM,EACnCsF,EAAWlG,EAAc,KAAKgG,CAAW,EACzCG,EAA0B,IAAI,IACpC,OAAAA,EAAQ,IAAI,QAASF,CAAQ,EAC7BE,EAAQ,IAAI,QAASD,CAAQ,EACtBtB,GAAiBuB,EAAS,CAAC,QAAS,OAAO,CAAC,CACrD,CACA,KAAKC,EAAO,CAEV,MAAMC,EADS,KAAK,QAAO,EACF,IAAKvF,GACxBA,IAAM,KAAa,KAChB,KAAK,WAAWA,EAAGsF,CAAK,CAChC,EACKzD,EAAO2D,GAAqBF,EAAOC,CAAS,EAClD,OAAO,IAAItB,EAAQ,KAAK,MAAOpC,CAAI,CACrC,CACA,MAAMO,EAAI,CACR,MAAMJ,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IACvCmD,EAAQ,KAAKI,EAAG,KAAK,QAAQ,IAAIvD,CAAC,CAAC,CAAC,EAEtC,IAAI4G,EAAc,MAClB,UAAWC,KAAK1D,EACd,GAAI0D,IAAM,KAAM,CACV,OAAOA,GAAM,SAAUD,EAAc,OAChC,OAAOC,GAAM,UAAWD,EAAc,OACtCC,aAAa,KAAMD,EAAc,OACrCA,EAAc,MACnB,KACF,CAEF,MAAM5D,EAAO2D,GAAqBC,EAAazD,CAAO,EACtD,OAAO,IAAIiC,EAAQ,KAAK,MAAOpC,CAAI,CACrC,CACA,kBAAmB,CACjB,GAAI,KAAK,mBAAmB3C,EAAe,OAAO,KAAK,QACvD,GAAI,KAAK,mBAAmBe,GAAa,OAAO,KAAK,QACrD,MAAM,IAAIjC,GACR,0DAA0D,KAAK,KAAK,GAC1E,CACE,CACA,eAAeY,EAAO+G,EAAW,CAC/B,MAAM3D,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAAK,CAC5C,MAAMgB,EAAM,KAAK,QAAQ,IAAIhB,CAAC,EAC1BgB,IAAQ,KACVmC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAK2D,EAAU9F,EAAKjB,CAAK,CAAC,CAEtC,CACA,OAAO,IAAIqF,EAAQ,KAAK,MAAOjD,EAAc,KAAKgB,CAAO,CAAC,CAC5D,CACA,cAAcpD,EAAO,CACnB,OAAIA,aAAiB,KAAaA,EAAM,QAAO,EACxCA,CACT,CACA,aAAakB,EAAQ,CACnB,OAAQ,KAAK,QAAQ,MAAK,CACxB,IAAK,MACH,OAAOZ,EAAc,KAAKY,CAAM,EAClC,IAAK,MACH,OAAOG,GAAY,KAAKH,CAAM,EAChC,IAAK,OACH,OAAOK,EAAW,KAAKL,CAAM,EAC/B,IAAK,OACH,OAAOkB,EAAc,KAAKlB,CAAM,EAClC,IAAK,OACH,OAAOoB,EAAW,KAAKpB,CAAM,EAC/B,IAAK,SACH,OAAOsB,GAAa,KAAKtB,CAAM,EACjC,QACE,MAAM,IAAIpC,EACR,oBACA,sBAAsB,KAAK,QAAQ,KAAK,EAClD,CACA,CACE,CACA,WAAWkB,EAAOgH,EAAa,CAC7B,OAAQA,EAAW,CACjB,IAAK,MACL,IAAK,MACH,OAAI,OAAOhH,GAAU,SAAiBA,EAClC,OAAOA,GAAU,SAAiB,OAAOA,CAAK,EAC9C,OAAOA,GAAU,UAAkBA,EAAQ,EAAI,EAC/CA,aAAiB,KAAaA,EAAM,QAAO,EACxC,OAAOA,CAAK,EACrB,IAAK,OACH,OAAIA,aAAiB,KAAaA,EAAM,YAAW,EAC5C,OAAOA,CAAK,EACrB,IAAK,OACH,MAAO,EAAQA,EACjB,IAAK,OACH,OAAIA,aAAiB,KAAaA,EAC9B,OAAOA,GAAU,SAAiB,IAAI,KAAKA,CAAK,EAChD,OAAOA,GAAU,SAAiB,IAAI,KAAKA,CAAK,EAC7C,IAAI,KAAK,OAAOA,CAAK,CAAC,EAC/B,QACE,MAAM,IAAIZ,GACR,yBAAyB4H,CAAW,GAC9C,CACA,CACE,CACF,EACA,SAASJ,GAAqBF,EAAOxF,EAAQ,CAC3C,OAAQwF,EAAK,CACX,IAAK,MACH,OAAOpG,EAAc,KAAKY,CAAM,EAClC,IAAK,MACH,OAAOG,GAAY,KAAKH,CAAM,EAChC,IAAK,OACH,OAAOK,EAAW,KAAKL,CAAM,EAC/B,IAAK,OACH,OAAOkB,EAAc,KAAKlB,CAAM,EAClC,IAAK,OACH,OAAOoB,EAAW,KAAKpB,CAAM,EAC/B,IAAK,SACH,OAAOsB,GAAa,KAAKtB,CAAM,EACjC,QACE,MAAM,IAAIpC,EACR,oBACA,8CAA8C4H,CAAK,EAC3D,CACA,CACA,CAGG,IAACO,EAAO,MAAMC,EAAM,CACrB,GAAG5B,EAAM,CACP,OAAO,IAAI6B,GAAU,KAAM7B,CAAI,CACjC,CAEA,IAAIpF,EAAO,CACT,OAAO,IAAIkH,GAAe,KAAMC,GAAQnH,CAAK,EAAG,KAAK,CACvD,CACA,IAAIA,EAAO,CACT,OAAO,IAAIkH,GAAe,KAAMC,GAAQnH,CAAK,EAAG,KAAK,CACvD,CACA,IAAIA,EAAO,CACT,OAAO,IAAIkH,GAAe,KAAMC,GAAQnH,CAAK,EAAG,KAAK,CACvD,CACA,IAAIA,EAAO,CACT,OAAO,IAAIkH,GAAe,KAAMC,GAAQnH,CAAK,EAAG,KAAK,CACvD,CACA,IAAIA,EAAO,CACT,OAAO,IAAIkH,GAAe,KAAMC,GAAQnH,CAAK,EAAG,KAAK,CACvD,CACA,IAAIA,EAAO,CACT,OAAO,IAAIkH,GAAe,KAAMC,GAAQnH,CAAK,EAAG,KAAK,CACvD,CAEA,GAAGA,EAAO,CACR,OAAO,IAAIoH,GAAe,KAAMC,GAAKrH,CAAK,EAAG,IAAI,CACnD,CACA,IAAIA,EAAO,CACT,OAAO,IAAIoH,GAAe,KAAMC,GAAKrH,CAAK,EAAG,KAAK,CACpD,CACA,GAAGA,EAAO,CACR,OAAO,IAAIoH,GAAe,KAAMC,GAAKrH,CAAK,EAAG,IAAI,CACnD,CACA,IAAIA,EAAO,CACT,OAAO,IAAIoH,GAAe,KAAMC,GAAKrH,CAAK,EAAG,KAAK,CACpD,CACA,GAAGA,EAAO,CACR,OAAO,IAAIoH,GAAe,KAAMC,GAAKrH,CAAK,EAAG,IAAI,CACnD,CACA,IAAIA,EAAO,CACT,OAAO,IAAIoH,GAAe,KAAMC,GAAKrH,CAAK,EAAG,KAAK,CACpD,CAEA,IAAIA,EAAO,CACT,OAAO,IAAIsH,GAAY,KAAMC,GAASvH,CAAK,EAAG,KAAK,CACrD,CACA,GAAGA,EAAO,CACR,OAAO,IAAIsH,GAAY,KAAMC,GAASvH,CAAK,EAAG,IAAI,CACpD,CACA,KAAM,CACJ,OAAO,IAAIwH,GAAQ,IAAI,CACzB,CAEA,gBAAiB,CACf,MAAMC,EAAO,KAAK,aAClB,GAAIA,EAAK,SAAW,EAClB,MAAM,IAAI,MAAM,yCAAyC,EAE3D,OAAOA,EAAK,CAAC,CACf,CACA,KAAM,CACJ,OAAO,IAAIC,GAAW,KAAK,gBAAgB,CAC7C,CACA,MAAO,CACL,OAAO,IAAIC,GAAY,KAAK,gBAAgB,CAC9C,CACA,OAAQ,CACN,OAAO,IAAIC,GAAa,KAAK,gBAAgB,CAC/C,CACA,eAAgB,CACd,OAAO,IAAIC,GAAqB,KAAK,gBAAgB,CACvD,CACA,KAAM,CACJ,OAAO,IAAIC,GAAW,KAAK,gBAAgB,CAC7C,CACA,KAAM,CACJ,OAAO,IAAIC,GAAW,KAAK,gBAAgB,CAC7C,CACA,KAAM,CACJ,OAAO,IAAIC,GAAW,KAAK,gBAAgB,CAC7C,CACA,OAAQ,CACN,OAAO,IAAIC,GAAa,KAAK,gBAAgB,CAC/C,CACA,MAAO,CACL,OAAO,IAAIC,GAAY,KAAK,gBAAgB,CAC9C,CACA,MAAO,CACL,OAAO,IAAIC,GAAY,KAAK,gBAAgB,CAC9C,CACA,MAAO,CACL,OAAO,IAAIC,GAAY,KAAK,gBAAgB,CAC9C,CAEA,YAAYC,EAAQ,CAClB,MAAMC,EAAQD,EAAO,IAAKE,GAAMA,aAAavB,GAAQuB,EAAI,IAAIC,EAAYD,CAAC,CAAC,EAC3E,OAAO,IAAIE,GAAa,CAAC,KAAM,GAAGH,CAAK,CAAC,CAC1C,CACA,SAASxI,EAAO,CACd,MAAM4I,EAAU5I,aAAiBkH,GAAQlH,EAAQ,IAAI0I,EAAY1I,CAAK,EACtE,OAAO,IAAI6I,GAAa,KAAMD,CAAO,CACvC,CACA,QAAS,CACP,OAAO,IAAIE,GAAW,IAAI,CAC5B,CACA,WAAY,CACV,OAAO,IAAIC,GAAc,IAAI,CAC/B,CACF,EACI5B,GAAY,KAAM,CACpB,KACA,KACA,YAAY6B,EAAM1D,EAAM,CACtB,KAAK,KAAO0D,EACZ,KAAK,KAAO1D,CACd,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,KAAK,YACnB,CACA,UAAW,CACT,MAAO,GAAG,KAAK,KAAK,SAAQ,CAAE,OAAO,KAAK,IAAI,EAChD,CACF,EACA,SAASiC,GAAKvH,EAAO,CACnB,OAAIA,aAAiBiH,EAAajH,EAC3B,IAAI0I,EAAY1I,CAAK,CAC9B,CACA,SAASqH,GAAQrH,EAAO,CACtB,OAAIA,aAAiBiH,EAAajH,EAC3B,IAAI0I,EAAY1I,CAAK,CAC9B,CACA,SAASyH,GAASzH,EAAO,CACvB,OAAIA,aAAiBiH,EAAajH,EAC3B,IAAI0I,EAAY1I,CAAK,CAC9B,CACA,SAASiJ,GAAqBvC,EAAOxF,EAAQ,CAC3C,OAAQwF,EAAK,CACX,IAAK,MACH,OAAOpG,EAAc,KAAKY,CAAM,EAClC,IAAK,OACH,OAAOK,EAAW,KAAKL,CAAM,EAC/B,IAAK,OACH,OAAOkB,EAAc,KAAKlB,CAAM,EAClC,IAAK,OACH,OAAOoB,EAAW,KAAKpB,CAAM,EAC/B,QACE,OAAOZ,EAAc,KAAKY,CAAM,CACtC,CACA,CACA,SAASgI,GAAmBlJ,EAAO,CACjC,OAAI,OAAOA,GAAU,SAAiB,MAClC,OAAOA,GAAU,SAAiB,OAClC,OAAOA,GAAU,UAAkB,OACnCA,aAAiB,KAAa,OAC3B,KACT,CACA,IAAI0I,EAAc,cAAczB,CAAK,CACnC,OACA,YAAYjH,EAAO,CACjB,MAAK,EACL,KAAK,OAASA,CAChB,CACA,IAAI,cAAe,CACjB,MAAO,CAAA,CACT,CACA,UAAW,CACT,OAAI,OAAO,KAAK,QAAW,SAAiB,IAAI,KAAK,MAAM,IACvD,KAAK,kBAAkB,KAAa,KAAK,OAAO,YAAW,EACxD,OAAO,KAAK,MAAM,CAC3B,CACA,SAASmJ,EAAK,CACZ,MAAMzH,EAAMyH,EAAI,OACVjI,EAAS,IAAI,MAAMQ,CAAG,EAAE,KAAK,KAAK,MAAM,EACxCgF,EAAQwC,GAAmB,KAAK,MAAM,EACtCjG,EAAOgG,GAAqBvC,EAAOxF,CAAM,EAC/C,OAAO,IAAIiC,EAAO,UAAWF,CAAI,CACnC,CACF,EACImG,GAAa,cAAcnC,CAAK,CAClC,MACA,YAAY3B,EAAM,CAChB,MAAK,EACL,KAAK,MAAQA,CACf,CACA,IAAI,cAAe,CACjB,MAAO,CAAC,KAAK,KAAK,CACpB,CACA,UAAW,CACT,OAAO,KAAK,KACd,CACA,SAAS6D,EAAK,CACZ,OAAOA,EAAI,IAAI,KAAK,KAAK,CAC3B,CACF,EACIE,GAAmB,CACrB,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACP,EACIjC,GAAiB,cAAcH,CAAK,CACtC,MACA,OACA,IACA,YAAYqC,EAAMC,EAAOC,EAAI,CAC3B,MAAK,EACL,KAAK,MAAQF,EACb,KAAK,OAASC,EACd,KAAK,IAAMC,CACb,CACA,IAAI,cAAe,CACjB,MAAO,CAAC,GAAmB,IAAI,IAAI,CAAC,GAAG,KAAK,MAAM,aAAc,GAAG,KAAK,OAAO,YAAY,CAAC,CAAC,CAC/F,CACA,UAAW,CACT,MAAO,IAAI,KAAK,MAAM,SAAQ,CAAE,IAAIH,GAAiB,KAAK,GAAG,CAAC,IAAI,KAAK,OAAO,SAAQ,CAAE,GAC1F,CACA,SAASF,EAAK,CACZ,MAAMM,EAAa,KAAK,MAAM,SAASN,CAAG,EACpCO,EAAc,KAAK,OAAO,SAASP,CAAG,EACtCzH,EAAM+H,EAAW,OACjBrG,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmE,EAAIqF,EAAW,IAAIxJ,CAAC,EACpBoE,EAAIqF,EAAY,IAAIzJ,CAAC,EACvBmE,IAAM,MAAQC,IAAM,KACtBjB,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAKuG,GAAavF,EAAGC,EAAG,KAAK,GAAG,CAAC,CAE7C,CACA,OAAO,IAAIlB,EAAO,GAAI7C,EAAc,KAAK8C,CAAO,CAAC,CACnD,CACF,EACA,SAASuG,GAAavF,EAAGC,EAAGmF,EAAI,CAC9B,OAAQA,EAAE,CACR,IAAK,MACH,OAAOpF,EAAIC,EACb,IAAK,MACH,OAAOD,EAAIC,EACb,IAAK,MACH,OAAOD,EAAIC,EACb,IAAK,MACH,OAAOD,EAAIC,EACb,IAAK,MACH,OAAOD,EAAIC,EACb,IAAK,MACH,OAAO,KAAK,IAAID,EAAGC,CAAC,CAC1B,CACA,CACA,IAAIuF,GAAiB,CACnB,GAAI,KACJ,IAAK,KACL,GAAI,IACJ,IAAK,KACL,GAAI,IACJ,IAAK,IACP,EACItC,GAAiB,cAAcL,CAAK,CACtC,MACA,OACA,IACA,YAAYqC,EAAMC,EAAOC,EAAI,CAC3B,MAAK,EACL,KAAK,MAAQF,EACb,KAAK,OAASC,EACd,KAAK,IAAMC,CACb,CACA,IAAI,cAAe,CACjB,MAAO,CAAC,GAAmB,IAAI,IAAI,CAAC,GAAG,KAAK,MAAM,aAAc,GAAG,KAAK,OAAO,YAAY,CAAC,CAAC,CAC/F,CACA,UAAW,CACT,MAAO,IAAI,KAAK,MAAM,SAAQ,CAAE,IAAII,GAAe,KAAK,GAAG,CAAC,IAAI,KAAK,OAAO,SAAQ,CAAE,GACxF,CACA,SAAST,EAAK,CACZ,GAAI,KAAK,iBAAiBC,IAAc,KAAK,kBAAkBV,EAAa,CAC1E,MAAMmB,EAAa,KAAK,MAAM,aAAa,CAAC,EACtCC,EAAU,KAAK,OAAO,OACtBxG,EAAS6F,EAAI,IAAIU,CAAU,EAAE,OAC7BE,EAAOzG,EAAO,OACd0G,EAAW,IAAI,MAAMD,CAAI,EAC/B,QAAS9J,EAAI,EAAGA,EAAI8J,EAAM9J,IAAK,CAC7B,MAAM,EAAIqD,EAAO,IAAIrD,CAAC,EAClB,IAAM,MAAQ6J,IAAY,KAC5BE,EAAS/J,CAAC,EAAI,KAEd+J,EAAS/J,CAAC,EAAIgK,GAAW,EAAGH,EAAS,KAAK,GAAG,CAEjD,CACA,OAAO,IAAI3G,EAAO,GAAIf,EAAc,KAAK4H,CAAQ,CAAC,CACpD,CACA,GAAI,KAAK,iBAAiBtB,GAAe,KAAK,kBAAkBU,GAAY,CAC1E,MAAMU,EAAU,KAAK,MAAM,OACrBD,EAAa,KAAK,OAAO,aAAa,CAAC,EACvCvG,EAAS6F,EAAI,IAAIU,CAAU,EAAE,OAC7BE,EAAOzG,EAAO,OACd0G,EAAW,IAAI,MAAMD,CAAI,EAC/B,QAAS9J,EAAI,EAAGA,EAAI8J,EAAM9J,IAAK,CAC7B,MAAMoE,EAAIf,EAAO,IAAIrD,CAAC,EAClB6J,IAAY,MAAQzF,IAAM,KAC5B2F,EAAS/J,CAAC,EAAI,KAEd+J,EAAS/J,CAAC,EAAIgK,GAAWH,EAASzF,EAAG,KAAK,GAAG,CAEjD,CACA,OAAO,IAAIlB,EAAO,GAAIf,EAAc,KAAK4H,CAAQ,CAAC,CACpD,CACA,MAAMP,EAAa,KAAK,MAAM,SAASN,CAAG,EACpCO,EAAc,KAAK,OAAO,SAASP,CAAG,EACtCzH,EAAM+H,EAAW,OACjBrG,EAAU,IAAI,MAAM1B,CAAG,EAC7B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmE,EAAIqF,EAAW,IAAIxJ,CAAC,EACpBoE,EAAIqF,EAAY,IAAIzJ,CAAC,EACvBmE,IAAM,MAAQC,IAAM,KACtBjB,EAAQnD,CAAC,EAAI,KAEbmD,EAAQnD,CAAC,EAAIgK,GAAW7F,EAAGC,EAAG,KAAK,GAAG,CAE1C,CACA,OAAO,IAAIlB,EAAO,GAAIf,EAAc,KAAKgB,CAAO,CAAC,CACnD,CACF,EACA,SAAS6G,GAAW7F,EAAGC,EAAGmF,EAAI,CAC5B,OAAQA,EAAE,CACR,IAAK,KACH,OAAOpF,IAAMC,EACf,IAAK,MACH,OAAOD,IAAMC,EACf,IAAK,KACH,OAAOD,EAAIC,EACb,IAAK,MACH,OAAOD,GAAKC,EACd,IAAK,KACH,OAAOD,EAAIC,EACb,IAAK,MACH,OAAOD,GAAKC,CAClB,CACA,CACA,IAAImD,GAAc,cAAcP,CAAK,CACnC,MACA,OACA,IACA,YAAYqC,EAAMC,EAAOC,EAAI,CAC3B,MAAK,EACL,KAAK,MAAQF,EACb,KAAK,OAASC,EACd,KAAK,IAAMC,CACb,CACA,IAAI,cAAe,CACjB,MAAO,CAAC,GAAmB,IAAI,IAAI,CAAC,GAAG,KAAK,MAAM,aAAc,GAAG,KAAK,OAAO,YAAY,CAAC,CAAC,CAC/F,CACA,UAAW,CACT,MAAO,IAAI,KAAK,MAAM,SAAQ,CAAE,IAAI,KAAK,IAAI,YAAW,CAAE,IAAI,KAAK,OAAO,SAAQ,CAAE,GACtF,CACA,SAASL,EAAK,CACZ,MAAMM,EAAa,KAAK,MAAM,SAASN,CAAG,EACpCO,EAAc,KAAK,OAAO,SAASP,CAAG,EACtCzH,EAAM+H,EAAW,OACjBrG,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmE,EAAIqF,EAAW,IAAIxJ,CAAC,EACpBoE,EAAIqF,EAAY,IAAIzJ,CAAC,EACvBmE,IAAM,MAAQC,IAAM,KACtBjB,EAAQ,KAAK,IAAI,EACR,KAAK,MAAQ,MACtBA,EAAQ,KAAKgB,GAAKC,CAAC,EAEnBjB,EAAQ,KAAKgB,GAAKC,CAAC,CAEvB,CACA,OAAO,IAAIlB,EAAO,GAAIf,EAAc,KAAKgB,CAAO,CAAC,CACnD,CACF,EACIsE,GAAU,cAAcT,CAAK,CAC/B,OACA,YAAYiD,EAAO,CACjB,MAAK,EACL,KAAK,OAASA,CAChB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,OAAO,YACrB,CACA,UAAW,CACT,MAAO,OAAO,KAAK,OAAO,SAAQ,CAAE,EACtC,CACA,SAASf,EAAK,CACZ,MAAMgB,EAAc,KAAK,OAAO,SAAShB,CAAG,EACtCzH,EAAMyI,EAAY,OAClB/G,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmB,EAAI+I,EAAY,IAAIlK,CAAC,EAC3BmD,EAAQ,KAAKhC,IAAM,KAAO,KAAO,CAACA,CAAC,CACrC,CACA,OAAO,IAAI+B,EAAO,GAAIf,EAAc,KAAKgB,CAAO,CAAC,CACnD,CACF,EACA,SAASgH,GAAI9E,EAAM,CACjB,OAAO,IAAI8D,GAAW9D,CAAI,CAC5B,CACA,SAAS+E,EAAIrK,EAAO,CAClB,OAAO,IAAI0I,EAAY1I,CAAK,CAC9B,CACA,SAASsK,GAAgBlJ,EAAG,CAC1B,OAAIA,aAAa,KAAa,SAASA,EAAE,QAAO,CAAE,GAC9C,OAAOA,GAAM,SAAiB,QAAQA,CAAC,GACvC,OAAOA,GAAM,SAAiB,QAAQA,CAAC,GACvC,OAAOA,GAAM,UAAkB,SAASA,CAAC,GACtC,UAAU,OAAOA,CAAC,CAAC,EAC5B,CACG,IAACmJ,GAAU,cAActD,CAAK,CAC/B,YACA,YAAY4C,EAAY,CACtB,MAAK,EACL,KAAK,YAAcA,CACrB,CACA,IAAI,cAAe,CACjB,MAAO,CAAC,KAAK,WAAW,CAC1B,CACA,UAAW,CACT,MAAO,GAAG,KAAK,QAAQ,IAAI,KAAK,WAAW,GAC7C,CACA,SAASV,EAAK,CAEZ,MAAMjI,EAAS,CADA,KAAK,cAAciI,CAAG,CACf,EAChBlG,EAAO3C,EAAc,KAAKY,CAAM,EACtC,OAAO,IAAIiC,EAAO,GAAIF,CAAI,CAC5B,CACA,cAAckG,EAAK,CACjB,MAAMxG,EAASwG,EAAI,IAAI,KAAK,WAAW,EACvC,OAAO,KAAK,eAAexG,EAAO,MAAM,CAC1C,CACF,EACIiF,GAAa,cAAc2C,EAAQ,CACrC,SAAW,MACX,eAAerL,EAAQ,CACrB,IAAI6B,EAAQ,EACZ,QAASd,EAAI,EAAGA,EAAIf,EAAO,OAAQe,IAAK,CACtC,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EAClBmB,IAAM,MAAQ,OAAOA,GAAM,WAC7BL,GAASK,EAEb,CACA,OAAOL,CACT,CACF,EACI8G,GAAc,cAAc0C,EAAQ,CACtC,SAAW,OACX,eAAerL,EAAQ,CACrB,IAAI6B,EAAQ,EACR3C,EAAQ,EACZ,QAAS6B,EAAI,EAAGA,EAAIf,EAAO,OAAQe,IAAK,CACtC,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EAClBmB,IAAM,MAAQ,OAAOA,GAAM,WAC7BL,GAASK,EACThD,IAEJ,CACA,OAAOA,IAAU,EAAI,KAAO2C,EAAQ3C,CACtC,CACF,EACI0J,GAAe,cAAcyC,EAAQ,CACvC,SAAW,QACX,eAAerL,EAAQ,CACrB,IAAId,EAAQ,EACZ,QAAS6B,EAAI,EAAGA,EAAIf,EAAO,OAAQe,IAC7Bf,EAAO,IAAIe,CAAC,IAAM,MACpB7B,IAGJ,OAAOA,CACT,CACF,EACI2J,GAAuB,cAAcwC,EAAQ,CAC/C,SAAW,iBACX,eAAerL,EAAQ,CACrB,MAAM+G,EAAuB,IAAI,IACjC,QAAShG,EAAI,EAAGA,EAAIf,EAAO,OAAQe,IAAK,CACtC,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EAClBmB,IAAM,MACR6E,EAAK,IAAIqE,GAAgBlJ,CAAC,CAAC,CAE/B,CACA,OAAO6E,EAAK,IACd,CACF,EACI+B,GAAa,cAAcuC,EAAQ,CACrC,SAAW,MACX,eAAerL,EAAQ,CACrB,IAAIiB,EAAS,KACb,QAASF,EAAI,EAAGA,EAAIf,EAAO,OAAQe,IAAK,CACtC,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EAClBmB,IAAM,MAAQ,OAAOA,GAAM,WACzBjB,IAAW,MAAQiB,EAAIjB,KACzBA,EAASiB,EAGf,CACA,OAAOjB,CACT,CACF,EACI8H,GAAa,cAAcsC,EAAQ,CACrC,SAAW,MACX,eAAerL,EAAQ,CACrB,IAAIiB,EAAS,KACb,QAASF,EAAI,EAAGA,EAAIf,EAAO,OAAQe,IAAK,CACtC,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EAClBmB,IAAM,MAAQ,OAAOA,GAAM,WACzBjB,IAAW,MAAQiB,EAAIjB,KACzBA,EAASiB,EAGf,CACA,OAAOjB,CACT,CACF,EACI+H,GAAa,cAAcqC,EAAQ,CACrC,SAAW,MACX,eAAerL,EAAQ,CACrB,MAAMgC,EAAS,CAAA,EACf,QAASjB,EAAI,EAAGA,EAAIf,EAAO,OAAQe,IAAK,CACtC,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EAClBmB,IAAM,MAAQ,OAAOA,GAAM,UAC7BF,EAAO,KAAKE,CAAC,CAEjB,CACA,GAAIF,EAAO,OAAS,EAAG,OAAO,KAC9B,MAAMsJ,EAAOtJ,EAAO,OAAO,CAACkD,EAAGC,IAAMD,EAAIC,EAAG,CAAC,EAAInD,EAAO,OAClDsE,EAAYtE,EAAO,OAAO,CAACuJ,EAAKrJ,IAAMqJ,GAAOrJ,EAAIoJ,IAAS,EAAG,CAAC,EACpE,OAAO,KAAK,KAAKhF,GAAatE,EAAO,OAAS,EAAE,CAClD,CACF,EACIiH,GAAe,cAAcoC,EAAQ,CACvC,SAAW,QACX,eAAerL,EAAQ,CACrB,QAASe,EAAI,EAAGA,EAAIf,EAAO,OAAQe,IAAK,CACtC,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EACtB,GAAImB,IAAM,KACR,OAAOA,CAEX,CACA,OAAO,IACT,CACF,EACIgH,GAAc,cAAcmC,EAAQ,CACtC,SAAW,OACX,eAAerL,EAAQ,CACrB,QAASe,EAAIf,EAAO,OAAS,EAAGe,GAAK,EAAGA,IAAK,CAC3C,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EACtB,GAAImB,IAAM,KACR,OAAOA,CAEX,CACA,OAAO,IACT,CACF,EACIiH,GAAc,cAAckC,EAAQ,CACtC,SAAW,OACX,eAAerL,EAAQ,CACrB,MAAMiB,EAAS,CAAA,EACf,QAASF,EAAI,EAAGA,EAAIf,EAAO,OAAQe,IAAK,CACtC,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EAClBmB,IAAM,MACRjB,EAAO,KAAKiB,CAAC,CAEjB,CACA,OAAOjB,CACT,CACF,EACImI,GAAc,cAAciC,EAAQ,CACtC,SAAW,OACX,eAAerL,EAAQ,CACrB,MAAMiH,EAAyB,IAAI,IACnC,QAASlG,EAAI,EAAGA,EAAIf,EAAO,OAAQe,IAAK,CACtC,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EACtB,GAAImB,IAAM,KAAM,CACd,MAAM8E,EAAMoE,GAAgBlJ,CAAC,EACvBiF,EAAQF,EAAO,IAAID,CAAG,EACxBG,EACFA,EAAM,QAENF,EAAO,IAAID,EAAK,CAAE,MAAO9E,EAAG,MAAO,EAAG,CAE1C,CACF,CACA,IAAIsJ,EAAO,KACPC,EAAY,EAChB,UAAWtE,KAASF,EAAO,SACrBE,EAAM,MAAQsE,IAChBD,EAAOrE,EAAM,MACbsE,EAAYtE,EAAM,OAGtB,OAAOqE,CACT,CACF,EACI/B,GAAe,cAAc1B,CAAK,CACpC,OACA,YAAYuB,EAAO,CACjB,MAAK,EACL,KAAK,OAASA,CAChB,CACA,IAAI,cAAe,CACjB,MAAMb,EAAuB,IAAI,IACjC,UAAWiD,KAAK,KAAK,OACnB,UAAWzI,KAAKyI,EAAE,aAChBjD,EAAK,IAAIxF,CAAC,EAGd,MAAO,CAAC,GAAGwF,CAAI,CACjB,CACA,UAAW,CACT,MAAO,YAAY,KAAK,OAAO,IAAK,GAAM,EAAE,SAAQ,CAAE,EAAE,KAAK,IAAI,CAAC,GACpE,CACA,SAASwB,EAAK,CACZ,MAAM0B,EAAY,KAAK,OAAO,IAAKD,GAAMA,EAAE,SAASzB,CAAG,CAAC,EAClDzH,EAAMmJ,EAAU,CAAC,EAAE,OACnBzH,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,IAAI6K,EAAQ,KACZ,UAAWhJ,KAAK+I,EAAW,CACzB,MAAMzJ,EAAIU,EAAE,IAAI7B,CAAC,EACjB,GAAImB,IAAM,KAAM,CACd0J,EAAQ1J,EACR,KACF,CACF,CACAgC,EAAQ,KAAK0H,CAAK,CACpB,CAEA,MAAMpE,EADcmE,EAAU,CAAC,EACL,OAAO,MAC3B5H,EAAOgG,GAAqBvC,EAAOtD,CAAO,EAChD,OAAO,IAAID,EAAO,GAAIF,CAAI,CAC5B,CACF,EACI4F,GAAe,cAAc5B,CAAK,CACpC,OACA,MACA,YAAYiD,EAAOa,EAAM,CACvB,MAAK,EACL,KAAK,OAASb,EACd,KAAK,MAAQa,CACf,CACA,IAAI,cAAe,CACjB,MAAO,CAAC,GAAmB,IAAI,IAAI,CAAC,GAAG,KAAK,OAAO,aAAc,GAAG,KAAK,MAAM,YAAY,CAAC,CAAC,CAC/F,CACA,UAAW,CACT,MAAO,YAAY,KAAK,OAAO,SAAQ,CAAE,KAAK,KAAK,MAAM,SAAQ,CAAE,GACrE,CACA,SAAS5B,EAAK,CACZ,MAAMgB,EAAc,KAAK,OAAO,SAAShB,CAAG,EACtC6B,EAAa,KAAK,MAAM,SAAS7B,CAAG,EACpCzH,EAAMyI,EAAY,OAClB/G,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmB,EAAI+I,EAAY,IAAIlK,CAAC,EAC3BmD,EAAQ,KAAKhC,IAAM,KAAOA,EAAI4J,EAAW,IAAI/K,CAAC,CAAC,CACjD,CACA,MAAMyG,EAAQyD,EAAY,OAAO,MAC3BlH,EAAOgG,GAAqBvC,EAAOtD,CAAO,EAChD,OAAO,IAAID,EAAO,GAAIF,CAAI,CAC5B,CACF,EACI6F,GAAa,cAAc7B,CAAK,CAClC,OACA,YAAYiD,EAAO,CACjB,MAAK,EACL,KAAK,OAASA,CAChB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,OAAO,YACrB,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,UAClC,CACA,SAASf,EAAK,CACZ,MAAMgB,EAAc,KAAK,OAAO,SAAShB,CAAG,EACtCzH,EAAMyI,EAAY,OAClB/G,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAIyB,EAAKzB,IACvBmD,EAAQ,KAAK+G,EAAY,IAAIlK,CAAC,IAAM,IAAI,EAE1C,OAAO,IAAIkD,EAAO,GAAIf,EAAc,KAAKgB,CAAO,CAAC,CACnD,CACF,EACI2F,GAAgB,cAAc9B,CAAK,CACrC,OACA,YAAYiD,EAAO,CACjB,MAAK,EACL,KAAK,OAASA,CAChB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,OAAO,YACrB,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,cAClC,CACA,SAASf,EAAK,CACZ,MAAMgB,EAAc,KAAK,OAAO,SAAShB,CAAG,EACtCzH,EAAMyI,EAAY,OAClB/G,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAIyB,EAAKzB,IACvBmD,EAAQ,KAAK+G,EAAY,IAAIlK,CAAC,IAAM,IAAI,EAE1C,OAAO,IAAIkD,EAAO,GAAIf,EAAc,KAAKgB,CAAO,CAAC,CACnD,CACF,EAGI6H,GAAsB,CAAC,GAAI,OAAQ,OAAQ,KAAM,MAAO,MAAO,MAAO,OAAQ,MAAM,EACxF,SAASC,GAASC,EAASC,EAAU,GAAI,CACvC,MAAMC,EAAQC,GAAWH,EAASC,CAAO,EACzC,GAAIC,EAAM,SAAW,EACnB,MAAO,CAAE,OAAQ,CAAA,EAAI,QAAS,CAAA,EAAI,cAAe,EAAE,EAErD,MAAME,EAAYH,EAAQ,WAAaI,GAAgBH,EAAM,MAAM,EAAG,EAAE,CAAC,EACnEI,EAAYL,EAAQ,YAAc,GAClCM,EAAa,IAAI,IAAIN,EAAQ,YAAcH,EAAmB,EAC9DU,EAAUN,EAAM,IAAKO,GAASC,GAAUD,EAAML,CAAS,CAAC,EAC9D,IAAIO,EAAY,EACZV,EAAQ,UAAYA,EAAQ,SAAW,IACzCU,EAAYV,EAAQ,UAEtB,IAAIW,EACAC,EACJ,GAAIZ,EAAQ,OACVW,EAASX,EAAQ,OACjBY,EAAWF,GAAaL,EAAY,EAAI,WAC/BA,GAAaK,EAAYH,EAAQ,OAC1CI,EAASJ,EAAQG,CAAS,EAAE,IAAKG,GAAMA,EAAE,MAAM,EAC/CD,EAAWF,EAAY,MAClB,CACL,MAAMI,EAAWP,EAAQG,CAAS,EAClC,GAAI,CAACI,EACH,MAAO,CAAE,OAAQ,CAAA,EAAI,QAAS,CAAA,EAAI,cAAe,EAAE,EAErDH,EAASG,EAAS,IAAI,CAAC,EAAGjM,IAAM,UAAUA,CAAC,EAAE,EAC7C+L,EAAWF,CACb,CACA,IAAIK,EAASR,EAAQ,OACjBP,EAAQ,QAAU,QAAUA,EAAQ,OAAS,IAC/Ce,EAAS,KAAK,IAAIA,EAAQH,EAAWZ,EAAQ,KAAK,GAEpD,MAAMgB,EAAkBhB,EAAQ,QAAU,IAAI,IAAIA,EAAQ,OAAO,EAAI,KAC/D3E,EAAU,CAAA,EACV4F,EAAe,CAAA,EACrB,UAAW/G,KAAQyG,EACbK,GAAmB,CAACA,EAAgB,IAAI9G,CAAI,IAChD+G,EAAa,KAAK/G,CAAI,EACtBmB,EAAQnB,CAAI,EAAI,CAAA,GAElB,MAAMgH,EAAiC,IAAI,IAC3C,QAASrM,EAAI,EAAGA,EAAI8L,EAAO,OAAQ9L,IAAK,CACtC,MAAMqF,EAAOyG,EAAO9L,CAAC,EACjBmM,GAAmB,CAACA,EAAgB,IAAI9G,CAAI,GAChDgH,EAAe,IAAIrM,EAAGqF,CAAI,CAC5B,CACA,QAASwB,EAAIkF,EAAUlF,EAAIqF,EAAQrF,IAAK,CACtC,MAAMyF,EAAMZ,EAAQ7E,CAAC,EACrB,GAAKyF,EACL,SAAW,CAACC,EAAQC,CAAO,IAAKH,EAAgB,CAC9C,MAAMI,EAAMF,EAASD,EAAI,OAASA,EAAIC,CAAM,EAAI,GAC1CxM,EAAQ0L,EAAW,IAAIgB,CAAG,EAAI,KAAOA,EAC3CjG,EAAQgG,CAAO,EAAE,KAAKzM,CAAK,CAC7B,CACF,CACA,MAAM2M,EAAgBC,GAAiBnG,EAAS4F,EAAcjB,CAAO,EACrE,MAAO,CAAE,OAAQiB,EAAc,QAAA5F,EAAS,cAAAkG,CAAa,CACvD,CACA,SAASrB,GAAWH,EAASC,EAAS,CACpC,MAAMyB,EAAUzB,EAAQ,QAClBC,EAAQ,CAAA,EACd,IAAIyB,EAAU,GACVC,EAAW,GACf,QAAS,EAAI,EAAG,EAAI5B,EAAQ,OAAQ,IAAK,CACvC,MAAM6B,EAAK7B,EAAQ,CAAC,EAChB6B,IAAO,IACLD,GAAY,EAAI,EAAI5B,EAAQ,QAAUA,EAAQ,EAAI,CAAC,IAAM,KAC3D2B,GAAW,KACX,MAEAC,EAAW,CAACA,EACZD,GAAWE,IAEHA,IAAO;AAAA,GAAQA,IAAO,OAAS,CAACD,GACtCC,IAAO,MAAQ,EAAI,EAAI7B,EAAQ,QAAUA,EAAQ,EAAI,CAAC,IAAM;AAAA,GAC9D,KAEE2B,EAAQ,OAAS,GAAKzB,EAAM,OAAS,KACnC,CAACwB,GAAW,CAACC,EAAQ,UAAS,EAAG,WAAWD,CAAO,IACrDxB,EAAM,KAAKyB,CAAO,EAGtBA,EAAU,IAEVA,GAAWE,CAEf,CACA,OAAIF,EAAQ,OAAS,IACf,CAACD,GAAW,CAACC,EAAQ,UAAS,EAAG,WAAWD,CAAO,IACrDxB,EAAM,KAAKyB,CAAO,EAGfzB,CACT,CACA,SAASQ,GAAUD,EAAML,EAAW,CAClC,MAAM0B,EAAS,CAAA,EACf,IAAIH,EAAU,GACVC,EAAW,GACX9M,EAAI,EACR,KAAOA,EAAI2L,EAAK,QAAQ,CACtB,MAAMoB,EAAKpB,EAAK3L,CAAC,EACb8M,EACEC,IAAO,IACL/M,EAAI,EAAI2L,EAAK,QAAUA,EAAK3L,EAAI,CAAC,IAAM,KACzC6M,GAAW,IACX7M,GAAK,IAEL8M,EAAW,GACX9M,MAGF6M,GAAWE,EACX/M,KAGE+M,IAAO,KAAOF,EAAQ,SAAW,GACnCC,EAAW,GACX9M,KACS2L,EAAK,WAAWL,EAAWtL,CAAC,GACrCgN,EAAO,KAAKH,CAAO,EACnBA,EAAU,GACV7M,GAAKsL,EAAU,SAEfuB,GAAWE,EACX/M,IAGN,CACA,GAAI8M,EACF,MAAM,IAAIzN,GAAW,kCAAkC,EAEzD,OAAA2N,EAAO,KAAKH,CAAO,EACZG,CACT,CACA,SAASzB,GAAgBH,EAAO,CAC9B,MAAM6B,EAAa,CAAC,IAAK,IAAK,IAAK,GAAG,EACtC,IAAIC,EAAgB,IAChBC,EAAY,GAChB,UAAWC,KAASH,EAAY,CAC9B,MAAM/G,EAASkF,EAAM,IAAKO,GAAS,CACjC,IAAIxN,EAAQ,EACR2O,EAAW,GACf,QAAS9M,EAAI,EAAGA,EAAI2L,EAAK,OAAQ3L,IACpB2L,EAAK3L,CAAC,IACN,IAAK8M,EAAW,CAACA,EACnB,CAACA,GAAYnB,EAAK,WAAWyB,EAAOpN,CAAC,GAAG7B,IAEnD,OAAOA,CACT,CAAC,EACD,GAAI+H,EAAO,SAAW,EAAG,SACzB,MAAMmH,EAAMnH,EAAO,OAAO,CAAC/B,EAAGC,IAAMD,EAAIC,EAAG,CAAC,EAAI8B,EAAO,OACvD,GAAImH,IAAQ,EAAG,SAEf,MAAMC,EADUpH,EAAO,MAAOqH,GAAMA,IAAMrH,EAAO,CAAC,CAAC,EAC3BmH,EAAM,EAAIA,EAC9BC,EAAQH,IACVA,EAAYG,EACZJ,EAAgBE,EAEpB,CACA,OAAOF,CACT,CACA,SAASP,GAAiBnG,EAASsF,EAAQX,EAAS,CAClD,MAAMqC,EAAQ,CAAA,EACRC,EAAetC,EAAQ,eAAiB,GACxCuC,EAAavC,EAAQ,aAAe,GAC1C,UAAW9F,KAAQyG,EAAQ,CACzB,GAAIX,EAAQ,QAAU9F,KAAQ8F,EAAQ,OAAQ,CAC5CqC,EAAMnI,CAAI,EAAI8F,EAAQ,OAAO9F,CAAI,EACjC,QACF,CAEA,MAAMsI,EADSnH,EAAQnB,CAAI,EACL,MAAM,EAAG,GAAG,EAAE,OAAQlE,GAAMA,IAAM,IAAI,EAC5D,GAAIwM,EAAO,SAAW,EAAG,CACvBH,EAAMnI,CAAI,EAAI,OACd,QACF,CACA,GAAIoI,GAAgBE,EAAO,MAAMC,EAAe,EAAG,CACjDJ,EAAMnI,CAAI,EAAIsI,EAAO,MAAME,EAAe,EAAI,MAAoB,MAClE,QACF,CACA,GAAIF,EAAO,MAAMG,EAAe,EAAG,CACjCN,EAAMnI,CAAI,EAAI,OACd,QACF,CACA,GAAIqI,GAAcC,EAAO,MAAMI,EAAY,EAAG,CAC5CP,EAAMnI,CAAI,EAAI,OACd,QACF,CACAmI,EAAMnI,CAAI,EAAI,MAChB,CACA,OAAOmI,CACT,CACA,SAASI,GAAgB/L,EAAG,CAC1B,GAAIA,EAAE,SAAW,EAAG,MAAO,GAC3B,MAAM4C,EAAI,OAAO5C,CAAC,EAClB,MAAO,CAAC,OAAO,MAAM4C,CAAC,GAAK5C,EAAE,KAAI,EAAG,OAAS,CAC/C,CACA,SAASgM,GAAgBhM,EAAG,CAC1B,GAAI,CAAC+L,GAAgB/L,CAAC,EAAG,MAAO,GAChC,MAAM4C,EAAI,OAAO5C,CAAC,EAClB,OAAO,OAAO,UAAU4C,CAAC,GAAK,CAAC5C,EAAE,SAAS,GAAG,GAAK,CAACA,EAAE,SAAS,GAAG,GAAK,CAACA,EAAE,SAAS,GAAG,CACvF,CACA,SAASiM,GAAgBjM,EAAG,CAC1B,MAAMmM,EAAQnM,EAAE,YAAW,EAC3B,OAAOmM,IAAU,QAAUA,IAAU,OACvC,CACA,IAAIC,GAAc,2EAClB,SAASF,GAAalM,EAAG,CACvB,GAAI,CAACoM,GAAY,KAAKpM,CAAC,EAAG,MAAO,GACjC,MAAMK,EAAI,IAAI,KAAKL,CAAC,EACpB,MAAO,CAAC,OAAO,MAAMK,EAAE,QAAO,CAAE,CAClC,CAGA,SAASgM,GAASpC,EAAQqC,EAAMhD,EAAU,CAAA,EAAI,CAC5C,MAAMG,EAAYH,EAAQ,WAAa,IACjCiD,EAAajD,EAAQ,YAAc,YACnCkD,EAAYlD,EAAQ,WAAa,GACjCmD,EAAgBnD,EAAQ,SAAW,GACnCoD,EAAMpD,EAAQ,MAAQ,GACtBC,EAAQ,CAAA,EACVmD,GACFnD,EAAM,KAAK,QAAQ,EAEjBkD,GACFlD,EAAM,KAAKU,EAAO,IAAKE,GAAMwC,GAAWxC,EAAGV,EAAW8C,CAAU,CAAC,EAAE,KAAK9C,CAAS,CAAC,EAEpF,UAAWgB,KAAO6B,EAAM,CACtB,MAAMnB,EAASV,EAAI,IAAKvM,GAClBA,GAAU,KACLyO,GAAWH,EAAW/C,EAAW8C,CAAU,EAEhDrO,aAAiB,KACZyO,GAAWzO,EAAM,YAAW,EAAIuL,EAAW8C,CAAU,EAGrDI,GADL,OAAOzO,GAAU,UAAY,OAAOA,GAAU,UAAY,OAAOA,GAAU,UAC3D,OAAOA,CAAK,EAEd,KAAK,UAAUA,CAAK,EAFHuL,EAAW8C,CAAU,CAGzD,EACDhD,EAAM,KAAK4B,EAAO,KAAK1B,CAAS,CAAC,CACnC,CACA,OAAOF,EAAM,KAAK;AAAA,CAAI,EAAI;AAAA,CAC5B,CACA,SAASoD,GAAWzO,EAAOuL,EAAW8C,EAAY,CAChD,OAAIA,IAAe,QACVrO,EAELqO,IAAe,SACV,IAAMrO,EAAM,QAAQ,KAAM,IAAI,EAAI,IAEvCA,EAAM,SAASuL,CAAS,GAAKvL,EAAM,SAAS,GAAG,GAAKA,EAAM,SAAS;AAAA,CAAI,GAAKA,EAAM,SAAS,IAAI,EAC1F,IAAMA,EAAM,QAAQ,KAAM,IAAI,EAAI,IAEpCA,CACT,CAGA,IAAI0O,GAAuB,CAAC,GAAI,OAAQ,OAAQ,KAAM,MAAO,MAAO,MAAO,OAAQ,MAAM,EACzF,eAAgBC,GAAcC,EAAUxD,EAAU,GAAI,CACpD,MAAMyD,EAAYzD,EAAQ,WAAa,IACjC0D,EAAK,KAAM,QAAO,uCAAI,EACtB,CAAE,iBAAAC,CAAgB,EAAKD,EAC7B,IAAIE,EACJ,GAAI,CACFA,EAASD,EAAiBH,EAAU,CAAE,SAAUxD,EAAQ,UAAY,QAAS,CAC/E,OAAS6D,EAAK,CACZ,MAAMjQ,EAAUiQ,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAI1P,EAAQ,4BAA4BqP,CAAQ,MAAM5P,CAAO,EAAE,CACvE,CACA,MAAMyM,EAAYL,EAAQ,YAAc,GAClCM,EAAa,IAAI,IAAIN,EAAQ,YAAcsD,EAAoB,EAC/D7B,EAAUzB,EAAQ,QAClB8D,EAAW9D,EAAQ,UAAY,EACrC,IAAI+D,EAAS,KACTC,EAAS,GACTrC,EAAW,GACXsC,EAAe,CAAA,EACfC,EAAe,EACfC,EAAiB,GACjBC,EAAY,CAAA,EACZC,EAAW,EACXC,EAAmB,EACvB,MAAMC,EAAQvE,EAAQ,MACtB,SAASwE,EAAWhE,EAAML,EAAW,CACnC,MAAM0B,EAAS,CAAA,EACf,IAAIH,EAAU,GACV+C,EAAS,GACT5P,EAAI,EACR,KAAOA,EAAI2L,EAAK,QAAQ,CACtB,MAAMoB,EAAKpB,EAAK3L,CAAC,EACb4P,EACE7C,IAAO,IACL/M,EAAI,EAAI2L,EAAK,QAAUA,EAAK3L,EAAI,CAAC,IAAM,KACzC6M,GAAW,IACX7M,GAAK,IAEL4P,EAAS,GACT5P,MAGF6M,GAAWE,EACX/M,KAGE+M,IAAO,KAAOF,EAAQ,SAAW,GACnC+C,EAAS,GACT5P,KACS2L,EAAK,WAAWL,EAAWtL,CAAC,GACrCgN,EAAO,KAAKH,CAAO,EACnBA,EAAU,GACV7M,GAAKsL,EAAU,SAEfuB,GAAWE,EACX/M,IAGN,CACA,GAAI4P,EACF,MAAM,IAAIvQ,GAAW,kCAAkC,EAEzD,OAAA2N,EAAO,KAAKH,CAAO,EACZG,CACT,CACA,SAAS6C,EAAiBzE,EAAO,CAC/B,MAAM6B,EAAa,CAAC,IAAK,IAAK,IAAK,GAAG,EACtC,IAAIC,EAAgB,IAChBC,EAAY,GAChB,UAAWC,KAASH,EAAY,CAC9B,MAAM/G,EAASkF,EAAM,IAAKO,GAAS,CACjC,IAAIxN,GAAQ,EACR2R,GAAI,GACR,QAAS9P,GAAI,EAAGA,GAAI2L,EAAK,OAAQ3L,KACpB2L,EAAK3L,EAAC,IACN,IAAK8P,GAAI,CAACA,GACZ,CAACA,IAAKnE,EAAK,WAAWyB,EAAOpN,EAAC,GAAG7B,KAE5C,OAAOA,EACT,CAAC,EACD,GAAI+H,EAAO,SAAW,EAAG,SACzB,MAAMmH,EAAMnH,EAAO,OAAO,CAAC/B,EAAGC,KAAMD,EAAIC,GAAG,CAAC,EAAI8B,EAAO,OACvD,GAAImH,IAAQ,EAAG,SAEf,MAAMC,EADUpH,EAAO,MAAOqH,GAAMA,IAAMrH,EAAO,CAAC,CAAC,EAC3BmH,EAAM,EAAIA,EAC9BC,EAAQH,IACVA,EAAYG,EACZJ,EAAgBE,EAEpB,CACA,OAAOF,CACT,CACA,SAAS6C,EAAWvJ,EAASsF,EAAQkE,EAAM,CACzC,MAAMxC,EAAQ,CAAA,EACRC,EAAeuC,EAAK,eAAiB,GACrCtC,EAAasC,EAAK,aAAe,GACvC,UAAW3K,KAAQyG,EAAQ,CACzB,GAAIkE,EAAK,QAAU3K,KAAQ2K,EAAK,OAAQ,CACtCxC,EAAMnI,CAAI,EAAI2K,EAAK,OAAO3K,CAAI,EAC9B,QACF,CAEA,MAAMsI,EADSnH,EAAQnB,CAAI,EACL,MAAM,EAAG,GAAG,EAAE,OAAQlE,GAAMA,IAAM,IAAI,EAC5D,GAAIwM,EAAO,SAAW,EAAG,CACvBH,EAAMnI,CAAI,EAAI,OACd,QACF,CACA,GAAIoI,GAAgBE,EAAO,MAAMsC,EAAgB,EAAG,CAClDzC,EAAMnI,CAAI,EAAIsI,EAAO,MAAMuC,EAAgB,EAAI,MAAoB,MACnE,QACF,CACA,GAAIvC,EAAO,MAAMwC,EAAgB,EAAG,CAClC3C,EAAMnI,CAAI,EAAI,OACd,QACF,CACA,GAAIqI,GAAcC,EAAO,MAAMyC,EAAa,EAAG,CAC7C5C,EAAMnI,CAAI,EAAI,OACd,QACF,CACAmI,EAAMnI,CAAI,EAAI,MAChB,CACA,OAAOmI,CACT,CACA,SAAS6C,EAAcvE,EAAQ,CAC7B,MAAMwE,EAAO,CAAA,EACb,UAAWjL,KAAQyG,EACjBwE,EAAKjL,CAAI,EAAI,CAAA,EAEf,OAAOiL,CACT,CACA,SAASC,EAAcvD,EAAQwD,EAAS,CACtC,QAASxQ,EAAI,EAAGA,EAAIwQ,EAAQ,OAAO,OAAQxQ,IAAK,CAC9C,MAAMqF,EAAOmL,EAAQ,OAAOxQ,CAAC,EACvByM,EAAMzM,EAAIgN,EAAO,OAASA,EAAOhN,CAAC,EAAI,GACtCD,EAAQyQ,EAAQ,WAAW,IAAI/D,CAAG,EAAI,KAAOA,EACnD8C,EAAUlK,CAAI,EAAE,KAAKtF,CAAK,CAC5B,CACAyP,GACF,CACA,IAAIiB,EAAe,KACfC,EAAoB,KACxB,SAASC,EAAYhF,EAAM,CACzB,GAAIiB,GAAWjB,EAAK,UAAS,EAAG,WAAWiB,CAAO,EAChD,OAAO,KAET,GAAIyC,EAAeJ,EACjB,OAAAI,IACO,KAET,GAAI,CAACC,EACH,OAAAoB,EAAoBvF,EAAQ,WAAa0E,EAAiB,CAAClE,CAAI,CAAC,EAC5DR,EAAQ,QACVsF,EAAetF,EAAQ,OACvBiE,EAAa,KAAKzD,CAAI,GACbH,EACTiF,EAAed,EAAWhE,EAAM+E,CAAiB,EAAE,IAAK1E,GAAMA,EAAE,MAAM,GAGtEyE,EADoBd,EAAWhE,EAAM+E,CAAiB,EAC3B,IAAI,CAACE,EAAG5Q,IAAM,UAAUA,CAAC,EAAE,EACtDoP,EAAa,KAAKzD,CAAI,GAExB2D,EAAiB,GACV,KAET,GAAI,CAACJ,EAAQ,CACXE,EAAa,KAAKzD,CAAI,EACtB,MAAML,EAAYoF,EACZ5E,EAAS2E,EACTI,EAAWR,EAAcvE,CAAM,EACrC,UAAWgF,KAAM1B,EAAc,CAC7B,MAAM2B,GAAUpB,EAAWmB,EAAIxF,CAAS,EACxC,QAAStL,EAAI,EAAGA,EAAI8L,EAAO,OAAQ9L,IAAK,CACtC,MAAMqF,EAAOyG,EAAO9L,CAAC,EACfyM,GAAMzM,EAAI+Q,GAAQ,OAASA,GAAQ/Q,CAAC,EAAI,GACxCD,GAAQ0L,EAAW,IAAIgB,EAAG,EAAI,KAAOA,GAC3CoE,EAASxL,CAAI,EAAE,KAAKtF,EAAK,CAC3B,CACF,CACA,MAAM2M,EAAgBqD,EAAWc,EAAU/E,EAAQX,CAAO,EAC1D+D,EAAS,CAAE,OAAApD,EAAQ,UAAAR,EAAW,WAAAG,EAAY,cAAAiB,CAAa,EACvD6C,EAAYc,EAAcvE,CAAM,EAChC,UAAWgF,KAAM1B,EAAc,CAC7B,MAAM2B,GAAUpB,EAAWmB,EAAIxF,CAAS,EACxCiF,EAAcQ,GAAS7B,CAAM,CAC/B,CAEA,GADAE,EAAe,CAAA,EACXI,GAAYZ,EAAW,CACzB,MAAM1O,EAAS,CAAE,OAAQgP,EAAO,OAAQ,WAAYK,EAAW,cAAeL,EAAO,aAAa,EAClG,OAAAK,EAAYc,EAAcnB,EAAO,MAAM,EACvCO,GAAoBD,EACpBA,EAAW,EACJtP,CACT,CACA,OAAO,IACT,CACA,MAAM8M,EAAS2C,EAAWhE,EAAMuD,EAAO,SAAS,EAEhD,GADAqB,EAAcvD,EAAQkC,CAAM,EACxBM,GAAYZ,EAAW,CACzB,MAAM1O,EAAS,CAAE,OAAQgP,EAAO,OAAQ,WAAYK,EAAW,cAAeL,EAAO,aAAa,EAClG,OAAAK,EAAYc,EAAcnB,EAAO,MAAM,EACvCO,GAAoBD,EACpBA,EAAW,EACJtP,CACT,CACA,OAAO,IACT,CACA,gBAAiB8Q,KAAYjC,EAAQ,CACnCI,GAAU6B,EACV,IAAIC,EAAY,EAChB,QAASjR,EAAI,EAAGA,EAAImP,EAAO,OAAQnP,IAAK,CACtC,MAAM+M,EAAKoC,EAAOnP,CAAC,EACnB,GAAI+M,IAAO,IACTD,EAAW,CAACA,UACH,CAACA,IAAaC,IAAO;AAAA,GAAQA,IAAO,MAAO,CACpD,MAAMpB,EAAOwD,EAAO,MAAM8B,EAAWjR,CAAC,EAKtC,GAJI+M,IAAO,MAAQ/M,EAAI,EAAImP,EAAO,QAAUA,EAAOnP,EAAI,CAAC,IAAM;AAAA,GAC5DA,IAEFiR,EAAYjR,EAAI,EACZ2L,EAAK,OAAS,EAAG,CACnB,GAAI+D,IAAU,QAAUD,EAAmBD,GAAYE,EACrD,MAEF,MAAMxP,EAASyQ,EAAYhF,CAAI,EAC/B,GAAIzL,IACF,MAAMA,EACFwP,IAAU,QAAUD,GAAoBC,GAAO,CACjDX,EAAO,QAAO,EACd,MACF,CAEJ,CACF,CACF,CAEA,GADAI,EAASA,EAAO,MAAM8B,CAAS,EAC3BvB,IAAU,QAAUD,GAAoBC,EAAO,CACjDX,EAAO,QAAO,EACd,MACF,CACF,CACII,EAAO,OAAS,GAAK,EAAEO,IAAU,QAAUD,GAAoBC,KAC7D,CAAC9C,GAAW,CAACuC,EAAO,UAAS,EAAG,WAAWvC,CAAO,IACpD+D,EAAYxB,CAAM,EAGtB,MAAM+B,EAAchC,EACpB,GAAIM,EAAW,GAAK0B,IAAgB,KAAM,CACxC,GAAIxB,IAAU,OAAQ,CACpB,MAAMyB,EAAYzB,EAAQD,EAC1B,GAAI0B,GAAa,EAAG,OACpB,GAAIA,EAAY3B,EACd,UAAWnK,KAAQ6L,EAAY,OAC7B3B,EAAUlK,CAAI,EAAIkK,EAAUlK,CAAI,EAAE,MAAM,EAAG8L,CAAS,CAG1D,CACA,KAAM,CAAE,OAAQD,EAAY,OAAQ,WAAY3B,EAAW,cAAe2B,EAAY,aAAa,CACrG,CACF,CACA,SAASjB,GAAiBpO,EAAG,CAC3B,GAAIA,EAAE,SAAW,EAAG,MAAO,GAC3B,MAAM4C,EAAI,OAAO5C,CAAC,EAClB,MAAO,CAAC,OAAO,MAAM4C,CAAC,GAAK5C,EAAE,KAAI,EAAG,OAAS,CAC/C,CACA,SAASqO,GAAiBrO,EAAG,CAC3B,GAAI,CAACoO,GAAiBpO,CAAC,EAAG,MAAO,GACjC,MAAM4C,EAAI,OAAO5C,CAAC,EAClB,OAAO,OAAO,UAAU4C,CAAC,GAAK,CAAC5C,EAAE,SAAS,GAAG,GAAK,CAACA,EAAE,SAAS,GAAG,GAAK,CAACA,EAAE,SAAS,GAAG,CACvF,CACA,SAASsO,GAAiBtO,EAAG,CAC3B,MAAMmM,EAAQnM,EAAE,YAAW,EAC3B,OAAOmM,IAAU,QAAUA,IAAU,OACvC,CACA,IAAIoD,GAAe,2EACnB,SAAShB,GAAcvO,EAAG,CACxB,GAAI,CAACuP,GAAa,KAAKvP,CAAC,EAAG,MAAO,GAClC,MAAMK,EAAI,IAAI,KAAKL,CAAC,EACpB,MAAO,CAAC,OAAO,MAAMK,EAAE,QAAO,CAAE,CAClC,CAGA,eAAgBmP,GAAiB1C,EAAUxD,EAAU,GAAI,CACvD,MAAMyD,EAAYzD,EAAQ,WAAa,IACjCuE,EAAQvE,EAAQ,MAChB0D,EAAK,KAAM,QAAO,uCAAI,EACtB,CAAE,iBAAAC,CAAgB,EAAKD,EAC7B,IAAIE,EACJ,GAAI,CACFA,EAASD,EAAiBH,EAAU,CAAE,SAAUxD,EAAQ,UAAY,QAAS,CAC/E,OAAS6D,EAAK,CACZ,MAAMjQ,EAAUiQ,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAI1P,EAAQ,+BAA+BqP,CAAQ,MAAM5P,CAAO,EAAE,CAC1E,CACA,IAAIoQ,EAAS,GACTmC,EAAQ,CAAA,EACRC,EAAe,EACnB,gBAAiBP,KAAYjC,EAAQ,CACnCI,GAAU6B,EACV,IAAIC,EAAY,EAChB,QAASjR,EAAI,EAAGA,EAAImP,EAAO,OAAQnP,IAAK,CACtC,MAAM+M,EAAKoC,EAAOnP,CAAC,EACnB,GAAI+M,IAAO;AAAA,GAAQA,IAAO,KAAM,CAC9B,MAAMpB,EAAOwD,EAAO,MAAM8B,EAAWjR,CAAC,EAKtC,GAJI+M,IAAO,MAAQ/M,EAAI,EAAImP,EAAO,QAAUA,EAAOnP,EAAI,CAAC,IAAM;AAAA,GAC5DA,IAEFiR,EAAYjR,EAAI,EACZ2L,EAAK,OAAO,OAAS,IACvB2F,EAAM,KAAK,KAAK,MAAM3F,CAAI,CAAC,EACvB2F,EAAM,QAAU1C,IAClB,MAAM0C,EACNC,GAAgBD,EAAM,OACtBA,EAAQ,CAAA,EACJ5B,IAAU,QAAU6B,GAAgB7B,IAAO,CAC7CX,EAAO,QAAO,EACd,MACF,CAGN,CACF,CACAI,EAASA,EAAO,MAAM8B,CAAS,CACjC,CAIA,GAHI9B,EAAO,OAAO,OAAS,GACzBmC,EAAM,KAAK,KAAK,MAAMnC,CAAM,CAAC,EAE3BmC,EAAM,OAAS,EAAG,CACpB,GAAI5B,IAAU,OAAQ,CACpB,MAAMyB,EAAYzB,EAAQ6B,EAC1B,GAAIJ,GAAa,EAAG,OAChBA,EAAYG,EAAM,SACpBA,EAAQA,EAAM,MAAM,EAAGH,CAAS,EAEpC,CACA,MAAMG,CACR,CACF,CAGA,SAASE,GAAU1F,EAAQqC,EAAMhD,EAAU,CAAA,EAAI,CAC7C,MAAMsG,EAAU,CAAA,EAChB,UAAWnF,KAAO6B,EAAM,CACtB,MAAMuD,EAAM,CAAA,EACZ,QAAS,EAAI,EAAG,EAAI5F,EAAO,OAAQ,IAAK,CACtC,MAAM/L,EAAQuM,EAAI,CAAC,EACfvM,aAAiB,KACnB2R,EAAI5F,EAAO,CAAC,CAAC,EAAI/L,EAAM,YAAW,EAElC2R,EAAI5F,EAAO,CAAC,CAAC,EAAI/L,GAAS,IAE9B,CACA0R,EAAQ,KAAKC,CAAG,CAClB,CACA,OAAIvG,EAAQ,OACH,KAAK,UAAUsG,EAAS,KAAM,CAAC,EAEjC,KAAK,UAAUA,CAAO,CAC/B,CACA,SAASE,GAAY7F,EAAQqC,EAAM,CACjC,MAAM/C,EAAQ,CAAA,EACd,UAAWkB,KAAO6B,EAAM,CACtB,MAAMuD,EAAM,CAAA,EACZ,QAAS1R,EAAI,EAAGA,EAAI8L,EAAO,OAAQ9L,IAAK,CACtC,MAAMD,EAAQuM,EAAItM,CAAC,EACfD,aAAiB,KACnB2R,EAAI5F,EAAO9L,CAAC,CAAC,EAAID,EAAM,YAAW,EAElC2R,EAAI5F,EAAO9L,CAAC,CAAC,EAAID,GAAS,IAE9B,CACAqL,EAAM,KAAK,KAAK,UAAUsG,CAAG,CAAC,CAChC,CACA,OAAOtG,EAAM,KAAK;AAAA,CAAI,EAAI;AAAA,CAC5B,CAGA,SAASwG,GAAgB7R,EAAO,CAE9B,OADIA,GAAU,MACV,OAAOA,GAAU,SAAiB,MAClC,OAAOA,GAAU,UAAkB,OACnCA,aAAiB,KAAa,OAC9B,OAAOA,GAAU,SAAiB,OAClC,OAAOA,GAAU,SAAiB,SAC/B,MACT,CACA,SAAS8R,GAAaC,EAAK,CACzB,MAAMxO,EAAQ,kBAAkB,KAAKwO,EAAI,YAAW,CAAE,EACtD,GAAI,CAACxO,EAAO,MAAM,IAAIhE,EAAQ,4BAA4BwS,CAAG,GAAG,EAChE,MAAMC,EAASzO,EAAM,CAAC,EAChB0O,EAAS,SAAS1O,EAAM,CAAC,EAAG,EAAE,EACpC,IAAI2O,EAAS,EACb,QAASjS,EAAI,EAAGA,EAAI+R,EAAO,OAAQ/R,IACjCiS,EAASA,EAAS,IAAMF,EAAO,WAAW/R,CAAC,EAAI,IAEjD,MAAO,CAAE,IAAKiS,EAAQ,IAAKD,CAAM,CACnC,CACA,SAASE,GAAWC,EAAO,CACzB,MAAMC,EAAQD,EAAM,MAAM,GAAG,EAC7B,GAAIC,EAAM,SAAW,EAAG,MAAM,IAAI9S,EAAQ,0BAA0B6S,CAAK,mCAAmC,EAC5G,MAAM3R,EAAQqR,GAAaO,EAAM,CAAC,CAAC,EAC7B3R,EAAMoR,GAAaO,EAAM,CAAC,CAAC,EACjC,MAAO,CAAE,SAAU5R,EAAM,IAAK,SAAUA,EAAM,IAAK,OAAQC,EAAI,IAAK,OAAQA,EAAI,GAAG,CACrF,CACA,SAAS4R,GAAaC,EAAUC,EAAO,CACrC,GAAIA,IAAU,QAAUA,IAAU,EAAG,CACnC,MAAMC,EAAMF,EAAS,WAAW,CAAC,EACjC,GAAI,CAACE,EAAK,MAAM,IAAIlT,EAAQ,iCAAiC,EAC7D,OAAOkT,CACT,CACA,GAAI,OAAOD,GAAU,SAAU,CAC7B,MAAMC,EAAMF,EAAS,WAAWC,CAAK,EACrC,GAAI,CAACC,EAAK,MAAM,IAAIlT,EAAQ,sBAAsB,OAAOiT,CAAK,CAAC,YAAY,EAC3E,OAAOC,CACT,CACA,MAAMC,EAAKH,EAAS,aAAaC,CAAK,EACtC,GAAI,CAACE,EAAI,MAAM,IAAInT,EAAQ,cAAciT,CAAK,aAAa,EAC3D,OAAOE,CACT,CACA,SAASC,GAAmB3S,EAAO,CACjC,GAAIA,GAAU,KAA0B,OAAO,KAC/C,GAAI,OAAOA,GAAU,UAAYA,IAAU,MAAQ,CAAC,MAAM,QAAQA,CAAK,GAAK,EAAEA,aAAiB,MAAO,CACpG,GAAI,aAAcA,EAChB,OAAOA,EAAM,SAAS,IAAK,GAAM,OAAO,EAAE,IAAI,CAAC,EAAE,KAAK,EAAE,EAE1D,GAAI,WAAYA,EACd,OAAOA,EAAM,MAEjB,CACA,OAAOA,CACT,CACA,SAAS4S,GAAoBC,EAAWzH,EAAU,GAAI,CACpD,MAAMK,EAAYL,EAAQ,YAAc,GAClC0H,EAAW1H,EAAQ,MACzB,IAAI2H,EACAC,EACAC,EACAC,EACJ,GAAIJ,EAAU,CACZ,MAAMhM,EAAIqL,GAAWW,CAAQ,EAC7BC,EAAWjM,EAAE,SACbkM,EAASlM,EAAE,OACXmM,EAAWnM,EAAE,SACboM,EAASpM,EAAE,MACb,MACEiM,EAAW,EACXC,EAASH,EAAU,SACnBI,EAAW,EACXC,EAASL,EAAU,YAErB,GAAIG,EAASD,GAAYG,EAASD,EAChC,MAAO,CAAE,OAAQ,CAAA,EAAI,QAAS,CAAA,EAAI,cAAe,EAAE,EAErD,MAAME,EAAU,CAAA,EAChB,QAASrM,EAAIiM,EAAUjM,GAAKkM,EAAQlM,IAAK,CACvC,MAAMyF,EAAMsG,EAAU,OAAO/L,CAAC,EACxBsM,EAAY,CAAA,EAClB,QAAS5F,EAAIyF,EAAUzF,GAAK0F,EAAQ1F,IAAK,CACvC,MAAM6F,EAAO9G,EAAI,QAAQiB,CAAC,EAC1B4F,EAAU,KAAKT,GAAmBU,EAAK,KAAK,CAAC,CAC/C,CACAF,EAAQ,KAAKC,CAAS,CACxB,CACA,IAAIrH,EACAuH,EACJ,GAAI7H,GAAa0H,EAAQ,OAAS,EAChCpH,EAASoH,EAAQ,CAAC,EAAE,IAAI,CAAC/R,EAAGnB,IACtBmB,GAAM,KAA6B,UAAU,OAAOnB,CAAC,CAAC,GACtD,OAAOmB,GAAM,SAAiBA,EAC9B,OAAOA,GAAM,UAAY,OAAOA,GAAM,WAAa,OAAOA,GAAM,SAAiB,OAAOA,CAAC,EACzFA,aAAa,KAAaA,EAAE,YAAW,EACpC,UAAU,OAAOnB,CAAC,CAAC,EAC3B,EACDqT,EAAe,MACV,CACL,MAAMC,EAAWL,EAASD,EAAW,EACrClH,EAAS,MAAM,KAAK,CAAE,OAAQwH,CAAQ,EAAI,CAAC1C,EAAG5Q,IAAM,UAAU,OAAOA,CAAC,CAAC,EAAE,EACzEqT,EAAe,CACjB,CACA,MAAM7M,EAAU,CAAA,EAChB,UAAWnB,KAAQyG,EACjBtF,EAAQnB,CAAI,EAAI,CAAA,EAElB,QAASrF,EAAIqT,EAAcrT,EAAIkT,EAAQ,OAAQlT,IAAK,CAClD,MAAMsM,EAAM4G,EAAQlT,CAAC,EACrB,QAASuT,EAAI,EAAGA,EAAIzH,EAAO,OAAQyH,IAAK,CACtC,MAAM/G,EAAUV,EAAOyH,CAAC,EACxB/M,EAAQgG,CAAO,EAAE,KAAK+G,EAAIjH,EAAI,OAASA,EAAIiH,CAAC,GAAK,KAAO,IAAI,CAC9D,CACF,CACA,MAAM7G,EAAgB,CAAA,EACtB,UAAWrH,KAAQyG,EACjB,GAAIX,EAAQ,SAAS9F,CAAI,IAAM,OAC7BqH,EAAcrH,CAAI,EAAI8F,EAAQ,OAAO9F,CAAI,MACpC,CACL,MAAMmO,EAAYhN,EAAQnB,CAAI,EAC9B,IAAIoO,EAAW,MACf,UAAWtS,KAAKqS,EACd,GAAIrS,GAAM,KAAsB,CAC9BsS,EAAW7B,GAAgBzQ,CAAC,EAC5B,KACF,CAEFuL,EAAcrH,CAAI,EAAIoO,CACxB,CAEF,MAAO,CAAE,OAAA3H,EAAQ,QAAAtF,EAAS,cAAAkG,CAAa,CACzC,CACA,eAAegH,GAAc/E,EAAUxD,EAAU,GAAI,CACnD,IAAIwI,EACJ,GAAI,CACFA,EAAU,KAAM,QAAO,2BAAS,EAAA,KAAA,SAAAlP,EAAA,CAAA,OAAAA,EAAA,CAAA,CAAA,CAClC,MAAQ,CACN,MAAM,IAAInF,EACR,wFACN,CACE,CACA,GAAI,CACF,MAAMgT,EAAW,IAAIqB,EAAQ,SAC7B,MAAMrB,EAAS,KAAK,SAAS3D,CAAQ,EACrC,MAAMiE,EAAYP,GAAaC,EAAUnH,EAAQ,KAAK,EACtD,OAAOwH,GAAoBC,EAAWzH,CAAO,CAC/C,OAAS6D,EAAK,CACZ,GAAIA,aAAe1P,EAAS,MAAM0P,EAClC,MAAMjQ,EAAUiQ,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAI1P,EAAQ,8BAA8BqP,CAAQ,MAAM5P,CAAO,EAAE,CACzE,CACF,CAGA,SAAS6U,GAAiBC,EAAO,CAE/B,MAAM7F,GADU6F,EAAM,MAAM,WAAQ,GAAQ,OAAOA,EAAM,IAAI,GACvC,YAAW,EACjC,OAAI7F,EAAM,SAAS,OAAO,GAAKA,EAAM,SAAS,OAAO,GAAKA,EAAM,SAAS,MAAM,EACtE,MAELA,EAAM,SAAS,OAAO,GAAKA,EAAM,SAAS,KAAK,GAAKA,EAAM,SAAS,MAAM,GAGzEA,EAAM,SAAS,OAAO,GAAKA,EAAM,SAAS,QAAQ,GAAKA,EAAM,SAAS,SAAS,EAC1E,MAELA,EAAM,SAAS,MAAM,GAAKA,EAAM,SAAS,QAAQ,GAAKA,EAAM,SAAS,aAAa,GAAKA,EAAM,SAAS,WAAW,EAC5G,OAELA,IAAU,QAAUA,EAAM,SAAS,SAAS,EACvC,OAELA,EAAM,SAAS,MAAM,GAAKA,EAAM,SAAS,WAAW,EAC/C,OAEF,MACT,CACA,SAAS8F,GAAoB7U,EAAQwH,EAAOhH,EAAQ,CAClD,MAAMwB,EAAS,CAAA,EACf,QAASjB,EAAI,EAAGA,EAAIP,EAAQO,IAAK,CAC/B,GAAIf,EAAO,QAAQe,CAAC,IAAM,GAAO,CAC/BiB,EAAO,KAAK,IAAI,EAChB,QACF,CACA,IAAID,EAAM/B,EAAO,IAAIe,CAAC,EAClB,OAAOgB,GAAQ,WACjBA,EAAM,OAAOA,CAAG,GAEdyF,IAAU,QAAqB,OAAOzF,GAAQ,WAChDA,EAAM,IAAI,KAAKA,CAAG,GAEpBC,EAAO,KAAKD,CAAG,CACjB,CACA,OAAOC,CACT,CACA,eAAe8S,GAAgBpF,EAAUxD,EAAU,GAAI,CACrD,IAAI6I,EACJ,GAAI,CAEFA,EAAc,MAAM,OADD,eAErB,MAAQ,CACN,MAAM,IAAI1U,EACR,oGACN,CACE,CACA,GAAI,CAEF,MAAM6P,EAAS,MADJ,KAAM,QAAO,uCAAa,GACb,SAASR,CAAQ,EACnCsF,EAAQ,IAAI,WAAW9E,EAAO,OAAQA,EAAO,WAAYA,EAAO,UAAU,EAC1E+E,EAAaF,EAAY,YAAYC,CAAK,EAC1C/E,EAASgF,EAAW,OACpBC,EAAYjF,EAAO,WAAaA,EAAO,QAAQ,QAAU,EACzDkF,EAAUF,EAAW,SAAW,EAChCG,EAAY,CAAA,EAClB,QAASrU,EAAI,EAAGA,EAAImU,EAAWnU,IAAK,CAClC,MAAM6T,EAAQ3E,EAAO,MAAMlP,CAAC,EACtBqF,EAAO,OAAOwO,EAAM,IAAI,EACxBpN,EAAQmN,GAAiBC,CAAK,EACpCQ,EAAU,KAAK,CAAE,KAAAhP,EAAM,MAAAoB,EAAO,MAAOzG,EAAG,CAC1C,CACA,MAAMsU,EAAiBnJ,EAAQ,QAAUkJ,EAAU,OAAQE,GAAMpJ,EAAQ,QAAQ,SAASoJ,EAAE,IAAI,CAAC,EAAIF,EAC/FvI,EAAS,CAAA,EACTtF,EAAU,CAAA,EACVkG,EAAgB,CAAA,EACtB,UAAWmH,KAASS,EAAgB,CAClCxI,EAAO,KAAK+H,EAAM,IAAI,EACtBnH,EAAcmH,EAAM,IAAI,EAAIA,EAAM,MAClC,MAAMW,EAAWN,EAAW,WAAWL,EAAM,KAAK,EAC9CW,EACFhO,EAAQqN,EAAM,IAAI,EAAIC,GAAoBU,EAAUX,EAAM,MAAOO,CAAO,EAExE5N,EAAQqN,EAAM,IAAI,EAAI,IAAI,MAAMO,CAAO,EAAE,KAAK,IAAI,CAEtD,CACA,MAAO,CAAE,OAAAtI,EAAQ,QAAAtF,EAAS,cAAAkG,CAAa,CACzC,OAASsC,EAAK,CACZ,GAAIA,aAAe1P,EAAS,MAAM0P,EAClC,MAAMjQ,EAAUiQ,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAI1P,EAAQ,gCAAgCqP,CAAQ,MAAM5P,CAAO,EAAE,CAC3E,CACF,CAGA,SAAS0V,GAAc3C,EAAK,CAC1B,MAAMxO,EAAQ,kBAAkB,KAAKwO,EAAI,YAAW,CAAE,EACtD,GAAI,CAACxO,EAAO,MAAM,IAAIhE,EAAQ,4BAA4BwS,CAAG,GAAG,EAChE,MAAMC,EAASzO,EAAM,CAAC,EAChB0O,EAAS,SAAS1O,EAAM,CAAC,EAAG,EAAE,EACpC,IAAI2O,EAAS,EACb,QAASjS,EAAI,EAAGA,EAAI+R,EAAO,OAAQ/R,IACjCiS,EAASA,EAAS,IAAMF,EAAO,WAAW/R,CAAC,EAAI,IAEjD,MAAO,CAAE,IAAKiS,EAAQ,IAAKD,CAAM,CACnC,CACA,SAAS0C,GAAqB1R,EAAM,CAClC,IAAI9C,EAAS,GACT,EAAI8C,EACR,KAAO,EAAI,GAAG,CACZ,MAAM2R,GAAa,EAAI,GAAK,GAC5BzU,EAAS,OAAO,aAAa,GAAKyU,CAAS,EAAIzU,EAC/C,EAAI,KAAK,OAAO,EAAI,GAAK,EAAE,CAC7B,CACA,OAAOA,CACT,CACA,eAAe0U,GAAejG,EAAU7C,EAAQqC,EAAMhD,EAAU,CAAA,EAAI,CAClE,IAAIwI,EACJ,GAAI,CACFA,EAAU,KAAM,QAAO,2BAAS,EAAA,KAAA,SAAAlP,EAAA,CAAA,OAAAA,EAAA,CAAA,CAAA,CAClC,MAAQ,CACN,MAAM,IAAInF,EACR,yFACN,CACE,CACA,GAAI,CACF,MAAMgT,EAAW,IAAIqB,EAAQ,SACvBkB,EAAY1J,EAAQ,OAAS,SAC7ByH,EAAYN,EAAS,aAAauC,CAAS,EAC3CC,EAAY3J,EAAQ,WAAa,KACjC,CAAE,IAAK6H,EAAU,IAAKF,CAAQ,EAAK2B,GAAcK,CAAS,EAChE,QAAS9U,EAAI,EAAGA,EAAI8L,EAAO,OAAQ9L,IAAK,CAEtC,MAAM+U,EAAU,GADEL,GAAqB1B,EAAWhT,CAAC,CACvB,GAAG,OAAO8S,CAAQ,CAAC,GAC/CF,EAAU,QAAQmC,CAAO,EAAE,MAAQjJ,EAAO9L,CAAC,CAC7C,CACA,QAAS6G,EAAI,EAAGA,EAAIsH,EAAK,OAAQtH,IAAK,CACpC,MAAMyF,EAAM6B,EAAKtH,CAAC,EAClB,QAAS0G,EAAI,EAAGA,EAAIzB,EAAO,OAAQyB,IAAK,CAEtC,MAAMwH,EAAU,GADEL,GAAqB1B,EAAWzF,CAAC,CACvB,GAAG,OAAOuF,EAAW,EAAIjM,CAAC,CAAC,GACjD9G,EAAQwN,EAAIjB,EAAI,OAASA,EAAIiB,CAAC,EAAI,KACxCqF,EAAU,QAAQmC,CAAO,EAAE,MAAQhV,GAAqC,IAC1E,CACF,CACA,GAAIoL,EAAQ,WAAY,CACtB,MAAM6J,EAAgBN,GAAqB1B,EAAWlH,EAAO,OAAS,CAAC,EACjEmJ,EAAUnC,EAAW3E,EAAK,OAChCyE,EAAU,WAAa,GAAG8B,GAAqB1B,CAAQ,CAAC,GAAG,OAAOF,CAAQ,CAAC,IAAIkC,CAAa,GAAG,OAAOC,CAAO,CAAC,EAChH,CACA,GAAI9J,EAAQ,YAAa,CACvB,MAAM+J,EAAY/J,EAAQ,YAAY,IAChCgK,EAAYhK,EAAQ,YAAY,IACtCyH,EAAU,MAAQ,CAChB,CACE,MAAO,SACP,OAAQuC,EACR,OAAQrC,EAAW,EAAIoC,EACvB,YAAa,GAAGR,GAAqB1B,EAAWmC,CAAS,CAAC,GAAG,OAAOrC,EAAWoC,CAAS,CAAC,GACzF,WAAY,GAAGR,GAAqB1B,CAAQ,CAAC,GAAG,OAAOF,CAAQ,CAAC,EAC1E,CACA,CACI,CACA,GAAI3H,EAAQ,aACV,QAASnL,EAAI,EAAGA,EAAI8L,EAAO,OAAQ9L,IAAK,CACtC,MAAMwM,EAAUV,EAAO9L,CAAC,EAClBoV,EAAQjK,EAAQ,aAAaqB,CAAO,EAC1C,GAAI4I,IAAU,OAAQ,CACpB,MAAMpS,EAAO4P,EAAU,UAAUI,EAAWhT,CAAC,EAC7CgD,EAAK,MAAQoS,CACf,CACF,CAEF,MAAM9C,EAAS,KAAK,UAAU3D,CAAQ,CACxC,OAASK,EAAK,CACZ,GAAIA,aAAe1P,EAAS,MAAM0P,EAClC,MAAMjQ,EAAUiQ,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAI1P,EAAQ,+BAA+BqP,CAAQ,MAAM5P,CAAO,EAAE,CAC1E,CACF,CAGA,SAASsW,GAAiBC,EAAO7O,EAAO,CACtC,OAAQA,EAAK,CACX,IAAK,MACH,OAAO,IAAI6O,EAAM,QACnB,IAAK,MACH,OAAO,IAAIA,EAAM,MACnB,IAAK,OACH,OAAO,IAAIA,EAAM,KACnB,IAAK,OACH,OAAO,IAAIA,EAAM,KACnB,IAAK,OACL,IAAK,WACH,OAAO,IAAIA,EAAM,gBACnB,QACE,OAAO,IAAIA,EAAM,IACvB,CACA,CACA,SAASC,GAAatU,EAAQwF,EAAO,CACnC,OAAQA,EAAK,CACX,IAAK,MACL,IAAK,MACH,OAAOxF,EAAO,IAAKE,GAAMA,GAAM,KAAuB,KAAO,OAAOA,CAAC,CAAC,EACxE,IAAK,OACH,OAAOF,EAAO,IAAKE,GACbA,GAAM,KAA6B,KACnC,OAAOA,GAAM,SAAiBA,EAC9B,OAAOA,GAAM,UAAY,OAAOA,GAAM,WAAa,OAAOA,GAAM,SAAiB,OAAOA,CAAC,EACtF,OAAOA,GAAM,SAAW,KAAK,UAAUA,CAAC,EAAI,OAAOA,CAAC,CAC5D,EACH,IAAK,OACH,OAAOF,EAAO,IAAKE,GAAMA,GAAM,KAAuB,KAAO,EAAQA,CAAE,EACzE,IAAK,OACL,IAAK,WACH,OAAOF,EAAO,IAAKE,GACbA,GAAM,KAA6B,KACnCA,aAAa,KAAaA,EAAE,QAAO,EACnC,OAAOA,GAAM,SAAiBA,EAC3B,IACR,EACH,QACE,OAAOF,EAAO,IAAKE,GACbA,GAAM,KAA6B,KACnC,OAAOA,GAAM,SAAiBA,EAC9B,OAAOA,GAAM,UAAY,OAAOA,GAAM,WAAa,OAAOA,GAAM,SAC3D,OAAOA,CAAC,EAEV,OAAOA,GAAM,SAAW,KAAK,UAAUA,CAAC,EAAI,OAAOA,CAAC,CAC5D,CACP,CACA,CACA,SAASqU,GAAmBxB,EAAayB,EAAa,CACpD,MAAMC,EAAc1B,EAAY,YAChC,GAAI,CAAC0B,EAAa,OAAOD,EAAY,YAAW,EAChD,OAAQA,EAAW,CACjB,IAAK,SACH,OAAOC,EAAY,OACrB,IAAK,OACH,OAAOA,EAAY,KACrB,IAAK,OACH,OAAOA,EAAY,KACrB,IAAK,OACH,OAAOA,EAAY,YACzB,CACA,CACA,eAAeC,GAAiBhH,EAAU7C,EAAQtF,EAAS2E,EAAU,CAAA,EAAI,CACvE,IAAI6I,EACJ,GAAI,CAEFA,EAAc,MAAM,OADD,eAErB,MAAQ,CACN,MAAM,IAAI1U,EACR,qGACN,CACE,CACA,IAAIgW,EACJ,GAAI,CAEFA,EAAQ,MAAM,OADM,eAEtB,MAAQ,CACN,MAAM,IAAIhW,EACR,qGACN,CACE,CACA,GAAI,CACF,MAAM0N,EAAS,CAAA,EACT4I,EAAe,CAAA,EACrB,UAAWvQ,KAAQyG,EAAQ,CACzB,MAAM9I,EAAOwD,EAAQnB,CAAI,EACnBwQ,EAAYR,GAAiBC,EAAOtS,EAAK,KAAK,EACpDgK,EAAO,KAAK,IAAIsI,EAAM,MAAMjQ,EAAMwQ,EAAW,EAAI,CAAC,EAClD,MAAMC,EAAUP,GAAavS,EAAK,OAAQA,EAAK,KAAK,EACpD4S,EAAavQ,CAAI,EAAIiQ,EAAM,gBAAgBQ,EAASD,CAAS,CAC/D,CACA,MAAM3G,EAAS,IAAIoG,EAAM,OAAOtI,CAAM,EAChCkH,EAAa,IAAIoB,EAAM,MAAMpG,EAAQ0G,CAAY,EACjDG,EAAWT,EAAM,WAAWpB,EAAY,QAAQ,EAChD8B,EAAYhC,EAAY,MAAM,cAAc+B,CAAQ,EACpDN,EAActK,EAAQ,aAAe,SACrC8K,EAAsBT,GAAmBxB,EAAayB,CAAW,EACvE,IAAIS,EAAU,IAAIlC,EAAY,wBAC9BkC,EAAUA,EAAQ,eAAeD,CAAmB,EAChD9K,EAAQ,eAAiB,SAC3B+K,EAAUA,EAAQ,mBAAmB/K,EAAQ,YAAY,GAE3D,MAAMgL,EAAmBD,EAAQ,MAAK,EAChCE,EAAepC,EAAY,aAAagC,EAAWG,CAAgB,EAEzE,MADW,KAAM,QAAO,uCAAa,GAC5B,UAAUxH,EAAUyH,CAAY,CAC3C,OAASpH,EAAK,CACZ,GAAIA,aAAe1P,EAAS,MAAM0P,EAClC,MAAMjQ,EAAUiQ,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAI1P,EAAQ,iCAAiCqP,CAAQ,MAAM5P,CAAO,EAAE,CAC5E,CACF,CAGA,SAASsX,GAAkBf,EAAO7O,EAAO,CACvC,OAAQA,EAAK,CACX,IAAK,MACH,OAAO,IAAI6O,EAAM,QACnB,IAAK,MACH,OAAO,IAAIA,EAAM,MACnB,IAAK,OACH,OAAO,IAAIA,EAAM,KACnB,IAAK,OACH,OAAO,IAAIA,EAAM,KACnB,IAAK,OACL,IAAK,WACH,OAAO,IAAIA,EAAM,gBACnB,QACE,OAAO,IAAIA,EAAM,IACvB,CACA,CACA,SAASgB,GAAYvW,EAAO0G,EAAO,CACjC,GAAI1G,GAAU,KAA0B,OAAO,KAC/C,OAAQ0G,EAAK,CACX,IAAK,MACL,IAAK,MACH,OAAO,OAAO1G,CAAK,EACrB,IAAK,OACH,MAAO,EAAQA,EACjB,IAAK,OACL,IAAK,WACH,OAAIA,aAAiB,KAAaA,EAAM,QAAO,EAC3C,OAAOA,GAAU,SAAiBA,EAC/B,IAAI,KAAKA,CAAK,EAAE,QAAO,EAEhC,QACE,OAAI,OAAOA,GAAU,SAAiBA,EAClC,OAAOA,GAAU,UAAY,OAAOA,GAAU,WAAa,OAAOA,GAAU,SAAiB,OAAOA,CAAK,EACtG,OAAOA,GAAU,SAAW,KAAK,UAAUA,CAAK,EAAI,OAAOA,CAAK,CAC7E,CACA,CACA,eAAewW,GAAaC,EAAO,CACjC,IAAIlB,EACJ,GAAI,CAEFA,EAAQ,MAAM,OADK,eAErB,MAAQ,CACN,MAAM,IAAIhW,EACR,gGACN,CACE,CACA,KAAM,CAAE,YAAAmX,EAAa,gBAAAC,CAAe,EAAKF,EACnCG,EAAY,CAAA,EAClB,UAAWtR,KAAQoR,EAAa,CAC9B,KAAM,CAAE,OAAAxV,EAAQ,MAAAwF,GAAUiQ,EAAgBrR,CAAI,EACxCwQ,EAAYQ,GAAkBf,EAAO7O,CAAK,EAC1CqP,EAAU7U,EAAO,IAAKE,GAAMmV,GAAYnV,EAAGsF,CAAK,CAAC,EACvDkQ,EAAUtR,CAAI,EAAIiQ,EAAM,gBAAgBQ,EAASD,CAAS,CAC5D,CACA,OAAO,IAAIP,EAAM,MAAMqB,CAAS,CAClC,CAGA,SAASC,GAAkB/C,EAAO,CAChC,MAAMgD,EAAShD,EAAM,MAAM,OACrBiD,EAAU,OAAOjD,EAAM,MAAQ,EAAE,EACvC,OAAQgD,EAAM,CACZ,IAAK,GACH,MAAO,MACT,IAAK,GACH,MAAO,MACT,IAAK,GACH,MAAO,OACT,IAAK,GACH,MAAO,OACT,IAAK,GAEL,IAAK,IACH,MAAO,OACT,IAAK,GACH,OAAIC,EAAQ,SAAS,MAAM,EAAU,OAEvC,QACE,OAAIA,EAAQ,SAAS,KAAK,EAAU,MAChCA,EAAQ,SAAS,OAAO,EAAU,MAClCA,EAAQ,SAAS,MAAM,GAAKA,EAAQ,SAAS,MAAM,EAAU,OAC7DA,EAAQ,SAAS,MAAM,EAAU,OACjCA,EAAQ,SAAS,MAAM,GAAKA,EAAQ,SAAS,WAAW,EAAU,OAC/D,MACb,CACA,CACA,SAASC,GAAeC,EAAO,CAC7B,GAAI,CAACA,GAAS,CAACA,EAAM,QAAU,CAACA,EAAM,OAAO,OAC3C,MAAM,IAAI1X,EAAQ,+CAA+C,EAEnE,MAAMwM,EAAS,CAAA,EACTtF,EAAU,CAAA,EACVkG,EAAgB,CAAA,EAChB0H,EAAU,OAAO4C,EAAM,OAAO,EAC9BhK,EAASgK,EAAM,OAAO,OAC5B,UAAWnD,KAAS7G,EAAQ,CAC1B,MAAM3H,EAAO,OAAOwO,EAAM,IAAI,EAC9B/H,EAAO,KAAKzG,CAAI,EAChB,MAAMoB,EAAQmQ,GAAkB/C,CAAK,EACrCnH,EAAcrH,CAAI,EAAIoB,EACtB,MAAMxH,EAAS+X,EAAM,SAAS3R,CAAI,EAC5BpE,EAAS,CAAA,EACf,QAASjB,EAAI,EAAGA,EAAIoU,EAASpU,IAAK,CAChC,MAAMgB,EAAM/B,EAAO,IAAIe,CAAC,EACpBgB,GAAQ,KACVC,EAAO,KAAK,IAAI,EACPwF,IAAU,QAAqB,OAAOzF,GAAQ,SACvDC,EAAO,KAAK,IAAI,KAAKD,CAAG,CAAC,EAEzBC,EAAO,KAAKD,CAAG,CAEnB,CACAwF,EAAQnB,CAAI,EAAIpE,CAClB,CACA,MAAO,CAAE,OAAA6K,EAAQ,QAAAtF,EAAS,cAAAkG,CAAa,CACzC,CAMA,IAAIuK,GAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiMdC,GAAoB,IACpBC,GAAqB,KAAK,IAAI,EAAG3Y,GAAG,KAAI,EAAG,OAAS,CAAC,EACrD4Y,GAAyB,KAC7B,SAASC,IAA+B,CACtC,OAAID,KAA2B,KACtB,GAEFA,EACT,CACA,SAASE,GAAkB9H,EAAUrE,EAAS,CAC5C,MAAMoM,EAAYpM,GAAS,WAAa+L,GAExC,OADI1H,EAAW+H,GACX,CAACF,GAA4B,EAAW,IACxBlM,GAAS,aAAegM,IACvB,CACvB,CACA,SAASK,GAAgBnS,EAAMpG,EAAQ,CACrC,MAAMwC,EAAMxC,EAAO,OACnB,IAAImB,EAAW,KACf,GAAInB,EAAO,UAAY,EAAG,CACxB,MAAMwY,EAAY,IAAI,WAAW,KAAK,KAAKhW,EAAM,CAAC,CAAC,EACnD,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IACnBf,EAAO,IAAIe,CAAC,IAAM,OACpByX,EAAUzX,GAAK,CAAC,GAAK,IAAMA,EAAI,IAGnCI,EAAWqX,EAAU,MACvB,CACA,OAAQxY,EAAO,MAAK,CAClB,IAAK,MACL,IAAK,OAAmB,CACtB,MAAMwE,EAAM,IAAI,aAAahC,CAAG,EAChC,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EAClBmB,IAAM,KACRsC,EAAIzD,CAAC,EAAI,EACAmB,aAAa,KACtBsC,EAAIzD,CAAC,EAAImB,EAAE,QAAO,EAElBsC,EAAIzD,CAAC,EAAImB,CAEb,CACA,MAAO,CACL,KAAAkE,EACA,MAAOpG,EAAO,QAAU,OAAoB,OAAS,UACrD,KAAMwE,EAAI,OACV,SAAArD,EACA,OAAQqB,CAChB,CACI,CACA,IAAK,MAAmB,CACtB,MAAMgC,EAAM,IAAI,WAAWhC,CAAG,EAC9B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EACtByD,EAAIzD,CAAC,EAAImB,IAAM,KAAO,EAAIA,CAC5B,CACA,MAAO,CACL,KAAAkE,EACA,MAAO,QACP,KAAM5B,EAAI,OACV,SAAArD,EACA,OAAQqB,CAChB,CACI,CACA,IAAK,OAAsB,CACzB,MAAMgC,EAAM,IAAI,WAAWhC,CAAG,EAC9B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EACtByD,EAAIzD,CAAC,EAAImB,IAAM,KAAO,EAAIA,EAAI,EAAI,CACpC,CACA,MAAO,CACL,KAAAkE,EACA,MAAO,UACP,KAAM5B,EAAI,OACV,SAAArD,EACA,OAAQqB,CAChB,CACI,CAEA,QAAS,CACP,MAAMgC,EAAM,CAAA,EACZ,QAASzD,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmB,EAAIlC,EAAO,IAAIe,CAAC,EAClBmB,IAAM,KACRsC,EAAI,KAAK,EAAE,EACF,OAAOtC,GAAM,SACtBsC,EAAI,KAAKtC,CAAC,EACD,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAC/CsC,EAAI,KAAK,OAAOtC,CAAC,CAAC,EAElBsC,EAAI,KAAK,EAAE,CAEf,CACA,MAAO,CACL,KAAA4B,EACA,MAAO,OACP,KAAM5B,EACN,SAAArD,EACA,OAAQqB,CAChB,CACI,CACJ,CACA,CACA,SAASiW,GAAgBC,EAAcC,EAAa,CAClD,MAAMC,EAAa,MAAM,KACvB,CAAE,OAAQD,CAAW,EACrB,IAAM,CAAA,CACV,EACE,QAAS5X,EAAI,EAAGA,EAAI2X,EAAa,OAAQ3X,IAAK,CAC5C,KAAM,EAAGY,CAAO,EAAI+W,EAAa3X,CAAC,EAClC6X,EAAW7X,EAAI4X,CAAW,EAAE,KAAK,CAAC5X,EAAGY,CAAO,CAAC,CAC/C,CACA,OAAOiX,CACT,CACA,eAAeC,GAAYH,EAAcI,EAAgBC,EAAYC,EAAUC,EAAe/M,EAAS,CACrG,MAAMgN,EAAK,KAAM,QAAO,uCAAgB,EAClC,CAAE,OAAAC,CAAM,EAAKD,EACnBf,GAAyB,GACzB,MAAMQ,EAAc,KAAK,IACvBzM,GAAS,aAAegM,GACxBQ,EAAa,MACjB,EACQU,EAAgC,IAAI,IAC1C,UAAWC,KAAWP,EACpBM,EAAc,IAAIC,CAAO,EAE3B,UAAWC,KAAQ,OAAO,OAAON,CAAQ,EACvCI,EAAc,IAAIE,EAAK,UAAU,EAEnC,MAAMC,EAAoB,CAAA,EAC1B,UAAWhM,KAAW6L,EAAe,CACnC,MAAMpZ,EAASiZ,EAAc,IAAI1L,CAAO,EACpCvN,IACFuZ,EAAkBhM,CAAO,EAAIgL,GAAgBhL,EAASvN,CAAM,EAEhE,CAEA,MAAMwZ,EADaf,GAAgBC,EAAcC,CAAW,EAC1B,IAAKc,GACjCA,EAAU,SAAW,EAChB,QAAQ,QAAQ,CAAE,QAAS,CAAA,CAAE,CAAE,EAEjC,IAAI,QAAQ,CAACC,EAASC,IAAW,CACtC,MAAMC,EAAS,IAAIT,EAAOnB,GAAa,CAAE,KAAM,GAAM,EAC/ClY,EAAU,CACd,QAASyZ,EACT,OAAQE,EACR,SAAAT,EACA,WAAYF,CACpB,EACMc,EAAO,GAAG,UAAY3Y,GAAW,CAC1B2Y,EAAO,UAAS,EACrBF,EAAQzY,CAAM,CAChB,CAAC,EACD2Y,EAAO,GAAG,QAAU7J,GAAQ,CACrB6J,EAAO,UAAS,EACrBD,EAAO5J,CAAG,CACZ,CAAC,EACD6J,EAAO,YAAY9Z,CAAO,CAC5B,CAAC,CACF,EACKoE,EAAU,MAAM,QAAQ,IAAIsV,CAAc,EAC1CK,EAAa,CAAA,EACnB,UAAWC,KAAgB5V,EACzB2V,EAAW,KAAK,GAAGC,EAAa,OAAO,EAEzC,OAAAD,EAAW,KAAK,CAAC3U,EAAGC,IAAMD,EAAE,WAAaC,EAAE,UAAU,EAC9C0U,CACT,CAGG,IAACE,GAAU,KAAM,CAClB,IACA,MACA,UACA,YAAY9P,EAAK+P,EAAM,CACrB,KAAK,IAAM/P,EACX,KAAK,MAAQ+P,EACb,UAAWhT,KAAOgT,EAChB,GAAI,CAAC/P,EAAI,QAAQ,SAASjD,CAAG,EAC3B,MAAM,IAAIjH,EAAoBiH,EAAKiD,EAAI,OAAO,EAGlD,KAAK,UAA4B,IAAI,IACrC,MAAM1C,EAAUyS,EAAK,IAAKC,GAAMhQ,EAAI,IAAIgQ,CAAC,EAAE,MAAM,EACjD,QAASlZ,EAAI,EAAGA,EAAIkJ,EAAI,OAAQlJ,IAAK,CACnC,MAAMmZ,EAAS,KAAK,cAAc3S,EAASxG,CAAC,EACtCoZ,EAAQ,KAAK,UAAU,IAAID,CAAM,EACnCC,EACFA,EAAM,KAAKpZ,CAAC,EAEZ,KAAK,UAAU,IAAImZ,EAAQ,CAACnZ,CAAC,CAAC,CAElC,CACF,CACA,IAAI,MAAO,CACT,MAAO,CAAC,GAAG,KAAK,KAAK,CACvB,CACA,IAAI,WAAY,CACd,OAAO,KAAK,GACd,CACA,IAAI,UAAW,CACb,OAAO,KAAK,SACd,CACA,SAAU,CACR,OAAO,KAAK,UAAU,IACxB,CACA,IAAIqZ,EAAOlO,EAAS,CAClB,OAAIA,GAAWmM,GAAkB,KAAK,IAAI,MAAM,IAC1BA,GAAkB,KAAK,IAAI,OAAQnM,CAAO,EAIzD,KAAK,SAASkO,CAAK,CAC5B,CAKA,MAAM,SAASA,EAAOlO,EAAS,CAC7B,MAAMmO,EAAgB,CAAA,EACtB,SAAW,CAACjU,EAAMkT,CAAI,IAAK,OAAO,QAAQc,CAAK,EACzC,OAAOd,GAAS,SAClBe,EAAcjU,CAAI,EAAI,KAAK,kBAAkBA,EAAMkT,CAAI,EAEvDe,EAAcjU,CAAI,EAAIkT,EAI1B,GAAI,CADgBjB,GAAkB,KAAK,IAAI,OAAQnM,CAAO,EAE5D,OAAO,KAAK,SAASkO,CAAK,EAE5B,MAAMpB,EAAW,CAAA,EACjB,SAAW,CAAC5S,EAAMkU,CAAO,IAAK,OAAO,QAAQD,CAAa,EAAG,CAC3D,MAAME,EAAU,KAAK,eAAeD,CAAO,EAC3C,GAAI,CAACC,EACH,OAAO,KAAK,SAASH,CAAK,EAE5BpB,EAAS5S,CAAI,EAAI,CACf,WAAYkU,EAAQ,aAAa,CAAC,EAClC,QAAAC,CACR,CACI,CACA,MAAMtB,EAAgC,IAAI,IAC1C,UAAW1L,KAAW,KAAK,IAAI,QAC7B0L,EAAc,IAAI1L,EAAS,KAAK,IAAI,IAAIA,CAAO,EAAE,MAAM,EAEzD,MAAMmL,EAAe,CAAC,GAAG,KAAK,UAAU,QAAO,CAAE,EAC3C8B,EAAU,KAAK,MAAM,IAAKP,GAAM,KAAK,IAAI,IAAIA,CAAC,EAAE,MAAM,EACtD/V,EAAU,MAAM2U,GACpBH,EACA,CAAC,GAAG,KAAK,KAAK,EACd8B,EACAxB,EACAC,EACA/M,CACN,EACUuO,EAAUvW,EAAQ,OAClBwW,EAAgC,IAAI,IACpClD,EAAc,CAAA,EACpB,QAASmD,EAAK,EAAGA,EAAK,KAAK,MAAM,OAAQA,IAAM,CAC7C,MAAMV,EAAI,KAAK,MAAMU,CAAE,EACjBC,EAAO1W,EAAQ,IAAK0D,GAAMA,EAAE,UAAU+S,CAAE,GAAK,IAAI,EACvDD,EAAc,IAAIT,EAAG,KAAK,iBAAiBO,EAAQG,CAAE,EAAGC,CAAI,CAAC,EAC7DpD,EAAY,KAAKyC,CAAC,CACpB,CACA,MAAMY,EAAW,OAAO,KAAKT,CAAK,EAClC,UAAWhU,KAAQyU,EAAU,CAC3B,MAAMD,EAAO1W,EAAQ,IAAK0D,GAAMA,EAAE,UAAUxB,CAAI,GAAK,IAAI,EACzDsU,EAAc,IAAItU,EAAM,KAAK,aAAawU,EAAMH,CAAO,CAAC,EACxDjD,EAAY,KAAKpR,CAAI,CACvB,CACA,MAAM0U,EAAO,KAAK,IAAI,YACtB,OAAO,IAAIA,EAAKJ,EAAelD,CAAW,CAC5C,CACA,SAAS4C,EAAO,CACd,MAAM1B,EAAe,CAAC,GAAG,KAAK,UAAU,QAAO,CAAE,EAC3C+B,EAAU/B,EAAa,OACvBK,EAAa,KAAK,MAClB8B,EAAW,OAAO,KAAKT,CAAK,EAC5BC,EAAgB,CAAA,EACtB,SAAW,CAACjU,EAAMkT,CAAI,IAAK,OAAO,QAAQc,CAAK,EACzC,OAAOd,GAAS,SAClBe,EAAcjU,CAAI,EAAI,KAAK,kBAAkBA,EAAMkT,CAAI,EAEvDe,EAAcjU,CAAI,EAAIkT,EAG1B,MAAMyB,EAA4B,IAAI,IACtC,UAAWd,KAAKlB,EACdgC,EAAU,IAAId,EAAG,EAAE,EAErB,MAAMe,EAA4B,IAAI,IACtC,UAAW5U,KAAQyU,EACjBG,EAAU,IAAI5U,EAAM,EAAE,EAExB,MAAMoU,EAAUzB,EAAW,IAAKkB,GAAM,KAAK,IAAI,IAAIA,CAAC,EAAE,MAAM,EAC5D,GAAIY,EAAS,SAAW,EAAG,CACzB,MAAMI,EAAcJ,EAAS,CAAC,EACxBK,EAAUb,EAAcY,CAAW,EACzC,GAAIC,aAAmBxS,GAAY,CACjC,MAAMyS,EAAY,KAAK,IAAI,IAAID,EAAQ,aAAa,CAAC,CAAC,EAAE,OACxD,SAAW,CAAA,CAAGvZ,CAAO,IAAK+W,EAAc,CACtC,MAAM0C,EAAazZ,EAAQ,CAAC,EAC5B,QAASgZ,EAAK,EAAGA,EAAK5B,EAAW,OAAQ4B,IACvCI,EAAU,IAAIhC,EAAW4B,CAAE,CAAC,EAAE,KAAKH,EAAQG,CAAE,EAAE,IAAIS,CAAU,CAAC,EAEhE,IAAIC,EAAM,EACNC,EAAW,GACf,QAASC,EAAK,EAAGA,EAAK5Z,EAAQ,OAAQ4Z,IAAM,CAC1C,MAAMrZ,EAAIiZ,EAAU,IAAIxZ,EAAQ4Z,CAAE,CAAC,EAC/B,OAAOrZ,GAAM,WACfmZ,GAAOnZ,EACPoZ,EAAW,GAEf,CACAN,EAAU,IAAIC,CAAW,EAAE,KAAKK,EAAWD,EAAM,IAAI,CACvD,CACA,MAAMG,EAAiC,IAAI,IACrCC,EAAe,CAAA,EACrB,QAASd,EAAK,EAAGA,EAAK5B,EAAW,OAAQ4B,IAAM,CAC7C,MAAMV,EAAIlB,EAAW4B,CAAE,EACjBC,EAAOG,EAAU,IAAId,CAAC,EAC5BuB,EAAe,IAAIvB,EAAG,KAAK,iBAAiBO,EAAQG,CAAE,EAAGC,CAAI,CAAC,EAC9Da,EAAa,KAAKxB,CAAC,CACrB,CACAuB,EAAe,IACbP,EACA7Z,EAAc,KAAK4Z,EAAU,IAAIC,CAAW,CAAC,CACvD,EACQQ,EAAa,KAAKR,CAAW,EAC7B,MAAMS,EAAQ,KAAK,IAAI,YACvB,OAAO,IAAIA,EAAMF,EAAgBC,CAAY,CAC/C,CACF,CACA,SAAW,CAAA,CAAG9Z,CAAO,IAAK+W,EAAc,CACtC,MAAM0C,EAAazZ,EAAQ,CAAC,EAC5B,QAASgZ,EAAK,EAAGA,EAAK5B,EAAW,OAAQ4B,IACvCI,EAAU,IAAIhC,EAAW4B,CAAE,CAAC,EAAE,KAAKH,EAAQG,CAAE,EAAE,IAAIS,CAAU,CAAC,EAEhE,MAAMO,EAAe,IAAI,WAAWha,CAAO,EACrCia,EAA6B,IAAI,IACvC,UAAWC,KAAc,KAAK,IAAI,QAChCD,EAAW,IAAIC,EAAY,KAAK,IAAI,IAAIA,CAAU,EAAE,OAAO,KAAKF,CAAY,CAAC,EAE/E,MAAMD,EAAQ,KAAK,IAAI,YACjBI,EAAW,IAAIJ,EAAME,EAAY,CAAC,GAAG,KAAK,IAAI,OAAO,CAAC,EAC5D,UAAWxV,KAAQyU,EAAU,CAE3B,MAAM5Z,EADUoZ,EAAcjU,CAAI,EACX,cAAc0V,CAAQ,EAC7Cd,EAAU,IAAI5U,CAAI,EAAE,KAAKnF,CAAM,CACjC,CACF,CACA,MAAMyZ,EAAgC,IAAI,IACpClD,EAAc,CAAA,EACpB,QAASmD,EAAK,EAAGA,EAAK5B,EAAW,OAAQ4B,IAAM,CAC7C,MAAMV,EAAIlB,EAAW4B,CAAE,EACjBQ,EAAYX,EAAQG,CAAE,EACtBC,EAAOG,EAAU,IAAId,CAAC,EAC5BS,EAAc,IAAIT,EAAG,KAAK,iBAAiBkB,EAAWP,CAAI,CAAC,EAC3DpD,EAAY,KAAKyC,CAAC,CACpB,CACA,UAAW7T,KAAQyU,EAAU,CAC3B,MAAMD,EAAOI,EAAU,IAAI5U,CAAI,EAC/BsU,EAAc,IAAItU,EAAM,KAAK,aAAawU,EAAMH,CAAO,CAAC,EACxDjD,EAAY,KAAKpR,CAAI,CACvB,CACA,MAAM0U,EAAO,KAAK,IAAI,YACtB,OAAO,IAAIA,EAAKJ,EAAelD,CAAW,CAC5C,CACA,eAAe8C,EAAS,CACtB,MAAMlU,EAAOkU,EAAQ,YAAY,KAYjC,MAXY,CACV,WAAY,MACZ,YAAa,OACb,aAAc,QACd,qBAAsB,iBACtB,WAAY,MACZ,WAAY,MACZ,WAAY,MACZ,aAAc,QACd,YAAa,MACnB,EACelU,CAAI,GAAK,IACtB,CACA,kBAAkBuE,EAAYoR,EAAQ,CACpC,MAAMC,EAAU9Q,GAAIP,CAAU,EAC9B,OAAQoR,EAAM,CACZ,IAAK,MACH,OAAOC,EAAQ,IAAG,EACpB,IAAK,OACH,OAAOA,EAAQ,KAAI,EACrB,IAAK,QACH,OAAOA,EAAQ,MAAK,EACtB,IAAK,MACH,OAAOA,EAAQ,IAAG,EACpB,IAAK,MACH,OAAOA,EAAQ,IAAG,EACpB,IAAK,MACH,OAAOA,EAAQ,IAAG,EACpB,IAAK,QACH,OAAOA,EAAQ,MAAK,EACtB,IAAK,OACH,OAAOA,EAAQ,KAAI,EACrB,QACE,MAAM,IAAI,MAAM,+BAA+BD,CAAM,EAAE,CAC/D,CACE,CACA,iBAAiB3X,EAAQpC,EAAQ,CAC/B,OAAQoC,EAAO,MAAK,CAClB,IAAK,MACH,OAAOhD,EAAc,KAAKY,CAAM,EAClC,IAAK,MACH,OAAOZ,EAAc,KAAKY,CAAM,EAClC,IAAK,OACH,OAAOK,EAAW,KAAKL,CAAM,EAC/B,IAAK,OACH,OAAOkB,EAAc,KAAKlB,CAAM,EAClC,IAAK,OACH,OAAOoB,EAAW,KAAKpB,CAAM,EAC/B,QACE,OAAOZ,EAAc,KAAKY,CAAM,CACxC,CACE,CACA,aAAaA,EAAQia,EAAS,CAC5B,IAAIvN,EAAS,KACb,UAAWxM,KAAKF,EACd,GAAIE,IAAM,KAAM,CACdwM,EAASxM,EACT,KACF,CAEF,OAAIwM,IAAW,MAAQ,OAAOA,GAAW,SAChCtN,EAAc,KAAKY,CAAM,EAE9B,OAAO0M,GAAW,SACbrM,EAAW,KAAKL,CAAM,EAE3B,OAAO0M,GAAW,UACbxL,EAAc,KAAKlB,CAAM,EAE9B0M,aAAkB,KACbtL,EAAW,KAAKpB,CAAM,EAExBZ,EAAc,KAAKY,CAAM,CAClC,CACA,OAAQ,CACN,MAAM0W,EAAe,CAAC,GAAG,KAAK,UAAU,QAAO,CAAE,EAC3C8B,EAAU,KAAK,MAAM,IAAKP,GAAM,KAAK,IAAI,IAAIA,CAAC,EAAE,MAAM,EACtDc,EAA4B,IAAI,IACtC,UAAWd,KAAK,KAAK,MACnBc,EAAU,IAAId,EAAG,EAAE,EAErB,MAAMhT,EAAS,CAAA,EACf,SAAW,CAAA,CAAGtF,CAAO,IAAK+W,EAAc,CACtC,MAAM0C,EAAazZ,EAAQ,CAAC,EAC5B,QAASgZ,EAAK,EAAGA,EAAK,KAAK,MAAM,OAAQA,IACvCI,EAAU,IAAI,KAAK,MAAMJ,CAAE,CAAC,EAAE,KAAKH,EAAQG,CAAE,EAAE,IAAIS,CAAU,CAAC,EAEhEnU,EAAO,KAAKtF,EAAQ,MAAM,CAC5B,CACA,MAAM+Y,EAAgC,IAAI,IACpClD,EAAc,CAAA,EACpB,QAASmD,EAAK,EAAGA,EAAK,KAAK,MAAM,OAAQA,IAAM,CAC7C,MAAMV,EAAI,KAAK,MAAMU,CAAE,EACjBC,EAAOG,EAAU,IAAId,CAAC,EAC5BS,EAAc,IAAIT,EAAG,KAAK,iBAAiBO,EAAQG,CAAE,EAAGC,CAAI,CAAC,EAC7DpD,EAAY,KAAKyC,CAAC,CACpB,CACAS,EAAc,IAAI,QAAStZ,EAAc,KAAK6F,CAAM,CAAC,EACrDuQ,EAAY,KAAK,OAAO,EACxB,MAAMsD,EAAO,KAAK,IAAI,YACtB,OAAO,IAAIA,EAAKJ,EAAelD,CAAW,CAC5C,CACA,IAAIxX,EAAQ,CACV,OAAO,KAAK,IAAI,CAAE,CAACA,CAAM,EAAGkL,GAAIlL,CAAM,EAAE,IAAG,EAAI,CACjD,CACA,KAAKA,EAAQ,CACX,OAAO,KAAK,IAAI,CAAE,CAACA,CAAM,EAAGkL,GAAIlL,CAAM,EAAE,KAAI,EAAI,CAClD,CACA,IAAIA,EAAQ,CACV,OAAO,KAAK,IAAI,CAAE,CAACA,CAAM,EAAGkL,GAAIlL,CAAM,EAAE,IAAG,EAAI,CACjD,CACA,IAAIA,EAAQ,CACV,OAAO,KAAK,IAAI,CAAE,CAACA,CAAM,EAAGkL,GAAIlL,CAAM,EAAE,IAAG,EAAI,CACjD,CACA,OAAQ,CACN,MAAMkc,EAAgB,KAAK,IAAI,QAAQ,OAAQ5N,GAAM,CAAC,KAAK,MAAM,SAASA,CAAC,CAAC,EACtE8L,EAAQ,CAAA,EACd,UAAW9L,KAAK4N,EACd9B,EAAM9L,CAAC,EAAIpD,GAAIoD,CAAC,EAAE,MAAK,EAEzB,OAAO,KAAK,IAAI8L,CAAK,CACvB,CACA,MAAO,CACL,MAAM8B,EAAgB,KAAK,IAAI,QAAQ,OAAQ5N,GAAM,CAAC,KAAK,MAAM,SAASA,CAAC,CAAC,EACtE8L,EAAQ,CAAA,EACd,UAAW9L,KAAK4N,EACd9B,EAAM9L,CAAC,EAAIpD,GAAIoD,CAAC,EAAE,KAAI,EAExB,OAAO,KAAK,IAAI8L,CAAK,CACvB,CACA,MAAM9V,EAAI,CACR,MAAMJ,EAAU,CAAA,EAChB,SAAW,CAAA,CAAGvC,CAAO,IAAK,KAAK,UAAW,CACxC,MAAMma,EAAW,KAAK,eAAena,CAAO,EAC5CuC,EAAQ,KAAKI,EAAGwX,CAAQ,CAAC,CAC3B,CACA,OAAI5X,EAAQ,SAAW,EACd,KAAK,IAAI,MAAM,EAAG,CAAC,EAEf,KAAK,IAAI,YACV,OAAO,GAAGA,CAAO,CAC/B,CACA,QAAS,CACP,MAAMjD,EAAyB,IAAI,IACnC,SAAW,CAAC+F,EAAKrF,CAAO,IAAK,KAAK,UAChCV,EAAO,IAAI+F,EAAK,KAAK,eAAerF,CAAO,CAAC,EAE9C,OAAOV,CACT,CACA,cAAcsG,EAAS5G,EAAO,CAC5B,GAAI4G,EAAQ,SAAW,EAAG,CACxB,MAAMrF,EAAIqF,EAAQ,CAAC,EAAE,IAAI5G,CAAK,EAC9B,OAAIuB,IAAM,KAAa,SACnBA,aAAa,KAAa,MAAMA,EAAE,QAAO,CAAE,GAC3C,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAC1D,KAAK,OAAOA,CAAC,GAAG,OAAOA,CAAC,CAAC,GAE3B,QAAQ,KAAK,UAAUA,CAAC,CAAC,EAClC,CACA,MAAMiR,EAAQ,CAAA,EACd,UAAWnT,KAAUuH,EAAS,CAC5B,MAAMrF,EAAIlC,EAAO,IAAIW,CAAK,EACtBuB,IAAM,KACRiR,EAAM,KAAK,QAAQ,EACVjR,aAAa,KACtBiR,EAAM,KAAK,MAAMjR,EAAE,QAAO,CAAE,EAAE,EACrB,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAAY,OAAOA,GAAM,UACxEiR,EAAM,KAAK,KAAK,OAAOjR,CAAC,GAAG,OAAOA,CAAC,CAAC,EAAE,EAEtCiR,EAAM,KAAK,QAAQ,KAAK,UAAUjR,CAAC,CAAC,EAAE,CAE1C,CACA,OAAOiR,EAAM,KAAK,GAAG,CACvB,CACA,eAAexR,EAAS,CACtB,MAAMga,EAAe,IAAI,WAAWha,CAAO,EACrCwa,EAA6B,IAAI,IACjC3E,EAAc,KAAK,IAAI,QAC7B,UAAWpR,KAAQoR,EACjB2E,EAAW,IAAI/V,EAAM,KAAK,IAAI,IAAIA,CAAI,EAAE,OAAO,KAAKuV,CAAY,CAAC,EAEnE,MAAMb,EAAO,KAAK,IAAI,YACtB,OAAO,IAAIA,EAAKqB,EAAY3E,CAAW,CACzC,CACF,EAGA,SAAS4E,GAAa7U,EAAS5G,EAAO,CACpC,MAAMwS,EAAQ,CAAA,EACd,UAAWnT,KAAUuH,EAAS,CAC5B,MAAMrF,EAAIlC,EAAO,IAAIW,CAAK,EAC1B,GAAIuB,IAAM,KACR,OAAO,KACEA,aAAa,KACtBiR,EAAM,KAAK,MAAMjR,EAAE,QAAO,CAAE,EAAE,EACrB,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAAY,OAAOA,GAAM,UACxEiR,EAAM,KAAK,KAAK,OAAOjR,CAAC,GAAG,OAAOA,CAAC,CAAC,EAAE,EAEtCiR,EAAM,KAAK,QAAQ,KAAK,UAAUjR,CAAC,CAAC,EAAE,CAE1C,CACA,OAAOiR,EAAM,KAAK,GAAG,CACvB,CACA,SAASkJ,GAAmBvb,EAAO,CACjC,OAAIA,IAAU,KAAa,KACvBA,aAAiB,KAAa,MAAMA,EAAM,QAAO,CAAE,GACnD,OAAOA,GAAU,UAAY,OAAOA,GAAU,UAAY,OAAOA,GAAU,UACtEA,EAEF,QAAQ,KAAK,UAAUA,CAAK,CAAC,EACtC,CACA,SAASwb,GAAsB9U,EAAOxF,EAAQ,CAC5C,OAAQwF,EAAK,CACX,IAAK,MACH,OAAOpG,EAAc,KAAKY,CAAM,EAClC,IAAK,MACH,OAAOG,GAAY,KAAKH,CAAM,EAChC,IAAK,OACH,OAAOK,EAAW,KAAKL,CAAM,EAC/B,IAAK,OACH,OAAOkB,EAAc,KAAKlB,CAAM,EAClC,IAAK,OACH,OAAOoB,EAAW,KAAKpB,CAAM,EAC/B,QACE,OAAOZ,EAAc,KAAKY,CAAM,CACtC,CACA,CACA,SAASua,GAAYC,EAAI,CACvB,GAAI,OAAOA,GAAO,SAChB,MAAO,CAAE,SAAU,CAACA,CAAE,EAAG,UAAW,CAACA,CAAE,CAAC,EAE1C,GAAI,MAAM,QAAQA,CAAE,EAClB,MAAO,CAAE,SAAUA,EAAI,UAAWA,CAAE,EAEtC,MAAMC,EAAW,MAAM,QAAQD,EAAG,IAAI,EAAIA,EAAG,KAAO,CAACA,EAAG,IAAI,EACtDE,EAAY,MAAM,QAAQF,EAAG,KAAK,EAAIA,EAAG,MAAQ,CAACA,EAAG,KAAK,EAChE,GAAIC,EAAS,SAAWC,EAAU,OAChC,MAAM,IAAI,MAAM,qDAAqD,EAEvE,MAAO,CAAE,SAAAD,EAAU,UAAAC,CAAS,CAC9B,CACA,SAASC,GAAUvS,EAAMC,EAAO1G,EAAQ,CACtC,MAAMiZ,EAAexS,EAAK,OAASC,EAAM,OACnCqQ,EAAgC,IAAI,IACpClD,EAAc,CAAA,EACdqF,EAAkC,IAAI,IAC5C,UAAWC,KAAMzS,EAAM,QACjBD,EAAK,QAAQ,SAAS0S,CAAE,EAC1BD,EAAgB,IAAIC,EAAI,GAAGA,CAAE,GAAGnZ,CAAM,EAAE,EAExCkZ,EAAgB,IAAIC,EAAIA,CAAE,EAG9B,UAAWvP,KAAWnD,EAAK,QAAS,CAClC,MAAM2S,EAAS3S,EAAK,IAAImD,CAAO,EAAE,OAC3BvL,EAAS,IAAI,MAAM4a,CAAY,EACrC,QAASI,EAAK,EAAGA,EAAK5S,EAAK,OAAQ4S,IAAM,CACvC,MAAM9a,EAAI6a,EAAO,IAAIC,CAAE,EACvB,QAASC,EAAK,EAAGA,EAAK5S,EAAM,OAAQ4S,IAClCjb,EAAOgb,EAAK3S,EAAM,OAAS4S,CAAE,EAAI/a,CAErC,CACAwY,EAAc,IAAInN,EAAS+O,GAAsBS,EAAO,MAAO/a,CAAM,CAAC,EACtEwV,EAAY,KAAKjK,CAAO,CAC1B,CACA,UAAWA,KAAWlD,EAAM,QAAS,CACnC,MAAM0S,EAAS1S,EAAM,IAAIkD,CAAO,EAAE,OAC5B2P,EAAaL,EAAgB,IAAItP,CAAO,EACxCvL,EAAS,IAAI,MAAM4a,CAAY,EACrC,QAASI,EAAK,EAAGA,EAAK5S,EAAK,OAAQ4S,IACjC,QAASC,EAAK,EAAGA,EAAK5S,EAAM,OAAQ4S,IAClCjb,EAAOgb,EAAK3S,EAAM,OAAS4S,CAAE,EAAIF,EAAO,IAAIE,CAAE,EAGlDvC,EAAc,IAAIwC,EAAYZ,GAAsBS,EAAO,MAAO/a,CAAM,CAAC,EACzEwV,EAAY,KAAK0F,CAAU,CAC7B,CACA,MAAMpC,EAAO1Q,EAAK,YAClB,OAAO,IAAI0Q,EAAKJ,EAAelD,CAAW,CAC5C,CACA,SAAS2F,GAAa/S,EAAMC,EAAOmS,EAAIY,EAAM,CAC3C,KAAM,CAAE,SAAAX,EAAU,UAAAC,GAAcH,GAAYC,CAAE,EAC9C,UAAWxV,KAAOyV,EAChB,GAAI,CAACrS,EAAK,QAAQ,SAASpD,CAAG,EAC5B,MAAM,IAAIjH,EAAoBiH,EAAKoD,EAAK,OAAO,EAGnD,UAAWpD,KAAO0V,EAChB,GAAI,CAACrS,EAAM,QAAQ,SAASrD,CAAG,EAC7B,MAAM,IAAIjH,EAAoBiH,EAAKqD,EAAM,OAAO,EAGpD,MAAMgT,EAAeX,EAAU,IAAKzC,GAAM5P,EAAM,IAAI4P,CAAC,EAAE,MAAM,EACvDqD,EAAcb,EAAS,IAAKxC,GAAM7P,EAAK,IAAI6P,CAAC,EAAE,MAAM,EACpDsD,EAA8B,IAAI,IACxC,GAAIF,EAAa,SAAW,EAAG,CAC7B,MAAMG,EAAcH,EAAa,CAAC,EAClC,QAAStc,EAAI,EAAGA,EAAIsJ,EAAM,OAAQtJ,IAAK,CACrC,MAAMiG,EAAMqV,GAAmBmB,EAAY,IAAIzc,CAAC,CAAC,EAC7CiG,IAAQ,MAAMuW,EAAY,IAAIvW,CAAG,CACvC,CACF,KACE,SAASjG,EAAI,EAAGA,EAAIsJ,EAAM,OAAQtJ,IAAK,CACrC,MAAMmZ,EAASkC,GAAaiB,EAActc,CAAC,EACvCmZ,IAAW,MAAMqD,EAAY,IAAIrD,CAAM,CAC7C,CAEF,MAAMuD,EAAiB,CAAA,EACvB,GAAIH,EAAY,SAAW,EAAG,CAC5B,MAAMI,EAAaJ,EAAY,CAAC,EAChC,QAASvc,EAAI,EAAGA,EAAIqJ,EAAK,OAAQrJ,IAAK,CACpC,MAAMiG,EAAMqV,GAAmBqB,EAAW,IAAI3c,CAAC,CAAC,EAC1C4c,EAAW3W,IAAQ,MAAQuW,EAAY,IAAIvW,CAAG,GAChDoW,EAAO,CAACO,EAAWA,IACrBF,EAAe,KAAK1c,CAAC,CAEzB,CACF,KACE,SAASA,EAAI,EAAGA,EAAIqJ,EAAK,OAAQrJ,IAAK,CACpC,MAAMmZ,EAASkC,GAAakB,EAAavc,CAAC,EACpC4c,EAAWzD,IAAW,MAAQqD,EAAY,IAAIrD,CAAM,GACtDkD,EAAO,CAACO,EAAWA,IACrBF,EAAe,KAAK1c,CAAC,CAEzB,CAEF,MAAM2Z,EAAgC,IAAI,IACpClD,EAAc,CAAA,EACpB,UAAWjK,KAAWnD,EAAK,QAAS,CAClC,MAAM2S,EAAS3S,EAAK,IAAImD,CAAO,EAAE,OAC3BvL,EAAS,IAAI,MAAMyb,EAAe,MAAM,EAC9C,QAAS1c,EAAI,EAAGA,EAAI0c,EAAe,OAAQ1c,IACzCiB,EAAOjB,CAAC,EAAIgc,EAAO,IAAIU,EAAe1c,CAAC,CAAC,EAE1C2Z,EAAc,IAAInN,EAAS+O,GAAsBS,EAAO,MAAO/a,CAAM,CAAC,EACtEwV,EAAY,KAAKjK,CAAO,CAC1B,CACA,MAAMuN,EAAO1Q,EAAK,YAClB,OAAO,IAAI0Q,EAAKJ,EAAelD,CAAW,CAC5C,CACA,SAASoG,GAASxT,EAAMC,EAAOmS,EAAIqB,EAAM,QAAS3R,EAAS,CACzD,MAAMvI,EAASuI,GAAS,QAAU,SAClC,GAAI2R,IAAQ,QACV,OAAOlB,GAAUvS,EAAMC,EAAO1G,CAAM,EAEtC,GAAIka,IAAQ,OACV,OAAOV,GAAa/S,EAAMC,EAAOmS,EAAI,EAAK,EAE5C,GAAIqB,IAAQ,OACV,OAAOV,GAAa/S,EAAMC,EAAOmS,EAAI,EAAI,EAE3C,KAAM,CAAE,SAAAC,EAAU,UAAAC,GAAcH,GAAYC,CAAE,EAC9C,UAAWxV,KAAOyV,EAChB,GAAI,CAACrS,EAAK,QAAQ,SAASpD,CAAG,EAC5B,MAAM,IAAIjH,EAAoBiH,EAAKoD,EAAK,OAAO,EAGnD,UAAWpD,KAAO0V,EAChB,GAAI,CAACrS,EAAM,QAAQ,SAASrD,CAAG,EAC7B,MAAM,IAAIjH,EAAoBiH,EAAKqD,EAAM,OAAO,EAGpD,GAAIwT,IAAQ,QAAUpB,EAAS,SAAW,GAAKC,EAAU,SAAW,EAAG,CACrE,MAAMgB,EAAatT,EAAK,IAAIqS,EAAS,CAAC,CAAC,EAAE,OACnCe,EAAcnT,EAAM,IAAIqS,EAAU,CAAC,CAAC,EAAE,OACtCoB,EAAkC,IAAI,IAC5C,IAAIC,EAAiB,GACrB,QAAShd,EAAI,EAAGA,EAAIsJ,EAAM,OAAQtJ,IAAK,CACrC,MAAMiG,EAAMqV,GAAmBmB,EAAY,IAAIzc,CAAC,CAAC,EACjD,GAAIiG,IAAQ,KACZ,IAAI8W,EAAgB,IAAI9W,CAAG,EAAG,CAC5B+W,EAAiB,GACjB,KACF,CACAD,EAAgB,IAAI9W,EAAKjG,CAAC,EAC5B,CACA,GAAIgd,EAAgB,CAClB,MAAMvC,EAAiC,IAAI,IACrCC,EAAe,CAAA,EACrB,UAAWlO,KAAWnD,EAAK,QACzBoR,EAAe,IAAIjO,EAASnD,EAAK,IAAImD,CAAO,EAAE,MAAM,EACpDkO,EAAa,KAAKlO,CAAO,EAE3B,MAAMyQ,EAAmB3T,EAAM,QAAQ,OAAQiE,GAAMA,IAAMoO,EAAU,CAAC,CAAC,EACjEuB,EAAmC,IAAI,IAC7C,UAAWnB,KAAMkB,EACfC,EAAiB,IAAInB,EAAI1S,EAAK,QAAQ,SAAS0S,CAAE,EAAI,GAAGA,CAAE,GAAGnZ,CAAM,GAAKmZ,CAAE,EAE5E,UAAWvP,KAAWyQ,EAAkB,CACtC,MAAMjB,EAAS1S,EAAM,IAAIkD,CAAO,EAAE,OAC5BvL,EAAS,IAAI,MAAMoI,EAAK,MAAM,EACpC,QAAS4S,EAAK,EAAGA,EAAK5S,EAAK,OAAQ4S,IAAM,CACvC,MAAMhW,EAAMqV,GAAmBqB,EAAW,IAAIV,CAAE,CAAC,EACjD,GAAIhW,IAAQ,KAAM,CAChBhF,EAAOgb,CAAE,EAAI,KACb,QACF,CACA,MAAMC,GAAKa,EAAgB,IAAI9W,CAAG,EAClChF,EAAOgb,CAAE,EAAIC,KAAO,OAAS,KAAOF,EAAO,IAAIE,EAAE,CACnD,CACA,MAAMC,EAAae,EAAiB,IAAI1Q,CAAO,EAC/CiO,EAAe,IAAI0B,EAAYZ,GAAsBS,EAAO,MAAO/a,CAAM,CAAC,EAC1EyZ,EAAa,KAAKyB,CAAU,CAC9B,CACA,MAAMxB,EAAQtR,EAAK,YACnB,OAAO,IAAIsR,EAAMF,EAAgBC,CAAY,CAC/C,CACF,CACA,MAAM4B,EAAeX,EAAU,IAAKzC,GAAM5P,EAAM,IAAI4P,CAAC,EAAE,MAAM,EACvDiE,EAA4B,IAAI,IACtC,GAAIb,EAAa,SAAW,EAAG,CAC7B,MAAMG,EAAcH,EAAa,CAAC,EAClC,QAAStc,EAAI,EAAGA,EAAIsJ,EAAM,OAAQtJ,IAAK,CACrC,MAAMiG,EAAMqV,GAAmBmB,EAAY,IAAIzc,CAAC,CAAC,EACjD,GAAIiG,IAAQ,KAAM,SAClB,MAAMmX,EAASD,EAAU,IAAIlX,CAAG,EAC5BmX,IAAW,OACbD,EAAU,IAAIlX,EAAKjG,CAAC,EACX,OAAOod,GAAW,SAC3BD,EAAU,IAAIlX,EAAK,CAACmX,EAAQpd,CAAC,CAAC,EAE9Bod,EAAO,KAAKpd,CAAC,CAEjB,CACF,KACE,SAASA,EAAI,EAAGA,EAAIsJ,EAAM,OAAQtJ,IAAK,CACrC,MAAMmZ,EAASkC,GAAaiB,EAActc,CAAC,EAC3C,GAAImZ,IAAW,KAAM,SACrB,MAAMiE,EAASD,EAAU,IAAIhE,CAAM,EAC/BiE,IAAW,OACbD,EAAU,IAAIhE,EAAQ,CAACnZ,CAAC,CAAC,EAChB,OAAOod,GAAW,SAC3BD,EAAU,IAAIhE,EAAQ,CAACiE,EAAQpd,CAAC,CAAC,EAEjCod,EAAO,KAAKpd,CAAC,CAEjB,CAEF,MAAMuc,EAAcb,EAAS,IAAKxC,GAAM7P,EAAK,IAAI6P,CAAC,EAAE,MAAM,EACpDmE,EAAc,CAAA,EACdC,EAAe,CAAA,EACfC,EAAe,IAAI,WAAWjU,EAAM,MAAM,EAChD,GAAIiT,EAAY,SAAW,EAAG,CAC5B,MAAMI,EAAaJ,EAAY,CAAC,EAChC,QAASvc,EAAI,EAAGA,EAAIqJ,EAAK,OAAQrJ,IAAK,CACpC,MAAMiG,EAAMqV,GAAmBqB,EAAW,IAAI3c,CAAC,CAAC,EAChD,GAAIiG,IAAQ,KAAM,EACZ6W,IAAQ,QAAUA,IAAQ,WAC5BO,EAAY,KAAKrd,CAAC,EAClBsd,EAAa,KAAK,IAAI,GAExB,QACF,CACA,MAAME,EAAUL,EAAU,IAAIlX,CAAG,EACjC,GAAIuX,IAAY,OACd,GAAI,OAAOA,GAAY,SACrBH,EAAY,KAAKrd,CAAC,EAClBsd,EAAa,KAAKE,CAAO,GACrBV,IAAQ,SAAWA,IAAQ,WAC7BS,EAAaC,CAAO,EAAI,OAG1B,SAASC,EAAK,EAAGA,EAAKD,EAAQ,OAAQC,IAAM,CAC1C,MAAMvB,EAAKsB,EAAQC,CAAE,EACrBJ,EAAY,KAAKrd,CAAC,EAClBsd,EAAa,KAAKpB,CAAE,GAChBY,IAAQ,SAAWA,IAAQ,WAC7BS,EAAarB,CAAE,EAAI,EAEvB,MAEOY,IAAQ,QAAUA,IAAQ,WACnCO,EAAY,KAAKrd,CAAC,EAClBsd,EAAa,KAAK,IAAI,EAE1B,CACF,KACE,SAAStd,EAAI,EAAGA,EAAIqJ,EAAK,OAAQrJ,IAAK,CACpC,MAAMmZ,EAASkC,GAAakB,EAAavc,CAAC,EAC1C,GAAImZ,IAAW,KAAM,EACf2D,IAAQ,QAAUA,IAAQ,WAC5BO,EAAY,KAAKrd,CAAC,EAClBsd,EAAa,KAAK,IAAI,GAExB,QACF,CACA,MAAME,EAAUL,EAAU,IAAIhE,CAAM,EACpC,GAAIqE,IAAY,OACd,GAAI,OAAOA,GAAY,SACrBH,EAAY,KAAKrd,CAAC,EAClBsd,EAAa,KAAKE,CAAO,GACrBV,IAAQ,SAAWA,IAAQ,WAC7BS,EAAaC,CAAO,EAAI,OAG1B,SAASC,EAAK,EAAGA,EAAKD,EAAQ,OAAQC,IAAM,CAC1C,MAAMvB,EAAKsB,EAAQC,CAAE,EACrBJ,EAAY,KAAKrd,CAAC,EAClBsd,EAAa,KAAKpB,CAAE,GAChBY,IAAQ,SAAWA,IAAQ,WAC7BS,EAAarB,CAAE,EAAI,EAEvB,MAEOY,IAAQ,QAAUA,IAAQ,WACnCO,EAAY,KAAKrd,CAAC,EAClBsd,EAAa,KAAK,IAAI,EAE1B,CAEF,GAAIR,IAAQ,SAAWA,IAAQ,QAC7B,QAAS9c,EAAI,EAAGA,EAAIsJ,EAAM,OAAQtJ,IAC5Bud,EAAavd,CAAC,IAAM,IACtBqd,EAAY,KAAK,EAAE,EACnBC,EAAa,KAAKtd,CAAC,GAIzB,MAAM2Z,EAAgC,IAAI,IACpClD,EAAc,CAAA,EACdoF,EAAewB,EAAY,OAC3BK,EAAkBpU,EAAM,QAAQ,OAAQiE,GAAM,CAACoO,EAAU,SAASpO,CAAC,CAAC,EACpEoQ,EAAiBtU,EAAK,QAAQ,OAAQkE,GAAM,CAACmO,EAAS,SAASnO,CAAC,CAAC,EACjEuO,EAAkC,IAAI,IAC5C,UAAWC,KAAM2B,EACXrU,EAAK,QAAQ,SAAS0S,CAAE,EAC1BD,EAAgB,IAAIC,EAAI,GAAGA,CAAE,GAAGnZ,CAAM,EAAE,EAExCkZ,EAAgB,IAAIC,EAAIA,CAAE,EAG9B,QAASnC,EAAK,EAAGA,EAAK8B,EAAS,OAAQ9B,IAAM,CAC3C,MAAMgE,EAAUlC,EAAS9B,CAAE,EACrBiE,EAAWlC,EAAU/B,CAAE,EACvBkE,EAAUzU,EAAK,IAAIuU,CAAO,EAAE,OAC5BG,EAAWzU,EAAM,IAAIuU,CAAQ,EAAE,OAC/B5c,EAAS,IAAI,MAAM4a,CAAY,EACrC,QAAS7b,EAAI,EAAGA,EAAI6b,EAAc7b,IAAK,CACrC,MAAMic,EAAKoB,EAAYrd,CAAC,EAClBkc,EAAKoB,EAAatd,CAAC,EACrBic,GAAM,EACRhb,EAAOjB,CAAC,EAAI8d,EAAQ,IAAI7B,CAAE,EACjBC,IAAO,KAChBjb,EAAOjB,CAAC,EAAI+d,EAAS,IAAI7B,CAAE,EAE3Bjb,EAAOjB,CAAC,EAAI,IAEhB,CACA2Z,EAAc,IAAIiE,EAASrC,GAAsBuC,EAAQ,MAAO7c,CAAM,CAAC,EACvEwV,EAAY,KAAKmH,CAAO,CAC1B,CACA,UAAWpR,KAAWmR,EAAgB,CACpC,MAAM3B,EAAS3S,EAAK,IAAImD,CAAO,EAAE,OAC3BvL,EAAS,IAAI,MAAM4a,CAAY,EACrC,QAAS7b,EAAI,EAAGA,EAAI6b,EAAc7b,IAAK,CACrC,MAAMic,EAAKoB,EAAYrd,CAAC,EACxBiB,EAAOjB,CAAC,EAAIic,GAAM,EAAID,EAAO,IAAIC,CAAE,EAAI,IACzC,CACAtC,EAAc,IAAInN,EAAS+O,GAAsBS,EAAO,MAAO/a,CAAM,CAAC,EACtEwV,EAAY,KAAKjK,CAAO,CAC1B,CACA,UAAWA,KAAWkR,EAAiB,CACrC,MAAM1B,EAAS1S,EAAM,IAAIkD,CAAO,EAAE,OAC5B2P,EAAaL,EAAgB,IAAItP,CAAO,EACxCvL,EAAS,IAAI,MAAM4a,CAAY,EACrC,QAAS7b,EAAI,EAAGA,EAAI6b,EAAc7b,IAAK,CACrC,MAAMkc,EAAKoB,EAAatd,CAAC,EACrBkc,IAAO,KACTjb,EAAOjB,CAAC,EAAIgc,EAAO,IAAIE,CAAE,EAEzBjb,EAAOjB,CAAC,EAAI,IAEhB,CACA2Z,EAAc,IAAIwC,EAAYZ,GAAsBS,EAAO,MAAO/a,CAAM,CAAC,EACzEwV,EAAY,KAAK0F,CAAU,CAC7B,CACA,MAAMpC,EAAO1Q,EAAK,YAClB,OAAO,IAAI0Q,EAAKJ,EAAelD,CAAW,CAC5C,CAGA,SAASuH,GAAcxX,EAAS5G,EAAO,CACrC,MAAMwS,EAAQ,CAAA,EACd,UAAWnT,KAAUuH,EAAS,CAC5B,MAAMrF,EAAIlC,EAAO,IAAIW,CAAK,EAC1B,GAAIuB,IAAM,KACR,OAAO,KACEA,aAAa,KACtBiR,EAAM,KAAK,MAAMjR,EAAE,QAAO,CAAE,EAAE,EACrB,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAAY,OAAOA,GAAM,UACxEiR,EAAM,KAAK,KAAK,OAAOjR,CAAC,GAAG,OAAOA,CAAC,CAAC,EAAE,EAEtCiR,EAAM,KAAK,QAAQ,KAAK,UAAUjR,CAAC,CAAC,EAAE,CAE1C,CACA,OAAOiR,EAAM,KAAK,GAAG,CACvB,CACA,SAAS6L,GAAuBxX,EAAOxF,EAAQ,CAC7C,OAAQwF,EAAK,CACX,IAAK,MACH,OAAOpG,EAAc,KAAKY,CAAM,EAClC,IAAK,MACH,OAAOG,GAAY,KAAKH,CAAM,EAChC,IAAK,OACH,OAAOK,EAAW,KAAKL,CAAM,EAC/B,IAAK,OACH,OAAOkB,EAAc,KAAKlB,CAAM,EAClC,IAAK,OACH,OAAOoB,EAAW,KAAKpB,CAAM,EAC/B,QACE,OAAO,IAAIsB,GAAatB,CAAM,CACpC,CACA,CACA,SAASid,GAAO7U,EAAMC,EAAOmS,EAAIxa,EAAQ,CACvC,GAAI,CAACoI,EAAK,QAAQ,SAASoS,CAAE,EAC3B,MAAM,IAAIzc,EAAoByc,EAAIpS,EAAK,OAAO,EAEhD,GAAI,CAACC,EAAM,QAAQ,SAASmS,CAAE,EAC5B,MAAM,IAAIzc,EAAoByc,EAAInS,EAAM,OAAO,EAEjD,MAAM6U,EAAYld,GAAUqI,EAAM,QAAQ,OAAQiE,GAAMA,IAAMkO,CAAE,EAChE,UAAWzY,KAAQmb,EACjB,GAAI,CAAC7U,EAAM,QAAQ,SAAStG,CAAI,EAC9B,MAAM,IAAIhE,EAAoBgE,EAAMsG,EAAM,OAAO,EAGrD,MAAMmT,EAAc,CAACnT,EAAM,IAAImS,CAAE,EAAE,MAAM,EACnC2C,EAA4B,IAAI,IACtC,QAASpe,EAAI,EAAGA,EAAIsJ,EAAM,OAAQtJ,IAAK,CACrC,MAAMmZ,EAAS6E,GAAcvB,EAAazc,CAAC,EACvCmZ,IAAW,OACViF,EAAU,IAAIjF,CAAM,GACvBiF,EAAU,IAAIjF,EAAQnZ,CAAC,EAE3B,CACA,MAAM2c,EAAa,CAACtT,EAAK,IAAIoS,CAAE,EAAE,MAAM,EACjC9B,EAAgC,IAAI,IACpClD,EAAc,CAAA,EACpB,UAAWjK,KAAWnD,EAAK,QACzBsQ,EAAc,IAAInN,EAASnD,EAAK,IAAImD,CAAO,EAAE,MAAM,EACnDiK,EAAY,KAAKjK,CAAO,EAE1B,UAAWA,KAAW2R,EAAW,CAC/B,MAAMnC,EAAS1S,EAAM,IAAIkD,CAAO,EAAE,OAC5BqN,EAAO,IAAI,MAAMxQ,EAAK,MAAM,EAClC,QAASrJ,EAAI,EAAGA,EAAIqJ,EAAK,OAAQrJ,IAAK,CACpC,MAAMmZ,EAAS6E,GAAcrB,EAAY3c,CAAC,EAC1C,GAAImZ,IAAW,KAAM,CACnB,MAAM+C,EAAKkC,EAAU,IAAIjF,CAAM,EAC/BU,EAAK7Z,CAAC,EAAIkc,IAAO,OAASF,EAAO,IAAIE,CAAE,EAAI,IAC7C,MACErC,EAAK7Z,CAAC,EAAI,IAEd,CACA,MAAMmc,GAAa9S,EAAK,QAAQ,SAASmD,CAAO,EAAIA,GACpDmN,EAAc,IAAIwC,EAAY8B,GAAuBjC,EAAO,MAAOnC,CAAI,CAAC,EACxEpD,EAAY,KAAK0F,CAAU,CAC7B,CACA,MAAMpC,EAAO1Q,EAAK,YAClB,OAAO,IAAI0Q,EAAKJ,EAAelD,CAAW,CAC5C,CAGA,SAAS4H,GAAOnV,EAAKjK,EAAQkM,EAAU,CAAA,EAAI,CACzC,GAAI,CAACjC,EAAI,QAAQ,SAASjK,CAAM,EAC9B,MAAM,IAAID,EAAoBC,EAAQiK,EAAI,OAAO,EAEnD,KAAM,CAAE,MAAAoV,EAAO,KAAMC,EAAQ,KAAAC,EAAO,EAAK,EAAKrT,EACxC6Q,EAAS9S,EAAI,IAAIjK,CAAM,EAAE,OACzBwC,EAAMyH,EAAI,OAChB,IAAIuV,EAAW,GACXC,EAAc,EAClB,MAAMC,EAA6B,IAAI,IACvC,QAAS3e,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMgB,EAAMgb,EAAO,IAAIhc,CAAC,EACxB,GAAIgB,IAAQ,MACZ,GAAI,MAAM,QAAQA,CAAG,EACnB0d,EAAc,KAAK,IAAIA,EAAa1d,EAAI,MAAM,UACrC,OAAOA,GAAQ,SAAU,CAClCyd,EAAW,GACX,UAAWxY,KAAO,OAAO,KAAKjF,CAAG,EAC/B2d,EAAW,IAAI1Y,CAAG,CAEtB,EACF,CACA,MAAM0T,EAAgC,IAAI,IACpClD,EAAc,CAAA,EACpB,UAAWjK,KAAWtD,EAAI,QACpBsV,GAAQhS,IAAYvN,IACxB0a,EAAc,IAAInN,EAAStD,EAAI,IAAIsD,CAAO,EAAE,MAAM,EAClDiK,EAAY,KAAKjK,CAAO,GAE1B,GAAIiS,EAAU,CACZ,MAAMxF,EAAO,CAAC,GAAG0F,CAAU,EACrBC,EAAgBN,IAAU,OAASrF,EAAK,MAAM,EAAGqF,CAAK,EAAIrF,EAChE,UAAWhT,KAAO2Y,EAAe,CAC/B,MAAMC,EAAUN,EAASA,EAAOtf,EAAQgH,CAAG,EAAI,GAAGhH,CAAM,IAAIgH,CAAG,GACzDhF,EAAS,IAAI,MAAMQ,CAAG,EAC5B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMgB,EAAMgb,EAAO,IAAIhc,CAAC,EACxB,GAAIgB,IAAQ,MAAQ,OAAOA,GAAQ,UAAY,MAAM,QAAQA,CAAG,EAC9DC,EAAOjB,CAAC,EAAI,SACP,CACL,MAAM0R,EAAM1Q,EACZC,EAAOjB,CAAC,EAAIiG,KAAOyL,EAAMA,EAAIzL,CAAG,EAAI,IACtC,CACF,CACA0T,EAAc,IAAIkF,EAAStc,GAAa,KAAKtB,CAAM,CAAC,EACpDwV,EAAY,KAAKoI,CAAO,CAC1B,CACF,KAAO,CACL,MAAMzJ,EAAQkJ,IAAU,OAAS,KAAK,IAAII,EAAaJ,CAAK,EAAII,EAChE,QAAS7d,EAAM,EAAGA,EAAMuU,EAAOvU,IAAO,CACpC,MAAMge,EAAUN,EAASA,EAAOtf,EAAQ4B,CAAG,EAAI,GAAG5B,CAAM,IAAI,OAAO4B,CAAG,CAAC,GACjEI,EAAS,IAAI,MAAMQ,CAAG,EAC5B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMgB,EAAMgb,EAAO,IAAIhc,CAAC,EACpBgB,IAAQ,MAAQ,CAAC,MAAM,QAAQA,CAAG,GAAKH,GAAOG,EAAI,OACpDC,EAAOjB,CAAC,EAAI,KAEZiB,EAAOjB,CAAC,EAAIgB,EAAIH,CAAG,CAEvB,CACA8Y,EAAc,IAAIkF,EAAStc,GAAa,KAAKtB,CAAM,CAAC,EACpDwV,EAAY,KAAKoI,CAAO,CAC1B,CACF,CACA,MAAM9E,EAAO7Q,EAAI,YACjB,OAAO,IAAI6Q,EAAKJ,EAAelD,CAAW,CAC5C,CAGA,SAASqI,GAAO5V,EAAK1C,EAAS2E,EAAU,CAAA,EAAI,CAC1C,MAAMmF,EAAO,MAAM,QAAQ9J,CAAO,EAAIA,EAAU,CAACA,CAAO,EACxD,UAAW+G,KAAK+C,EACd,GAAI,CAACpH,EAAI,QAAQ,SAASqE,CAAC,EACzB,MAAM,IAAIvO,EAAoBuO,EAAGrE,EAAI,OAAO,EAGhD,MAAMzH,EAAMyH,EAAI,OACV6V,EAAgB7V,EAAI,QAAQ,OAAQqE,GAAM,CAAC+C,EAAK,SAAS/C,CAAC,CAAC,EAC3DyR,EAAY,IAAI,MAAMvd,CAAG,EAC/B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,IAAIif,EAAS,EACb,UAAW1R,KAAK+C,EAAM,CACpB,MAAMtP,EAAMkI,EAAI,IAAIqE,CAAC,EAAE,OAAO,IAAIvN,CAAC,EAC/B,MAAM,QAAQgB,CAAG,IACnBie,EAAS,KAAK,IAAIA,EAAQje,EAAI,MAAM,EAExC,CACAge,EAAUhf,CAAC,EAAIif,CACjB,CACA,MAAMC,EAAYF,EAAU,OAAO,CAAC7a,EAAGC,IAAMD,EAAIC,EAAG,CAAC,EAC/C+a,EAAa,CAAA,EACnB,UAAW5R,KAAKwR,EACdI,EAAW5R,CAAC,EAAI,IAAI,MAAM2R,CAAS,EAErC,UAAW3R,KAAK+C,EACd6O,EAAW5R,CAAC,EAAI,IAAI,MAAM2R,CAAS,EAErC,IAAIE,EACAjU,EAAQ,QACViU,EAAY,IAAI,MAAMF,CAAS,GAEjC,IAAIG,EAAS,EACb,QAASrf,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAM7B,EAAQ6gB,EAAUhf,CAAC,EACzB,GAAI7B,IAAU,EACd,QAASoV,EAAI,EAAGA,EAAIpV,EAAOoV,IAAK,CAC9B,UAAWhG,KAAKwR,EACdI,EAAW5R,CAAC,EAAE8R,CAAM,EAAInW,EAAI,IAAIqE,CAAC,EAAE,OAAO,IAAIvN,CAAC,EAEjD,UAAWuN,KAAK+C,EAAM,CACpB,MAAMtP,EAAMkI,EAAI,IAAIqE,CAAC,EAAE,OAAO,IAAIvN,CAAC,EAC/B,MAAM,QAAQgB,CAAG,GAAKuS,EAAIvS,EAAI,OAChCme,EAAW5R,CAAC,EAAE8R,CAAM,EAAIre,EAAIuS,CAAC,EAE7B4L,EAAW5R,CAAC,EAAE8R,CAAM,EAAI,IAE5B,CACID,IACFA,EAAUC,CAAM,EAAI9L,GAEtB8L,GACF,CACF,CACA,MAAM1F,EAAgC,IAAI,IACpClD,EAAc,CAAA,EACpB,UAAWlJ,KAAKrE,EAAI,QAClByQ,EAAc,IAAIpM,EAAGhL,GAAa,KAAK4c,EAAW5R,CAAC,CAAC,CAAC,EACrDkJ,EAAY,KAAKlJ,CAAC,EAEhBpC,EAAQ,OAASiU,IACnBzF,EAAc,IAAIxO,EAAQ,MAAO5I,GAAa,KAAK6c,CAAS,CAAC,EAC7D3I,EAAY,KAAKtL,EAAQ,KAAK,GAEhC,MAAM4O,EAAO7Q,EAAI,YACjB,OAAO,IAAI6Q,EAAKJ,EAAelD,CAAW,CAC5C,CAGA,SAAS6I,GAAOhT,EAAK2M,EAAM,CACzB,OAAOA,EAAK,IAAKC,GAAM,CACrB,MAAMnZ,EAAQuM,EAAI4M,CAAC,EACnB,OAAInZ,IAAU,KAAa,WACvBA,aAAiB,KAAa,WAAW,OAAOA,EAAM,QAAO,CAAE,CAAC,GAC7D,KAAK,OAAOA,CAAK,KAAK,KAAK,UAAUA,CAAK,CAAC,EACpD,CAAC,EAAE,KAAK,GAAG,CACb,CACA,SAASwf,GAAUte,EAAQ,CACzB,GAAIA,EAAO,SAAW,EAAG,MAAO,CAAC,CAAA,CAAE,EACnC,IAAIue,EAAM,CAAC,EAAE,EACb,UAAW1Z,KAAO7E,EAAQ,CACxB,MAAMwe,EAAO,CAAA,EACb,UAAW9c,KAAU6c,EACnB,UAAWE,KAAQ5Z,EACjB2Z,EAAK,KAAK,CAAC,GAAG9c,EAAQ+c,CAAI,CAAC,EAG/BF,EAAMC,CACR,CACA,OAAOD,CACT,CACA,SAASG,GAAOzW,EAAKjI,EAAQkK,EAAU,CAAA,EAAI,CACzC,UAAWqB,KAAW,OAAO,KAAKvL,CAAM,EACtC,GAAI,CAACiI,EAAI,QAAQ,SAASsD,CAAO,EAC/B,MAAM,IAAIxN,EAAoBwN,EAAStD,EAAI,OAAO,EAGtD,MAAM0W,EAAazU,EAAQ,QAAU,CAAA,EACrC,UAAWlF,KAAO2Z,EAChB,GAAI,CAAC1W,EAAI,QAAQ,SAASjD,CAAG,EAC3B,MAAM,IAAIjH,EAAoBiH,EAAKiD,EAAI,OAAO,EAGlD,MAAM2W,EAAa3W,EAAI,QAAO,EAC9B,IAAI4W,EAAcD,EAClB,GAAID,EAAW,OAAS,EAAG,CACzB,MAAMG,EAAaH,EAAW,IAAK3Z,GAAQ,CACzC,MAAMD,EAAuB,IAAI,IAC3BwZ,EAAM,CAAA,EACZ,UAAWlT,KAAOuT,EAAY,CAC5B,MAAMpT,EAAMH,EAAIrG,CAAG,EACb+Z,EAAavT,aAAe,KAAO,KAAK,OAAOA,EAAI,QAAO,CAAE,CAAC,GAAK,KAAK,UAAUA,CAAG,EACrFzG,EAAK,IAAIga,CAAU,IACtBha,EAAK,IAAIga,CAAU,EACnBR,EAAI,KAAK/S,GAAO,IAAI,EAExB,CACA,OAAO+S,CACT,CAAC,EACKS,EAASV,GAAUQ,CAAU,EAC7BG,EAA2B,IAAI,IACrC,UAAW5T,KAAOuT,EAChBK,EAAS,IAAIZ,GAAOhT,EAAKsT,CAAU,EAAGtT,CAAG,EAE3CwT,EAAcG,EAAO,IAAKE,GAAU,CAClC,MAAMC,EAAW,CAAA,EACjB,QAASpgB,EAAI,EAAGA,EAAI4f,EAAW,OAAQ5f,IACrCogB,EAASR,EAAW5f,CAAC,CAAC,EAAImgB,EAAMngB,CAAC,GAAK,KAExC,MAAMqgB,EAAcH,EAAS,IAAIZ,GAAOc,EAAUR,CAAU,CAAC,EAC7D,GAAIS,EACF,OAAOA,EAET,MAAMC,EAAY,CAAA,EAClB,UAAW9T,KAAWtD,EAAI,QACxBoX,EAAU9T,CAAO,EAAI4T,EAAS5T,CAAO,GAAK,KAE5C,OAAO8T,CACT,CAAC,CACH,CACA,MAAMC,EAAa,CAAA,EACnB,UAAW/T,KAAWtD,EAAI,QACxBqX,EAAW/T,CAAO,EAAIsT,EAAY,IAAKxT,GAAQA,EAAIE,CAAO,GAAK,IAAI,EAErE,MAAMgU,EAAiB,CAAA,EACvB,SAAW,CAAChU,EAAS+L,CAAI,IAAK,OAAO,QAAQtX,CAAM,EACjDuf,EAAehU,CAAO,EAAI,OAAO+L,GAAS,WAAaA,EAAKgI,CAAU,EAAIhI,EAE5E,MAAMkI,EAAaX,EAAY,IAAKxT,GAAQ,CAC1C,MAAMmT,EAAO,CAAE,GAAGnT,CAAG,EACrB,SAAW,CAACE,EAASkU,CAAS,IAAK,OAAO,QAAQF,CAAc,GACzDf,EAAKjT,CAAO,GAAK,QAAU,OAC9BiT,EAAKjT,CAAO,EAAIkU,GAGpB,OAAOjB,CACT,CAAC,EACD,OAAOvW,EAAI,YAAY,SAASuX,CAAU,CAC5C,CAGA,SAASE,GAAU1f,EAAQ2f,EAAS,CAClC,OAAQA,EAAO,CACb,IAAK,QACH,OAAO3f,EAAO,OAAS,EAAIA,EAAO,CAAC,EAAI,KACzC,IAAK,OACH,OAAOA,EAAO,OAAS,EAAIA,EAAOA,EAAO,OAAS,CAAC,EAAI,KACzD,IAAK,QACH,OAAOA,EAAO,OAChB,IAAK,MAAO,CACV,IAAIH,EAAQ,EACZ,UAAWK,KAAKF,EACV,OAAOE,GAAM,WAAUL,GAASK,GAEtC,OAAOL,CACT,CACA,IAAK,OAAQ,CACX,IAAIA,EAAQ,EACR3C,EAAQ,EACZ,UAAWgD,KAAKF,EACV,OAAOE,GAAM,WACfL,GAASK,EACThD,KAGJ,OAAOA,EAAQ,EAAI2C,EAAQ3C,EAAQ,IACrC,CACJ,CACA,CACA,SAAS0iB,GAAc3X,EAAKtJ,EAAOkhB,EAAW,CAC5C,MAAM1O,EAAQ,CAAA,EACd,UAAW/M,KAAQyb,EAAW,CAC5B,MAAM3f,EAAI+H,EAAI,IAAI7D,CAAI,EAAE,IAAIzF,CAAK,EAC7BuB,IAAM,KACRiR,EAAM,KAAK,QAAQ,EACVjR,aAAa,KACtBiR,EAAM,KAAK,MAAMjR,EAAE,QAAO,CAAE,EAAE,EACrB,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAAY,OAAOA,GAAM,UACxEiR,EAAM,KAAK,KAAK,OAAOjR,CAAC,GAAG,OAAOA,CAAC,CAAC,EAAE,EAEtCiR,EAAM,KAAK,QAAQ,KAAK,UAAUjR,CAAC,CAAC,EAAE,CAE1C,CACA,OAAOiR,EAAM,KAAK,GAAG,CACvB,CACA,SAAS2O,GAAuBta,EAAOxF,EAAQ,CAC7C,OAAQwF,EAAK,CACX,IAAK,MACH,OAAOpG,EAAc,KAAKY,CAAM,EAClC,IAAK,MACH,OAAOG,GAAY,KAAKH,CAAM,EAChC,IAAK,OACH,OAAOK,EAAW,KAAKL,CAAM,EAC/B,IAAK,OACH,OAAOkB,EAAc,KAAKlB,CAAM,EAClC,IAAK,OACH,OAAOoB,EAAW,KAAKpB,CAAM,EAC/B,QACE,OAAOZ,EAAc,KAAKY,CAAM,CACtC,CACA,CACA,SAAS+f,GAAM9X,EAAKiC,EAAS,CAC3B,MAAM2V,EAAY,MAAM,QAAQ3V,EAAQ,KAAK,EAAIA,EAAQ,MAAQ,CAACA,EAAQ,KAAK,EACzE8V,EAAa9V,EAAQ,QACrB+V,EAAY/V,EAAQ,OACpByV,EAAUzV,EAAQ,SAAW,QACnC,UAAWnI,IAAQ,CAAC,GAAG8d,EAAWG,EAAYC,CAAS,EACrD,GAAI,CAAChY,EAAI,QAAQ,SAASlG,CAAI,EAC5B,MAAM,IAAIhE,EAAoBgE,EAAMkG,EAAI,OAAO,EAGnD,MAAMiY,EAAgB,CAAA,EAChBC,EAAuC,IAAI,IACjD,QAASphB,EAAI,EAAGA,EAAIkJ,EAAI,OAAQlJ,IAAK,CACnC,MAAMiG,EAAM4a,GAAc3X,EAAKlJ,EAAG8gB,CAAS,EACtCM,EAAqB,IAAInb,CAAG,IAC/Bkb,EAAc,KAAKlb,CAAG,EACtBmb,EAAqB,IAAInb,EAAK,EAAE,GAElCmb,EAAqB,IAAInb,CAAG,EAAE,KAAKjG,CAAC,CACtC,CACA,MAAMqhB,EAAiB,CAAA,EACjBC,EAA8B,IAAI,IAClCC,EAAoBrY,EAAI,IAAI+X,CAAU,EAC5C,QAASjhB,EAAI,EAAGA,EAAIkJ,EAAI,OAAQlJ,IAAK,CACnC,MAAMmB,EAAIogB,EAAkB,IAAIvhB,CAAC,EACjC,IAAIwhB,EACArgB,IAAM,KACRqgB,EAAM,OACG,OAAOrgB,GAAM,UAAY,OAAOA,GAAM,UAAY,OAAOA,GAAM,UACxEqgB,EAAM,OAAOrgB,CAAC,EACLA,aAAa,KACtBqgB,EAAMrgB,EAAE,YAAW,EAEnBqgB,EAAM,KAAK,UAAUrgB,CAAC,EAEnBmgB,EAAY,IAAIE,CAAG,IACtBF,EAAY,IAAIE,CAAG,EACnBH,EAAe,KAAKG,CAAG,EAE3B,CACA,MAAMC,EAA2B,IAAI,IACrC,QAASzhB,EAAI,EAAGA,EAAIkJ,EAAI,OAAQlJ,IAAK,CACnC,MAAM0hB,EAAWb,GAAc3X,EAAKlJ,EAAG8gB,CAAS,EAC1Ca,EAAWJ,EAAkB,IAAIvhB,CAAC,EACxC,IAAI4hB,EACAD,IAAa,KACfC,EAAW,OACF,OAAOD,GAAa,UAAY,OAAOA,GAAa,UAAY,OAAOA,GAAa,UAC7FC,EAAW,OAAOD,CAAQ,EACjBA,aAAoB,KAC7BC,EAAWD,EAAS,YAAW,EAE/BC,EAAW,KAAK,UAAUD,CAAQ,EAEpC,MAAME,EAAUH,EAAW,IAAME,EAC5BH,EAAS,IAAII,CAAO,GACvBJ,EAAS,IAAII,EAAS,EAAE,EAE1BJ,EAAS,IAAII,CAAO,EAAE,KAAK3Y,EAAI,IAAIgY,CAAS,EAAE,IAAIlhB,CAAC,CAAC,CACtD,CACA,MAAM8hB,EAAc5Y,EAAI,IAAIgY,CAAS,EAAE,OAAO,MACxCa,EAAcnB,IAAY,QAAU,MAAsBkB,EAC1DnI,EAAgC,IAAI,IACpClD,EAAc,CAAA,EACpB,UAAWuL,KAAUlB,EAAW,CAC9B,MAAMjH,EAAO,CAAA,EACPO,EAAYlR,EAAI,IAAI8Y,CAAM,EAChC,UAAW/b,KAAOkb,EAAe,CAC/B,MAAMlV,EAAWmV,EAAqB,IAAInb,CAAG,EAAE,CAAC,EAChD4T,EAAK,KAAKO,EAAU,IAAInO,CAAQ,CAAC,CACnC,CACA0N,EAAc,IAAIqI,EAAQjB,GAAuB3G,EAAU,OAAO,MAAOP,CAAI,CAAC,EAC9EpD,EAAY,KAAKuL,CAAM,CACzB,CACA,UAAWL,KAAYN,EAAgB,CACrC,MAAMxH,EAAO,CAAA,EACb,UAAW6H,KAAYP,EAAe,CACpC,MAAMU,EAAUH,EAAW,IAAMC,EAC3BM,EAAaR,EAAS,IAAII,CAAO,EACnCI,GAAcA,EAAW,OAAS,EACpCpI,EAAK,KAAK8G,GAAUsB,EAAYrB,CAAO,CAAC,EAExC/G,EAAK,KAAK,IAAI,CAElB,CACAF,EAAc,IAAIgI,EAAUZ,GAAuBgB,EAAalI,CAAI,CAAC,EACrEpD,EAAY,KAAKkL,CAAQ,CAC3B,CACA,MAAM5H,EAAO7Q,EAAI,YACjB,OAAO,IAAI6Q,EAAKJ,EAAelD,CAAW,CAC5C,CAGA,SAASyL,GAAuBzb,EAAOxF,EAAQ,CAC7C,OAAQwF,EAAK,CACX,IAAK,MACH,OAAOpG,EAAc,KAAKY,CAAM,EAClC,IAAK,MACH,OAAOG,GAAY,KAAKH,CAAM,EAChC,IAAK,OACH,OAAOK,EAAW,KAAKL,CAAM,EAC/B,IAAK,OACH,OAAOkB,EAAc,KAAKlB,CAAM,EAClC,IAAK,OACH,OAAOoB,EAAW,KAAKpB,CAAM,EAC/B,QACE,OAAOZ,EAAc,KAAKY,CAAM,CACtC,CACA,CACA,SAASkhB,GAAYlhB,EAAQ,CAC3B,UAAWE,KAAKF,EACd,GAAIE,GAAM,KACV,IAAI,OAAOA,GAAM,SAAU,OAAO,OAAO,UAAUA,CAAC,EAAI,MACxD,GAAI,OAAOA,GAAM,SAAU,MAAO,OAClC,GAAI,OAAOA,GAAM,UAAW,MAAO,OACnC,GAAIA,aAAa,KAAM,MAAO,OAEhC,MAAO,KACT,CACA,SAASihB,GAAKlZ,EAAKiC,EAAS,CAC1B,MAAMkX,EAAS,MAAM,QAAQlX,EAAQ,MAAM,EAAIA,EAAQ,OAAS,CAACA,EAAQ,MAAM,EACzEmX,EAAUnX,EAAQ,SAAW,WAC7BoX,EAAYpX,EAAQ,WAAa,QACvC,UAAWnI,KAAQqf,EACjB,GAAI,CAACnZ,EAAI,QAAQ,SAASlG,CAAI,EAC5B,MAAM,IAAIhE,EAAoBgE,EAAMkG,EAAI,OAAO,EAGnD,IAAIsZ,EACJ,GAAIrX,EAAQ,UAAW,CACrBqX,EAAY,MAAM,QAAQrX,EAAQ,SAAS,EAAIA,EAAQ,UAAY,CAACA,EAAQ,SAAS,EACrF,UAAWnI,KAAQwf,EACjB,GAAI,CAACtZ,EAAI,QAAQ,SAASlG,CAAI,EAC5B,MAAM,IAAIhE,EAAoBgE,EAAMkG,EAAI,OAAO,CAGrD,KAAO,CACL,MAAMuZ,EAAQ,IAAI,IAAIJ,CAAM,EAC5BG,EAAYtZ,EAAI,QAAQ,OAAQqE,GAAM,CAACkV,EAAM,IAAIlV,CAAC,CAAC,CACrD,CACA,MAAMmC,EAAQxG,EAAI,OACZwZ,EAAaF,EAAU,OACvB3G,EAAenM,EAAQgT,EACvB/I,EAAgC,IAAI,IACpClD,EAAc,CAAA,EACpB,UAAWkM,KAASN,EAAQ,CAC1B,MAAMO,EAAe1Z,EAAI,IAAIyZ,CAAK,EAC5B9I,EAAO,IAAI,MAAMgC,CAAY,EACnC,QAAS7b,EAAI,EAAGA,EAAI0P,EAAO1P,IAAK,CAC9B,MAAMmB,EAAIyhB,EAAa,IAAI5iB,CAAC,EAC5B,QAASuT,EAAI,EAAGA,EAAImP,EAAYnP,IAC9BsG,EAAK7Z,EAAI0iB,EAAanP,CAAC,EAAIpS,CAE/B,CACAwY,EAAc,IAAIgJ,EAAOT,GAAuBU,EAAa,OAAO,MAAO/I,CAAI,CAAC,EAChFpD,EAAY,KAAKkM,CAAK,CACxB,CACA,MAAME,EAAY,IAAI,MAAMhH,CAAY,EACxC,QAAS7b,EAAI,EAAGA,EAAI0P,EAAO1P,IACzB,QAASuT,EAAI,EAAGA,EAAImP,EAAYnP,IAC9BsP,EAAU7iB,EAAI0iB,EAAanP,CAAC,EAAIiP,EAAUjP,CAAC,EAG/CoG,EAAc,IAAI2I,EAAShhB,EAAW,KAAKuhB,CAAS,CAAC,EACrDpM,EAAY,KAAK6L,CAAO,EACxB,MAAMQ,EAAc,IAAI,MAAMjH,CAAY,EAC1C,QAAS7b,EAAI,EAAGA,EAAI0P,EAAO1P,IACzB,QAASuT,EAAI,EAAGA,EAAImP,EAAYnP,IAC9BuP,EAAY9iB,EAAI0iB,EAAanP,CAAC,EAAIrK,EAAI,IAAIsZ,EAAUjP,CAAC,CAAC,EAAE,IAAIvT,CAAC,EAGjE,MAAM+iB,EAAaZ,GAAYW,CAAW,EAC1CnJ,EAAc,IAAI4I,EAAWL,GAAuBa,EAAYD,CAAW,CAAC,EAC5ErM,EAAY,KAAK8L,CAAS,EAC1B,MAAMxI,EAAO7Q,EAAI,YACjB,OAAO,IAAI6Q,EAAKJ,EAAelD,CAAW,CAC5C,CAGA,SAASuM,GAAa/hB,EAAQ,CAC5B,UAAWE,KAAKF,EACd,GAAIE,GAAM,KACV,IAAI,OAAOA,GAAM,SAAU,MAAO,MAClC,GAAI,OAAOA,GAAM,SAAU,MAAO,OAClC,GAAI,OAAOA,GAAM,UAAW,MAAO,OACnC,GAAIA,aAAa,KAAM,MAAO,OAEhC,MAAO,KACT,CACA,SAAS8hB,GAAuBxc,EAAOxF,EAAQ,CAC7C,OAAQwF,EAAK,CACX,IAAK,MACH,OAAOpG,EAAc,KAAKY,CAAM,EAClC,IAAK,MACH,OAAOG,GAAY,KAAKH,CAAM,EAChC,IAAK,OACH,OAAOK,EAAW,KAAKL,CAAM,EAC/B,IAAK,OACH,OAAOkB,EAAc,KAAKlB,CAAM,EAClC,IAAK,OACH,OAAOoB,EAAW,KAAKpB,CAAM,EAC/B,QACE,OAAOZ,EAAc,KAAKY,CAAM,CACtC,CACA,CACA,SAASiiB,GAAe/hB,EAAG,CACzB,OAAIA,GAAM,KAA6B,OACnCA,aAAa,KAAaA,EAAE,YAAW,EACvC,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAC1D,OAAOA,CAAC,EAEV,KAAK,UAAUA,CAAC,CACzB,CACA,SAASgiB,GAAUja,EAAKka,EAAc,CACpC,MAAMrJ,EAAO7Q,EAAI,YACXwG,EAAQxG,EAAI,OACZoH,EAAOpH,EAAI,QACjB,GAAIoH,EAAK,SAAW,GAAKZ,IAAU,EACjC,OAAO,IAAIqK,EAAqB,IAAI,IAAO,CAAA,CAAE,EAE/C,IAAIsJ,EACAnL,EACJ,GAAIkL,EAAc,CAChB,MAAME,EAAepa,EAAI,IAAIka,CAAY,EACzCC,EAAa,CAAA,EACb,QAASrjB,EAAI,EAAGA,EAAI0P,EAAO1P,IACzBqjB,EAAW,KAAKH,GAAeI,EAAa,IAAItjB,CAAC,CAAC,CAAC,EAErDkY,EAAgB5H,EAAK,OAAQ/C,GAAMA,IAAM6V,CAAY,CACvD,KAAO,CACLC,EAAa,CAAA,EACb,QAASrjB,EAAI,EAAGA,EAAI0P,EAAO1P,IACzBqjB,EAAW,KAAK,OAAOrjB,CAAC,CAAC,EAE3BkY,EAAgB5H,CAClB,CACA,MAAMqJ,EAAgC,IAAI,IACpClD,EAAc,CAAC,QAAQ,EAC7BkD,EAAc,IAAI,SAAUrY,EAAW,KAAK4W,CAAa,CAAC,EAC1D,QAASqL,EAAS,EAAGA,EAAS7T,EAAO6T,IAAU,CAC7C,MAAMzX,EAASuX,EAAWE,CAAM,EAC1BtiB,EAAS,CAAA,EACf,UAAWuL,KAAW0L,EACpBjX,EAAO,KAAKiI,EAAI,IAAIsD,CAAO,EAAE,IAAI+W,CAAM,CAAC,EAE1C,MAAM9c,EAAQuc,GAAa/hB,CAAM,EACjC0Y,EAAc,IAAI7N,EAAQmX,GAAuBxc,EAAOxF,CAAM,CAAC,EAC/DwV,EAAY,KAAK3K,CAAM,CACzB,CACA,OAAO,IAAIiO,EAAKJ,EAAelD,CAAW,CAC5C,CACA,SAAS+M,MAAUC,EAAQ,CACzB,GAAIA,EAAO,SAAW,EACpB,MAAM,IAAIrkB,GAAmB,wCAAwC,EAEvE,MAAMskB,EAAQD,EAAO,CAAC,EAChB1J,EAAO2J,EAAM,YACnB,GAAID,EAAO,SAAW,EACpB,OAAOC,EAET,MAAMC,EAAa,CAAA,EACbC,EAA4B,IAAI,IACtC,UAAWC,KAASJ,EAClB,UAAWzgB,KAAQ6gB,EAAM,QAClBD,EAAU,IAAI5gB,CAAI,IACrB4gB,EAAU,IAAI5gB,CAAI,EAClB2gB,EAAW,KAAK3gB,CAAI,GAI1B,MAAM8gB,EAA2B,IAAI,IACrC,UAAWD,KAASJ,EAAQ,CAC1B,MAAMM,EAASF,EAAM,OACrB,UAAW7gB,KAAQ6gB,EAAM,QAAS,CAChC,MAAM3D,EAAW4D,EAAS,IAAI9gB,CAAI,EAC5B6J,EAAUkX,EAAO/gB,CAAI,EAC3B,GAAIkd,IAAa,QAAUA,IAAarT,EACtC,MAAM,IAAIzN,GACR,WAAW4D,CAAI,6BAA6Bkd,CAAQ,OAAOrT,CAAO,EAC5E,EAEMiX,EAAS,IAAI9gB,EAAM6J,CAAO,CAC5B,CACF,CACA,MAAMqS,EAAYuE,EAAO,OAAO,CAACnJ,EAAK/F,IAAM+F,EAAM/F,EAAE,OAAQ,CAAC,EACvDoF,EAAgC,IAAI,IAC1C,UAAWnN,KAAWmX,EAAY,CAChC,MAAM1iB,EAAS,IAAI,MAAMie,CAAS,EAClC,IAAI8E,EAAS,EACb,UAAWH,KAASJ,EAAQ,CAC1B,MAAMQ,EAAWJ,EAAM,OACvB,GAAIA,EAAM,QAAQ,SAASrX,CAAO,EAAG,CACnC,MAAM9J,EAASmhB,EAAM,IAAIrX,CAAO,EAChC,QAASxM,EAAI,EAAGA,EAAIikB,EAAUjkB,IAC5BiB,EAAO+iB,EAAShkB,CAAC,EAAI0C,EAAO,IAAI1C,CAAC,CAErC,KACE,SAASA,EAAI,EAAGA,EAAIikB,EAAUjkB,IAC5BiB,EAAO+iB,EAAShkB,CAAC,EAAI,KAGzBgkB,GAAUC,CACZ,CACA,MAAMxd,EAAQqd,EAAS,IAAItX,CAAO,GAAKwW,GAAa/hB,CAAM,EAC1D0Y,EAAc,IAAInN,EAASyW,GAAuBxc,EAAOxF,CAAM,CAAC,CAClE,CACA,OAAO,IAAI8Y,EAAKJ,EAAegK,CAAU,CAC3C,CAGA,SAASO,GAAahb,EAAKtJ,EAAO0Q,EAAM,CACtC,MAAM8B,EAAQ,CAAA,EACd,UAAW/M,KAAQiL,EAAM,CACvB,MAAMnP,EAAI+H,EAAI,IAAI7D,CAAI,EAAE,IAAIzF,CAAK,EAC7BuB,IAAM,KACRiR,EAAM,KAAK,QAAQ,EACVjR,aAAa,KACtBiR,EAAM,KAAK,MAAMjR,EAAE,QAAO,CAAE,EAAE,EACrB,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAAY,OAAOA,GAAM,UACxEiR,EAAM,KAAK,KAAK,OAAOjR,CAAC,GAAG,OAAOA,CAAC,CAAC,EAAE,EAEtCiR,EAAM,KAAK,QAAQ,KAAK,UAAUjR,CAAC,CAAC,EAAE,CAE1C,CACA,OAAOiR,EAAM,KAAK,GAAG,CACvB,CACA,SAAS+R,GAAwB9a,EAAMC,EAAO,CAC5C,MAAM8a,EAAW/a,EAAK,QAChBgb,EAAY/a,EAAM,QACxB,GAAI8a,EAAS,SAAWC,EAAU,OAChC,MAAM,IAAIjlB,GACR,6BAA6BglB,EAAS,MAAM,uBAAuBC,EAAU,MAAM,UACzF,EAEE,MAAMC,EAAajb,EAAK,OAClBkb,EAAcjb,EAAM,OAC1B,UAAWjE,KAAQ+e,EAAU,CAC3B,GAAI,EAAE/e,KAAQkf,GACZ,MAAM,IAAInlB,GACR,4BAA4BiG,CAAI,gCACxC,EAEI,GAAIif,EAAWjf,CAAI,IAAMkf,EAAYlf,CAAI,EACvC,MAAM,IAAIjG,GACR,4BAA4BiG,CAAI,gBAAgBif,EAAWjf,CAAI,CAAC,kBAAkBkf,EAAYlf,CAAI,CAAC,YAC3G,CAEE,CACF,CACA,SAASmf,GAAuB/d,EAAOxF,EAAQ,CAC7C,OAAQwF,EAAK,CACX,IAAK,MACH,OAAOpG,EAAc,KAAKY,CAAM,EAClC,IAAK,MACH,OAAOG,GAAY,KAAKH,CAAM,EAChC,IAAK,OACH,OAAOK,EAAW,KAAKL,CAAM,EAC/B,IAAK,OACH,OAAOkB,EAAc,KAAKlB,CAAM,EAClC,IAAK,OACH,OAAOoB,EAAW,KAAKpB,CAAM,EAC/B,QACE,OAAOZ,EAAc,KAAKY,CAAM,CACtC,CACA,CACA,SAASwjB,GAAYvb,EAAKtI,EAAS,CACjC,MAAM0P,EAAOpH,EAAI,QACX6a,EAAS7a,EAAI,OACbyQ,EAAgC,IAAI,IAC1C,UAAWtU,KAAQiL,EAAM,CACvB,MAAM5N,EAASwG,EAAI,IAAI7D,CAAI,EACrBpE,EAAS,CAAA,EACf,UAAWJ,KAAOD,EAChBK,EAAO,KAAKyB,EAAO,IAAI7B,CAAG,CAAC,EAE7B8Y,EAAc,IAAItU,EAAMmf,GAAuBT,EAAO1e,CAAI,EAAGpE,CAAM,CAAC,CACtE,CACA,MAAM8Y,EAAO7Q,EAAI,YACjB,OAAO,IAAI6Q,EAAKJ,EAAe,CAAC,GAAGrJ,CAAI,CAAC,CAC1C,CACA,SAASoU,GAAMrb,EAAMC,EAAO,CAC1B6a,GAAwB9a,EAAMC,CAAK,EACnC,MAAMgH,EAAOjH,EAAK,QACZ0a,EAAS1a,EAAK,OACdrD,EAAuB,IAAI,IAC3B2e,EAA8B,IAAI,IACxC,UAAWtf,KAAQiL,EACjBqU,EAAY,IAAItf,EAAM,EAAE,EAE1B,QAASrF,EAAI,EAAGA,EAAIqJ,EAAK,OAAQrJ,IAAK,CACpC,MAAMiG,EAAMie,GAAa7a,EAAMrJ,EAAGsQ,CAAI,EACtC,GAAI,CAACtK,EAAK,IAAIC,CAAG,EAAG,CAClBD,EAAK,IAAIC,CAAG,EACZ,UAAWZ,KAAQiL,EACjBqU,EAAY,IAAItf,CAAI,EAAE,KAAKgE,EAAK,IAAIhE,CAAI,EAAE,IAAIrF,CAAC,CAAC,CAEpD,CACF,CACA,QAASA,EAAI,EAAGA,EAAIsJ,EAAM,OAAQtJ,IAAK,CACrC,MAAMiG,EAAMie,GAAa5a,EAAOtJ,EAAGsQ,CAAI,EACvC,GAAI,CAACtK,EAAK,IAAIC,CAAG,EAAG,CAClBD,EAAK,IAAIC,CAAG,EACZ,UAAWZ,KAAQiL,EACjBqU,EAAY,IAAItf,CAAI,EAAE,KAAKiE,EAAM,IAAIjE,CAAI,EAAE,IAAIrF,CAAC,CAAC,CAErD,CACF,CACA,MAAM2Z,EAAgC,IAAI,IAC1C,UAAWtU,KAAQiL,EACjBqJ,EAAc,IAAItU,EAAMmf,GAAuBT,EAAO1e,CAAI,EAAGsf,EAAY,IAAItf,CAAI,CAAC,CAAC,EAErF,MAAM0U,EAAO1Q,EAAK,YAClB,OAAO,IAAI0Q,EAAKJ,EAAe,CAAC,GAAGrJ,CAAI,CAAC,CAC1C,CACA,SAASsU,GAAavb,EAAMC,EAAO,CACjC6a,GAAwB9a,EAAMC,CAAK,EACnC,MAAMgH,EAAOjH,EAAK,QACZsS,EAA4B,IAAI,IACtC,QAAS,EAAI,EAAG,EAAIrS,EAAM,OAAQ,IAChCqS,EAAU,IAAIuI,GAAa5a,EAAO,EAAGgH,CAAI,CAAC,EAE5C,MAAMtK,EAAuB,IAAI,IAC3BpF,EAAU,CAAA,EAChB,QAAS,EAAI,EAAG,EAAIyI,EAAK,OAAQ,IAAK,CACpC,MAAMpD,EAAMie,GAAa7a,EAAM,EAAGiH,CAAI,EAClCqL,EAAU,IAAI1V,CAAG,GAAK,CAACD,EAAK,IAAIC,CAAG,IACrCD,EAAK,IAAIC,CAAG,EACZrF,EAAQ,KAAK,CAAC,EAElB,CACA,OAAO6jB,GAAYpb,EAAMzI,CAAO,CAClC,CACA,SAASikB,GAAWxb,EAAMC,EAAO,CAC/B6a,GAAwB9a,EAAMC,CAAK,EACnC,MAAMgH,EAAOjH,EAAK,QACZsS,EAA4B,IAAI,IACtC,QAAS,EAAI,EAAG,EAAIrS,EAAM,OAAQ,IAChCqS,EAAU,IAAIuI,GAAa5a,EAAO,EAAGgH,CAAI,CAAC,EAE5C,MAAMtK,EAAuB,IAAI,IAC3BpF,EAAU,CAAA,EAChB,QAAS,EAAI,EAAG,EAAIyI,EAAK,OAAQ,IAAK,CACpC,MAAMpD,EAAMie,GAAa7a,EAAM,EAAGiH,CAAI,EAClC,CAACqL,EAAU,IAAI1V,CAAG,GAAK,CAACD,EAAK,IAAIC,CAAG,IACtCD,EAAK,IAAIC,CAAG,EACZrF,EAAQ,KAAK,CAAC,EAElB,CACA,OAAO6jB,GAAYpb,EAAMzI,CAAO,CAClC,CAGA,SAASkkB,GAAiBzf,EAAM,CAC9B,MAAO,IAAIA,EAAK,QAAQ,KAAM,IAAI,CAAC,GACrC,CACA,SAAS0f,GAAehlB,EAAO,CAC7B,OAAIA,GAAU,KACL,OAEL,OAAOA,GAAU,UACZA,EAAQ,OAAS,QAEtB,OAAOA,GAAU,SACd,SAASA,CAAK,EAGZ,OAAOA,CAAK,EAFV,OAIP,OAAOA,GAAU,SACZ,OAAOA,CAAK,EAEjBA,aAAiB,KACZ,IAAIA,EAAM,YAAW,CAAE,IAE5B,OAAOA,GAAU,SACZ,IAAIA,EAAM,QAAQ,KAAM,IAAI,CAAC,IAG/B,IADM,KAAK,UAAUA,CAAK,EACjB,QAAQ,KAAM,IAAI,CAAC,GACrC,CACA,SAASilB,GAASC,EAAWnZ,EAAQqC,EAAMhD,EAAU,CAAA,EAAI,CACvD,MAAM+Z,EAAY/Z,EAAQ,WAAa,IACvC,GAAIW,EAAO,SAAW,GAAKqC,EAAK,SAAW,EACzC,MAAO,GAET,MAAMgX,EAAarZ,EAAO,IAAIgZ,EAAgB,EAAE,KAAK,IAAI,EACnDM,EAAa,CAAA,EACnB,QAASplB,EAAI,EAAGA,EAAImO,EAAK,OAAQnO,GAAKklB,EAAW,CAE/C,MAAMG,EADQlX,EAAK,MAAMnO,EAAGA,EAAIklB,CAAS,EACjB,IAAK5Y,GAEpB,IADQA,EAAI,IAAIyY,EAAc,EAAE,KAAK,IAAI,CAC/B,GAClB,EACDK,EAAW,KACT,eAAeN,GAAiBG,CAAS,CAAC,KAAKE,CAAU;AAAA,EAC7DE,EAAU,KAAK;AAAA,CAAK,CAAC,GACvB,CACE,CACA,OAAOD,EAAW,KAAK;AAAA;AAAA,CAAM,CAC/B,CAGA,IAAIE,GAAa,EACjB,SAASC,IAAiB,CACxB,MAAO,CAAE,KAAM,OAAQ,GAAID,IAAY,CACzC,CACA,SAASE,GAAYC,EAAMC,EAAS,EAAG,CACrC,MAAMC,EAAM,KAAK,OAAOD,CAAM,EAC9B,OAAQD,EAAK,KAAI,CACf,IAAK,OACH,OAAIA,EAAK,WACA,GAAGE,CAAG,YAAYF,EAAK,EAAE,UAAUA,EAAK,WAAW,KAAK,IAAI,CAAC,IAE/D,GAAGE,CAAG,YAAYF,EAAK,EAAE,IAClC,IAAK,SACH,MAAO,GAAGE,CAAG,WAAWF,EAAK,UAAU,UAAU;AAAA,EACrDD,GAAYC,EAAK,MAAOC,EAAS,CAAC,CAAC,GACjC,IAAK,SACH,MAAO,GAAGC,CAAG,WAAWF,EAAK,QAAQ,KAAK,IAAI,CAAC;AAAA,EACnDD,GAAYC,EAAK,MAAOC,EAAS,CAAC,CAAC,GACjC,IAAK,UAAW,CACd,MAAME,EAAWH,EAAK,MAAM,IAAK9a,GAAMA,EAAE,SAAQ,CAAE,EAAE,KAAK,IAAI,EAC9D,MAAO,GAAGgb,CAAG,YAAYC,CAAQ;AAAA,EACrCJ,GAAYC,EAAK,MAAOC,EAAS,CAAC,CAAC,EACjC,CACA,IAAK,UAAW,CACd,MAAMG,EAAUJ,EAAK,KAAK,IAAKthB,GAAMA,EAAE,SAAQ,CAAE,EAAE,KAAK,IAAI,EAC5D,MAAO,GAAGwhB,CAAG,kBAAkBF,EAAK,KAAK,KAAK,IAAI,CAAC,WAAWI,CAAO;AAAA,EACzEL,GAAYC,EAAK,MAAOC,EAAS,CAAC,CAAC,EACjC,CACA,IAAK,OACH,MAAO,GAAGC,CAAG,SAASF,EAAK,GAAG;AAAA,EAClCE,CAAG;AAAA,EACHH,GAAYC,EAAK,KAAMC,EAAS,CAAC,CAAC;AAAA,EAClCC,CAAG;AAAA,EACHH,GAAYC,EAAK,MAAOC,EAAS,CAAC,CAAC,GACjC,IAAK,OACH,MAAO,GAAGC,CAAG,SAASF,EAAK,EAAE,IAAIA,EAAK,WAAa,OAAS,KAAK;AAAA,EACrED,GAAYC,EAAK,MAAOC,EAAS,CAAC,CAAC,GACjC,IAAK,QACH,MAAO,GAAGC,CAAG,UAAUF,EAAK,CAAC;AAAA,EACjCD,GAAYC,EAAK,MAAOC,EAAS,CAAC,CAAC,GACjC,IAAK,WACH,MAAO,GAAGC,CAAG,WAAWF,EAAK,OAAS,KAAKA,EAAK,OAAO,KAAK,IAAI,CAAC,IAAM,EAAE;AAAA,EAC7ED,GAAYC,EAAK,MAAOC,EAAS,CAAC,CAAC,EACrC,CACA,CAGA,SAASI,GAAQC,EAAM1iB,EAAQ,CAC7B,SAAS2iB,EAAIP,EAAM,CACjB,OAAQA,EAAK,KAAI,CACf,IAAK,OACH,OAAIA,EAAK,WACApiB,EAAO,OAAO,GAAGoiB,EAAK,UAAU,EAElCpiB,EACT,IAAK,SAEH,OADc2iB,EAAIP,EAAK,KAAK,EACf,OAAOA,EAAK,SAAS,EAEpC,IAAK,SAEH,OADcO,EAAIP,EAAK,KAAK,EACf,OAAO,GAAGA,EAAK,OAAO,EAErC,IAAK,UAAW,CACd,MAAMjP,EAAQwP,EAAIP,EAAK,KAAK,EAC5B,IAAIvlB,EAASsW,EACb,UAAWzN,KAAQ0c,EAAK,MAAO,CAC7B,MAAM/iB,EAASqG,EAAK,SAASyN,CAAK,EAClCtW,EAASA,EAAO,WAAWwC,EAAO,KAAMqG,CAAI,CAC9C,CACA,OAAO7I,CACT,CACA,IAAK,UAAW,CAEd,MAAM+lB,EADQD,EAAIP,EAAK,KAAK,EACX,QAAQ,GAAGA,EAAK,IAAI,EAC/BpM,EAAQ,CAAA,EACd,UAAWE,KAAWkM,EAAK,KAAM,CAC/B,MAAMS,EAAM3M,EAEN4C,EADO+J,EAAI,aACO,CAAC,GAAK,QAC9B7M,EAAM8C,CAAU,EAAI+J,CACtB,CACA,OAAOD,EAAG,IAAI5M,CAAK,CACrB,CACA,IAAK,OAEH,OADc2M,EAAIP,EAAK,KAAK,EACf,OAAOA,EAAK,GAAIA,EAAK,WAAa,OAAS,KAAK,EAE/D,IAAK,QAEH,OADcO,EAAIP,EAAK,KAAK,EACf,KAAKA,EAAK,CAAC,EAE1B,IAAK,WAEH,OADcO,EAAIP,EAAK,KAAK,EACf,OAAOA,EAAK,MAAM,EAEjC,IAAK,OAAQ,CACX,MAAMpc,EAAO2c,EAAIP,EAAK,IAAI,EACpBnc,EAAQ0c,EAAIP,EAAK,KAAK,EAC5B,OAAOpc,EAAK,KAAKC,EAAOmc,EAAK,GAAIA,EAAK,GAAG,CAC3C,CACN,CACE,CACA,OAAOO,EAAID,CAAI,CACjB,CAGA,SAASI,GAASJ,EAAM,CACtB,MAAMK,EAAYC,GAASN,CAAI,EACzBO,EAASC,GAAaH,CAAS,EACrC,OAAOI,GAAmBF,CAAM,CAClC,CACA,SAASD,GAASZ,EAAM,CACtB,OAAQA,EAAK,KAAI,CACf,IAAK,OACH,OAAOA,EACT,IAAK,SAAU,CAEb,MAAMgB,EAAS,CAAE,KAAM,SAAU,MADnBJ,GAASZ,EAAK,KAAK,EACO,UAAWA,EAAK,SAAS,EACjE,OAAOiB,GAAeD,CAAM,CAC9B,CACA,IAAK,SACH,MAAO,CAAE,KAAM,SAAU,MAAOJ,GAASZ,EAAK,KAAK,EAAG,QAASA,EAAK,OAAO,EAC7E,IAAK,UACH,MAAO,CAAE,KAAM,UAAW,MAAOY,GAASZ,EAAK,KAAK,EAAG,MAAOA,EAAK,KAAK,EAC1E,IAAK,UACH,MAAO,CAAE,KAAM,UAAW,MAAOY,GAASZ,EAAK,KAAK,EAAG,KAAMA,EAAK,KAAM,KAAMA,EAAK,IAAI,EACzF,IAAK,OACH,MAAO,CAAE,KAAM,OAAQ,MAAOY,GAASZ,EAAK,KAAK,EAAG,GAAIA,EAAK,GAAI,WAAYA,EAAK,UAAU,EAC9F,IAAK,QACH,MAAO,CAAE,KAAM,QAAS,MAAOY,GAASZ,EAAK,KAAK,EAAG,EAAGA,EAAK,CAAC,EAChE,IAAK,WACH,MAAO,CAAE,KAAM,WAAY,MAAOY,GAASZ,EAAK,KAAK,EAAG,OAAQA,EAAK,MAAM,EAC7E,IAAK,OACH,MAAO,CAAE,KAAM,OAAQ,KAAMY,GAASZ,EAAK,IAAI,EAAG,MAAOY,GAASZ,EAAK,KAAK,EAAG,GAAIA,EAAK,GAAI,IAAKA,EAAK,GAAG,CAC/G,CACA,CACA,SAASiB,GAAeD,EAAQ,CAC9B,MAAME,EAAQF,EAAO,MACrB,OAAQE,EAAM,KAAI,CAEhB,IAAK,SACH,MAAO,CACL,KAAM,SACN,MAAOD,GAAe,CAAE,KAAM,SAAU,MAAOC,EAAM,MAAO,UAAWF,EAAO,SAAS,CAAE,EACzF,QAASE,EAAM,OACvB,EACI,IAAK,UACH,MAAO,CACL,KAAM,UACN,MAAOD,GAAe,CAAE,KAAM,SAAU,MAAOC,EAAM,MAAO,UAAWF,EAAO,SAAS,CAAE,EACzF,MAAOE,EAAM,KACrB,EAEI,IAAK,OACH,MAAO,CACL,KAAM,OACN,MAAOD,GAAe,CAAE,KAAM,SAAU,MAAOC,EAAM,MAAO,UAAWF,EAAO,SAAS,CAAE,EACzF,GAAIE,EAAM,GACV,WAAYA,EAAM,UAC1B,EAEI,IAAK,UACH,OAAOF,EAET,QACE,OAAOA,CACb,CACA,CACA,SAASF,GAAad,EAAM,CAC1B,OAAQA,EAAK,KAAI,CACf,IAAK,OACH,OAAOA,EACT,IAAK,SAAU,CACb,MAAMjP,EAAQ+P,GAAad,EAAK,KAAK,EACrC,OAAIjP,EAAM,OAAS,SACV,CACL,KAAM,SACN,MAAOA,EAAM,MACb,UAAWA,EAAM,UAAU,IAAIiP,EAAK,SAAS,CACvD,EAEa,CAAE,KAAM,SAAU,MAAAjP,EAAO,UAAWiP,EAAK,SAAS,CAC3D,CACA,IAAK,SACH,MAAO,CAAE,KAAM,SAAU,MAAOc,GAAad,EAAK,KAAK,EAAG,QAASA,EAAK,OAAO,EACjF,IAAK,UACH,MAAO,CAAE,KAAM,UAAW,MAAOc,GAAad,EAAK,KAAK,EAAG,MAAOA,EAAK,KAAK,EAC9E,IAAK,UACH,MAAO,CAAE,KAAM,UAAW,MAAOc,GAAad,EAAK,KAAK,EAAG,KAAMA,EAAK,KAAM,KAAMA,EAAK,IAAI,EAC7F,IAAK,OACH,MAAO,CAAE,KAAM,OAAQ,MAAOc,GAAad,EAAK,KAAK,EAAG,GAAIA,EAAK,GAAI,WAAYA,EAAK,UAAU,EAClG,IAAK,QACH,MAAO,CAAE,KAAM,QAAS,MAAOc,GAAad,EAAK,KAAK,EAAG,EAAGA,EAAK,CAAC,EACpE,IAAK,WACH,MAAO,CAAE,KAAM,WAAY,MAAOc,GAAad,EAAK,KAAK,EAAG,OAAQA,EAAK,MAAM,EACjF,IAAK,OACH,MAAO,CAAE,KAAM,OAAQ,KAAMc,GAAad,EAAK,IAAI,EAAG,MAAOc,GAAad,EAAK,KAAK,EAAG,GAAIA,EAAK,GAAI,IAAKA,EAAK,GAAG,CACvH,CACA,CACA,SAASe,GAAmBf,EAAMmB,EAAQ,CACxC,OAAQnB,EAAK,KAAI,CACf,IAAK,OAAQ,CACX,GAAImB,GAAUA,EAAO,KAAO,EAAG,CAC7B,MAAMC,EAAa,CAAC,GAAGD,CAAM,EAAE,KAAI,EACnC,MAAO,CAAE,KAAM,OAAQ,GAAInB,EAAK,GAAI,WAAAoB,CAAU,CAChD,CACA,OAAOpB,CACT,CACA,IAAK,SAAU,CACb,MAAMqB,EAAc,IAAI,IAAIrB,EAAK,OAAO,EACxC,MAAO,CAAE,KAAM,SAAU,MAAOe,GAAmBf,EAAK,MAAOqB,CAAW,EAAG,QAASrB,EAAK,OAAO,CACpG,CACA,IAAK,SAAU,CACb,MAAMqB,EAAc,IAAI,IAAIF,CAAM,EAClC,UAAWG,KAAOtB,EAAK,UAAU,aAC/BqB,EAAY,IAAIC,CAAG,EAErB,MAAO,CAAE,KAAM,SAAU,MAAOP,GAAmBf,EAAK,MAAOqB,CAAW,EAAG,UAAWrB,EAAK,SAAS,CACxG,CACA,IAAK,UAAW,CACd,MAAMqB,EAA8B,IAAI,IACxC,UAAW/d,KAAQ0c,EAAK,MACtB,UAAWsB,KAAOhe,EAAK,aACrB+d,EAAY,IAAIC,CAAG,EAGvB,MAAO,CAAE,KAAM,UAAW,MAAOP,GAAmBf,EAAK,MAAOqB,CAAW,EAAG,MAAOrB,EAAK,KAAK,CACjG,CACA,IAAK,UAAW,CACd,MAAMqB,EAAc,IAAI,IAAIrB,EAAK,IAAI,EACrC,UAAWS,KAAOT,EAAK,KACrB,UAAWsB,KAAOb,EAAI,aACpBY,EAAY,IAAIC,CAAG,EAGvB,MAAO,CAAE,KAAM,UAAW,MAAOP,GAAmBf,EAAK,MAAOqB,CAAW,EAAG,KAAMrB,EAAK,KAAM,KAAMA,EAAK,IAAI,CAChH,CACA,IAAK,OAAQ,CACX,MAAMqB,EAAc,IAAI,IAAIF,CAAM,EAClC,OAAAE,EAAY,IAAIrB,EAAK,EAAE,EAChB,CAAE,KAAM,OAAQ,MAAOe,GAAmBf,EAAK,MAAOqB,CAAW,EAAG,GAAIrB,EAAK,GAAI,WAAYA,EAAK,UAAU,CACrH,CACA,IAAK,QACH,MAAO,CAAE,KAAM,QAAS,MAAOe,GAAmBf,EAAK,MAAOmB,CAAM,EAAG,EAAGnB,EAAK,CAAC,EAClF,IAAK,WAAY,CACf,GAAIA,EAAK,OAAQ,CACf,MAAMqB,EAAc,IAAI,IAAIF,CAAM,EAClC,UAAW5jB,KAAQyiB,EAAK,OACtBqB,EAAY,IAAI9jB,CAAI,EAEtB,MAAO,CAAE,KAAM,WAAY,MAAOwjB,GAAmBf,EAAK,MAAOqB,CAAW,EAAG,OAAQrB,EAAK,MAAM,CACpG,CACA,MAAO,CAAE,KAAM,WAAY,MAAOe,GAAmBf,EAAK,MAAOmB,CAAM,EAAG,OAAQnB,EAAK,MAAM,CAC/F,CACA,IAAK,OAAQ,CACX,MAAMuB,EAAS,OAAOvB,EAAK,IAAO,SAAW,CAACA,EAAK,EAAE,EAAIA,EAAK,GACxDwB,EAAa,IAAI,IAAIL,CAAM,EAC3BM,EAAc,IAAI,IAAIN,CAAM,EAClC,UAAWrZ,KAAKyZ,EACdC,EAAW,IAAI1Z,CAAC,EAChB2Z,EAAY,IAAI3Z,CAAC,EAEnB,MAAO,CAAE,KAAM,OAAQ,KAAMiZ,GAAmBf,EAAK,KAAMwB,CAAU,EAAG,MAAOT,GAAmBf,EAAK,MAAOyB,CAAW,EAAG,GAAIzB,EAAK,GAAI,IAAKA,EAAK,GAAG,CACxJ,CACJ,CACA,CAGG,IAAC0B,GAAc,KAAM,CAEtB,QAEA,MAEA,MACA,YAAY9jB,EAAQ0iB,EAAM9M,EAAM,CAC9B,KAAK,QAAU5V,EACf,KAAK,MAAQ0iB,EACb,KAAK,MAAQ9M,CACf,CACA,OAAOI,EAAO,CACZ,OAAO,IAAI+N,GAAU,KAAK,QAAS,CACjC,KAAM,UACN,MAAO,KAAK,MACZ,KAAM,CAAC,GAAG,KAAK,KAAK,EACpB,KAAM/N,CACZ,CAAK,CACH,CACF,EACI+N,GAAY,MAAMC,EAAW,CAE/B,QAEA,MACA,YAAYhkB,EAAQ0iB,EAAM,CACxB,KAAK,QAAU1iB,EACf,KAAK,MAAQ0iB,CACf,CACA,OAAOjf,EAAW,CAChB,OAAO,IAAIugB,GAAW,KAAK,QAAS,CAClC,KAAM,SACN,MAAO,KAAK,MACZ,UAAAvgB,CACN,CAAK,CACH,CACA,UAAUN,EAAS,CACjB,OAAO,IAAI6gB,GAAW,KAAK,QAAS,CAClC,KAAM,SACN,MAAO,KAAK,MACZ,QAAA7gB,CACN,CAAK,CACH,CACA,WAAW+B,EAAO,CAChB,OAAO,IAAI8e,GAAW,KAAK,QAAS,CAClC,KAAM,UACN,MAAO,KAAK,MACZ,MAAA9e,CACN,CAAK,CACH,CACA,KAAK+e,EAAIC,EAAa,GAAO,CAC3B,OAAO,IAAIF,GAAW,KAAK,QAAS,CAClC,KAAM,OACN,MAAO,KAAK,MACZ,GAAAC,EACA,WAAAC,CACN,CAAK,CACH,CACA,OAAOD,EAAIC,EAAa,GAAO,CAC7B,OAAO,KAAK,KAAKD,EAAIC,CAAU,CACjC,CACA,MAAM9iB,EAAG,CACP,OAAO,IAAI4iB,GAAW,KAAK,QAAS,CAClC,KAAM,QACN,MAAO,KAAK,MACZ,EAAA5iB,CACN,CAAK,CACH,CACA,KAAKA,EAAG,CACN,OAAO,KAAK,MAAMA,CAAC,CACrB,CACA,SAAS+iB,EAAQ,CACf,OAAO,IAAIH,GAAW,KAAK,QAAS,CAClC,KAAM,WACN,MAAO,KAAK,MACZ,OAAAG,CACN,CAAK,CACH,CACA,OAAOA,EAAQ,CACb,OAAO,KAAK,SAASA,CAAM,CAC7B,CACA,WAAWvO,EAAM,CACf,OAAO,IAAIkO,GAAY,KAAK,QAAS,KAAK,MAAOlO,CAAI,CACvD,CACA,SAAU,CACR,MAAMwO,EAAWjC,GAAY,KAAK,KAAK,EACjCkC,EAAgBvB,GAAS,KAAK,KAAK,EACnCC,EAAYZ,GAAYkC,CAAa,EAC3C,MAAO;AAAA,EACTD,CAAQ;AAAA;AAAA;AAAA,EAGRrB,CAAS,EACT,CACA,SAAU,CACR,OAAO,QAAQ,QAAQN,GAAQ,KAAK,MAAO,KAAK,OAAO,CAAC,CAC1D,CACA,MAAM,KAAKnX,EAAU,CACnB,MAAMzF,EAAM,MAAM,KAAK,QAAO,EACxBye,EAAMhZ,EAAS,YAAW,EAChC,GAAIgZ,EAAI,SAAS,MAAM,GAAKA,EAAI,SAAS,MAAM,EAC7C,MAAMze,EAAI,MAAMyF,CAAQ,UACfgZ,EAAI,SAAS,SAAS,GAAKA,EAAI,SAAS,QAAQ,EACzD,MAAMze,EAAI,SAASyF,CAAQ,MAE3B,OAAM,IAAI,MAAM,gCAAgCA,CAAQ,2CAA2C,CAEvG,CACF,EACA,SAASiZ,GAAgBvkB,EAAQ,CAC/B,OAAO,IAAI+jB,GAAU/jB,EAAQkiB,IAAgB,CAC/C,CAGA,IAAIsC,GAA2B,IAAI,IAAI,CACrC,SACA,OACA,QACA,QACA,KACA,QACA,QACA,SACA,MACA,KACA,KACA,OACA,KACA,MACA,OACA,MACA,OACA,IACF,CAAC,EACD,SAASC,GAAStR,EAAO,CACvB,MAAMuR,EAAS,CAAA,EACf,IAAI/nB,EAAI,EACR,KAAOA,EAAIwW,EAAM,QAAQ,CACvB,GAAI,KAAK,KAAKA,EAAMxW,CAAC,CAAC,EAAG,CACvBA,IACA,QACF,CACA,MAAMgoB,EAAMhoB,EACZ,GAAIwW,EAAMxW,CAAC,IAAM,IAAK,CACpBA,IACA,IAAID,EAAQ,GACZ,KAAOC,EAAIwW,EAAM,QAAUA,EAAMxW,CAAC,IAAM,KAClCwW,EAAMxW,CAAC,IAAM,KAAOwW,EAAMxW,EAAI,CAAC,IAAM,KACvCD,GAAS,IACTC,GAAK,IAELD,GAASyW,EAAMxW,CAAC,EAChBA,KAGJ,GAAIA,GAAKwW,EAAM,OACb,MAAM,IAAInX,GAAW,2CAA2C2oB,CAAG,EAAE,EAEvEhoB,IACA+nB,EAAO,KAAK,CAAE,KAAM,SAAuB,MAAAhoB,EAAO,SAAUioB,EAAK,EACjE,QACF,CACA,GAAI,KAAK,KAAKxR,EAAMxW,CAAC,CAAC,GAAKwW,EAAMxW,CAAC,IAAM,KAAOA,EAAI,EAAIwW,EAAM,QAAU,KAAK,KAAKA,EAAMxW,EAAI,CAAC,CAAC,EAAG,CAC9F,IAAID,EAAQ,GAKZ,IAJIyW,EAAMxW,CAAC,IAAM,MACfD,GAAS,IACTC,KAEKA,EAAIwW,EAAM,QAAU,QAAQ,KAAKA,EAAMxW,CAAC,CAAC,GAC9CD,GAASyW,EAAMxW,CAAC,EAChBA,IAEF+nB,EAAO,KAAK,CAAE,KAAM,SAAuB,MAAAhoB,EAAO,SAAUioB,EAAK,EACjE,QACF,CACA,GAAIxR,EAAMxW,CAAC,IAAM,IAAK,CACpB+nB,EAAO,KAAK,CAAE,KAAM,OAAmB,MAAO,IAAK,SAAUC,EAAK,EAClEhoB,IACA,QACF,CACA,GAAIwW,EAAMxW,CAAC,IAAM,IAAK,CACpB+nB,EAAO,KAAK,CAAE,KAAM,QAAqB,MAAO,IAAK,SAAUC,EAAK,EACpEhoB,IACA,QACF,CACA,GAAIwW,EAAMxW,CAAC,IAAM,IAAK,CACpB+nB,EAAO,KAAK,CAAE,KAAM,SAAuB,MAAO,IAAK,SAAUC,EAAK,EACtEhoB,IACA,QACF,CACA,GAAIwW,EAAMxW,CAAC,IAAM,IAAK,CACpB+nB,EAAO,KAAK,CAAE,KAAM,SAAuB,MAAO,IAAK,SAAUC,EAAK,EACtEhoB,IACA,QACF,CACA,GAAIwW,EAAMxW,CAAC,IAAM,KAAOwW,EAAMxW,EAAI,CAAC,IAAM,IAAK,CAC5C+nB,EAAO,KAAK,CAAE,KAAM,MAAiB,MAAO,KAAM,SAAUC,EAAK,EACjEhoB,GAAK,EACL,QACF,CACA,GAAIwW,EAAMxW,CAAC,IAAM,KAAOwW,EAAMxW,EAAI,CAAC,IAAM,IAAK,CAC5C+nB,EAAO,KAAK,CAAE,KAAM,MAAiB,MAAO,KAAM,SAAUC,EAAK,EACjEhoB,GAAK,EACL,QACF,CACA,GAAIwW,EAAMxW,CAAC,IAAM,KAAOwW,EAAMxW,EAAI,CAAC,IAAM,IAAK,CAC5C+nB,EAAO,KAAK,CAAE,KAAM,MAAiB,MAAO,KAAM,SAAUC,EAAK,EACjEhoB,GAAK,EACL,QACF,CACA,GAAIwW,EAAMxW,CAAC,IAAM,KAAOwW,EAAMxW,EAAI,CAAC,IAAM,IAAK,CAC5C+nB,EAAO,KAAK,CAAE,KAAM,MAAiB,MAAO,KAAM,SAAUC,EAAK,EACjEhoB,GAAK,EACL,QACF,CACA,GAAIwW,EAAMxW,CAAC,IAAM,IAAK,CACpB+nB,EAAO,KAAK,CAAE,KAAM,KAAe,MAAO,IAAK,SAAUC,EAAK,EAC9DhoB,IACA,QACF,CACA,GAAIwW,EAAMxW,CAAC,IAAM,IAAK,CACpB+nB,EAAO,KAAK,CAAE,KAAM,KAAe,MAAO,IAAK,SAAUC,EAAK,EAC9DhoB,IACA,QACF,CACA,GAAIwW,EAAMxW,CAAC,IAAM,IAAK,CACpB+nB,EAAO,KAAK,CAAE,KAAM,KAAe,MAAO,IAAK,SAAUC,EAAK,EAC9DhoB,IACA,QACF,CACA,GAAI,YAAY,KAAKwW,EAAMxW,CAAC,CAAC,EAAG,CAC9B,IAAID,EAAQ,GACZ,KAAOC,EAAIwW,EAAM,QAAU,eAAe,KAAKA,EAAMxW,CAAC,CAAC,GACrDD,GAASyW,EAAMxW,CAAC,EAChBA,IAEF,MAAMioB,EAAQloB,EAAM,YAAW,EAC3B8nB,GAAS,IAAII,CAAK,EACpBF,EAAO,KAAK,CAAE,KAAME,EAAO,MAAOA,EAAO,SAAUD,EAAK,EAExDD,EAAO,KAAK,CAAE,KAAM,aAA+B,MAAAhoB,EAAO,SAAUioB,EAAK,EAE3E,QACF,CACA,MAAM,IAAI3oB,GAAW,yBAAyBmX,EAAMxW,CAAC,CAAC,iBAAiBgoB,CAAG,EAAE,CAC9E,CACA,OAAAD,EAAO,KAAK,CAAE,KAAM,MAAiB,MAAO,GAAI,SAAU/nB,EAAG,EACtD+nB,CACT,CACA,IAAIG,GAAS,KAAM,CACjB,OACA,IACA,aAAe,CAAA,EACf,YAAYH,EAAQ,CAClB,KAAK,OAASA,EACd,KAAK,IAAM,CACb,CACA,SAAU,CACR,OAAO,KAAK,OAAO,KAAK,GAAG,CAC7B,CACA,MAAO,CACL,OAAO,KAAK,OAAO,KAAK,GAAG,CAC7B,CACA,SAAU,CACR,MAAMI,EAAQ,KAAK,OAAO,KAAK,GAAG,EAClC,YAAK,MACEA,CACT,CACA,OAAOC,EAAM,CACX,MAAMD,EAAQ,KAAK,QAAO,EAC1B,GAAIA,EAAM,OAASC,EACjB,MAAM,IAAI/oB,GACR,YAAY+oB,CAAI,aAAaD,EAAM,KAAK,iBAAiBA,EAAM,QAAQ,EAC/E,EAEI,OAAO,KAAK,QAAO,CACrB,CACA,MAAMC,EAAM,CACV,OAAI,KAAK,UAAU,OAASA,GAC1B,KAAK,QAAO,EACL,IAEF,EACT,CACA,OAAQ,CACN,KAAK,OAAO,QAAQ,EACpB,IAAIC,EAAY,GAChB,MAAMC,EAAc,CAAA,EACpB,GAAI,KAAK,UAAU,OAAS,OAC1BD,EAAY,GACZ,KAAK,QAAO,MAGZ,KADAC,EAAY,KAAK,KAAK,iBAAiB,EAChC,KAAK,MAAM,UAChBA,EAAY,KAAK,KAAK,iBAAiB,EAG3C,KAAK,aAAeA,EACpB,KAAK,OAAO,MAAM,EAClB,MAAMC,EAAY,KAAK,OAAO,YAAY,EAC1C,GAAIA,EAAU,QAAU,OACtB,MAAM,IAAIlpB,GACR,2CAA2CkpB,EAAU,KAAK,iBAAiBA,EAAU,QAAQ,EACrG,EAEI,IAAIC,EACA,KAAK,UAAU,OAAS,UAC1B,KAAK,QAAO,EACZA,EAAY,KAAK,YAAW,GAE9B,MAAMC,EAAiB,CAAA,EACvB,GAAI,KAAK,UAAU,OAAS,QAI1B,IAHA,KAAK,QAAO,EACZ,KAAK,OAAO,IAAI,EAChBA,EAAe,KAAK,KAAK,OAAO,YAAY,EAAmB,KAAK,EAC7D,KAAK,MAAM,UAChBA,EAAe,KAAK,KAAK,OAAO,YAAY,EAAmB,KAAK,EAGxE,IAAIC,EACA,KAAK,UAAU,OAAS,WAC1B,KAAK,QAAO,EACZA,EAAa,KAAK,YAAW,GAE/B,MAAMC,EAAe,CAAA,EACrB,GAAI,KAAK,UAAU,OAAS,QAI1B,IAHA,KAAK,QAAO,EACZ,KAAK,OAAO,IAAI,EAChBA,EAAa,KAAK,KAAK,kBAAkB,EAClC,KAAK,MAAM,UAChBA,EAAa,KAAK,KAAK,kBAAkB,EAG7C,IAAIrK,EACJ,GAAI,KAAK,UAAU,OAAS,QAAqB,CAC/C,KAAK,QAAO,EACZ,MAAMsK,EAAM,KAAK,OAAO,QAAQ,EAChCtK,EAAQ,SAASsK,EAAI,MAAO,EAAE,CAChC,CACA,GAAI,KAAK,UAAU,OAAS,MAC1B,MAAM,IAAIvpB,GACR,qBAAqB,KAAK,UAAU,KAAK,iBAAiB,KAAK,QAAO,EAAG,QAAQ,EACzF,EAEI,MAAO,CAAE,YAAAipB,EAAa,UAAAD,EAAW,UAAAG,EAAW,eAAAC,EAAgB,WAAAC,EAAY,aAAAC,EAAc,MAAArK,CAAK,CAC7F,CACA,iBAAkB,CAChB,MAAM6J,EAAQ,KAAK,QAAO,EACpBU,EAAWV,EAAM,MAAM,YAAW,EACxC,GAAIA,EAAM,OAAS,cAAiC,CAAC,MAAO,MAAO,QAAS,MAAO,KAAK,EAAE,SAASU,CAAQ,GAAK,KAAK,OAAO,KAAK,IAAM,CAAC,GAAG,OAAS,SAAuB,CACzK,MAAMC,EAAUD,EAChB,KAAK,QAAO,EACZ,KAAK,QAAO,EACZ,IAAIjf,EACA,KAAK,UAAU,OAAS,QAC1BA,EAAa,IACb,KAAK,QAAO,GAEZA,EAAa,KAAK,OAAO,YAAY,EAAmB,MAE1D,KAAK,OAAO,QAAQ,EACpB,IAAImf,EACJ,OAAI,KAAK,UAAU,OAAS,OAC1B,KAAK,QAAO,EACZA,EAAS,KAAK,OAAO,YAAY,EAAmB,OAE/C,CAAE,OAAQnf,EAAY,MAAOmf,EAAQ,UAAWD,CAAO,CAChE,CACA,MAAMtc,EAAU,KAAK,OAAO,YAAY,EAAmB,MAC3D,IAAIwc,EACJ,OAAI,KAAK,UAAU,OAAS,OAC1B,KAAK,QAAO,EACZA,EAAQ,KAAK,OAAO,YAAY,EAAmB,OAE9C,CAAE,OAAQxc,EAAS,MAAAwc,EAAO,UAAW,MAAM,CACpD,CACA,kBAAmB,CACjB,MAAM/pB,EAAS,KAAK,OAAO,YAAY,EAAmB,MAC1D,IAAIgqB,EAAY,MAChB,OAAI,KAAK,UAAU,OAAS,OAC1B,KAAK,QAAO,EACZA,EAAY,OACH,KAAK,QAAO,EAAG,OAAS,SACjC,KAAK,QAAO,EACZA,EAAY,QAEP,CAAE,OAAAhqB,EAAQ,UAAAgqB,CAAS,CAC5B,CAEA,aAAc,CACZ,IAAI5f,EAAO,KAAK,aAAY,EAC5B,KAAO,KAAK,UAAU,OAAS,MAAe,CAC5C,KAAK,QAAO,EACZ,MAAMC,EAAQ,KAAK,aAAY,EAC/BD,EAAOA,EAAK,GAAGC,CAAK,CACtB,CACA,OAAOD,CACT,CACA,cAAe,CACb,IAAIA,EAAO,KAAK,gBAAe,EAC/B,KAAO,KAAK,UAAU,OAAS,OAAiB,CAC9C,KAAK,QAAO,EACZ,MAAMC,EAAQ,KAAK,gBAAe,EAClCD,EAAOA,EAAK,IAAIC,CAAK,CACvB,CACA,OAAOD,CACT,CACA,iBAAkB,CAChB,GAAI,KAAK,UAAU,OAAS,SAAuB,CACjD,KAAK,QAAO,EACZ,MAAMN,EAAO,KAAK,YAAW,EAC7B,YAAK,OAAO,QAAQ,EACbA,CACT,CACA,GAAI,KAAK,UAAU,OAAS,MAC1B,YAAK,QAAO,EACC,KAAK,gBAAe,EACrB,IAAG,EAEjB,MAAMmgB,EAAY,KAAK,QAAO,EACxBL,EAAWK,EAAU,MAAM,YAAW,EAC5C,GAAIA,EAAU,OAAS,cAAiC,CAAC,MAAO,MAAO,QAAS,MAAO,KAAK,EAAE,SAASL,CAAQ,GAAK,KAAK,OAAO,KAAK,IAAM,CAAC,GAAG,OAAS,SACtJ,OAAO,KAAK,yBAAwB,EAEtC,MAAMjf,EAAa,KAAK,OAAO,YAAY,EAAmB,MACxDqR,EAAU9Q,GAAIP,CAAU,EAC9B,GAAI,KAAK,UAAU,OAAS,KAE1B,OADA,KAAK,QAAO,EACR,KAAK,UAAU,OAAS,OAC1B,KAAK,QAAO,EACZ,KAAK,OAAO,MAAM,EACX,IAAIuf,GAAYvf,EAAY,EAAI,IAEzC,KAAK,OAAO,MAAM,EACX,IAAIuf,GAAYvf,EAAY,EAAK,GAE1C,GAAI,KAAK,UAAU,OAAS,MAAiB,CAE3C,GADA,KAAK,QAAO,EACR,KAAK,UAAU,OAAS,KAAe,CACzC,KAAK,QAAO,EACZ,MAAM3I,EAAS,KAAK,eAAc,EAClC,IAAImoB,EAASnO,EAAQ,GAAG7Q,EAAInJ,EAAO,CAAC,CAAC,CAAC,EACtC,QAASjB,EAAI,EAAGA,EAAIiB,EAAO,OAAQjB,IACjCopB,EAASA,EAAO,GAAGnO,EAAQ,GAAG7Q,EAAInJ,EAAOjB,CAAC,CAAC,CAAC,CAAC,EAE/C,OAAOopB,EAAO,IAAG,CACnB,CACA,GAAI,KAAK,UAAU,OAAS,OAAmB,CAC7C,KAAK,QAAO,EACZ,MAAMvmB,EAAU,KAAK,OAAO,QAAQ,EAAe,MACnD,OAAO,KAAK,cAAc+G,EAAY/G,CAAO,EAAE,IAAG,CACpD,CACA,MAAM,IAAIxD,GAAW,6CAA6C,KAAK,QAAO,EAAG,QAAQ,EAAE,CAC7F,CACA,GAAI,KAAK,UAAU,OAAS,KAAe,CACzC,KAAK,QAAO,EACZ,MAAM4B,EAAS,KAAK,eAAc,EAClC,IAAImoB,EAASnO,EAAQ,GAAG7Q,EAAInJ,EAAO,CAAC,CAAC,CAAC,EACtC,QAASjB,EAAI,EAAGA,EAAIiB,EAAO,OAAQjB,IACjCopB,EAASA,EAAO,GAAGnO,EAAQ,GAAG7Q,EAAInJ,EAAOjB,CAAC,CAAC,CAAC,CAAC,EAE/C,OAAOopB,CACT,CACA,GAAI,KAAK,UAAU,OAAS,OAAmB,CAC7C,KAAK,QAAO,EACZ,MAAMvmB,EAAU,KAAK,OAAO,QAAQ,EAAe,MACnD,OAAO,KAAK,cAAc+G,EAAY/G,CAAO,CAC/C,CACA,MAAM0G,EAAK,KAAK,QAAO,EACvB,KAAK,QAAO,EACZ,MAAM8f,EAAa,KAAK,kBAAiB,EACzC,OAAQ9f,EAAG,KAAI,CACb,IAAK,KACH,OAAO0R,EAAQ,GAAG7Q,EAAIif,CAAU,CAAC,EACnC,IAAK,MACH,OAAOpO,EAAQ,IAAI7Q,EAAIif,CAAU,CAAC,EACpC,IAAK,KACH,OAAOpO,EAAQ,GAAG7Q,EAAIif,CAAU,CAAC,EACnC,IAAK,MACH,OAAOpO,EAAQ,IAAI7Q,EAAIif,CAAU,CAAC,EACpC,IAAK,KACH,OAAOpO,EAAQ,GAAG7Q,EAAIif,CAAU,CAAC,EACnC,IAAK,MACH,OAAOpO,EAAQ,IAAI7Q,EAAIif,CAAU,CAAC,EACpC,QACE,MAAM,IAAIhqB,GAAW,4CAA4CkK,EAAG,QAAQ,UAAUA,EAAG,KAAK,GAAG,CACzG,CACE,CACA,0BAA2B,CACzB,MAAMuf,EAAU,KAAK,QAAO,EAAG,MAAM,YAAW,EAChD,KAAK,OAAO,QAAQ,EACpB,IAAIlf,EACA,KAAK,UAAU,OAAS,QAC1BA,EAAa,IACb,KAAK,QAAO,GAEZA,EAAa,KAAK,OAAO,YAAY,EAAmB,MAE1D,KAAK,OAAO,QAAQ,EAIpB,MAAM0f,EAHiB,KAAK,aAAa,KACtC5J,GAASA,EAAK,YAAcoJ,GAAWpJ,EAAK,SAAW9V,CAC9D,GACqC,QAAUA,IAAe,IAAM,GAAGkf,EAAQ,YAAW,CAAE,GAAK,GAAGA,EAAQ,YAAW,CAAE,IAAIlf,CAAU,IAC7H2f,EAAapf,GAAImf,CAAQ,EACzB/f,EAAK,KAAK,QAAO,EACvB,KAAK,QAAO,EACZ,MAAM8f,EAAa,KAAK,kBAAiB,EACzC,OAAQ9f,EAAG,KAAI,CACb,IAAK,KACH,OAAOggB,EAAW,GAAGnf,EAAIif,CAAU,CAAC,EACtC,IAAK,MACH,OAAOE,EAAW,IAAInf,EAAIif,CAAU,CAAC,EACvC,IAAK,KACH,OAAOE,EAAW,GAAGnf,EAAIif,CAAU,CAAC,EACtC,IAAK,MACH,OAAOE,EAAW,IAAInf,EAAIif,CAAU,CAAC,EACvC,IAAK,KACH,OAAOE,EAAW,GAAGnf,EAAIif,CAAU,CAAC,EACtC,IAAK,MACH,OAAOE,EAAW,IAAInf,EAAIif,CAAU,CAAC,EACvC,QACE,MAAM,IAAIhqB,GAAW,4CAA4CkK,EAAG,QAAQ,UAAUA,EAAG,KAAK,GAAG,CACzG,CACE,CACA,mBAAoB,CAClB,MAAM4e,EAAQ,KAAK,QAAO,EAC1B,GAAIA,EAAM,OAAS,SACjB,YAAK,QAAO,EACL,WAAWA,EAAM,KAAK,EAE/B,GAAIA,EAAM,OAAS,SACjB,YAAK,QAAO,EACLA,EAAM,MAEf,GAAIA,EAAM,OAAS,OACjB,YAAK,QAAO,EACL,KAET,GAAIA,EAAM,OAAS,aAA+B,CAChD,MAAMF,EAAQE,EAAM,MAAM,YAAW,EACrC,GAAIF,IAAU,OACZ,YAAK,QAAO,EACL,GAET,GAAIA,IAAU,QACZ,YAAK,QAAO,EACL,EAEX,CACA,MAAM,IAAI5oB,GAAW,sCAAsC8oB,EAAM,QAAQ,UAAUA,EAAM,KAAK,GAAG,CACnG,CACA,gBAAiB,CACf,KAAK,OAAO,QAAQ,EACpB,MAAMlnB,EAAS,CAAA,EAEf,IADAA,EAAO,KAAK,KAAK,mBAAmB,EAC7B,KAAK,MAAM,UAChBA,EAAO,KAAK,KAAK,mBAAmB,EAEtC,YAAK,OAAO,QAAQ,EACbA,CACT,CACA,cAAc2I,EAAY/G,EAAS,CACjC,MAAM2mB,EAAW,IAAM3mB,EAAQ,QAAQ,sBAAuB,MAAM,EAAE,QAAQ,KAAM,IAAI,EAAE,QAAQ,KAAM,GAAG,EAAI,IAC/G,OAAO,IAAI4mB,GAAS7f,EAAY4f,CAAQ,CAC1C,CACF,EACIC,GAAW,cAAcziB,CAAK,CAChC,YACA,UACA,YAAY4C,EAAY4f,EAAU,CAChC,MAAK,EACL,KAAK,YAAc5f,EACnB,KAAK,UAAY4f,CACnB,CACA,IAAI,cAAe,CACjB,MAAO,CAAC,KAAK,WAAW,CAC1B,CACA,SAAStgB,EAAK,CACZ,MAAMxG,EAASwG,EAAI,IAAI,KAAK,WAAW,EACjCwgB,EAAQ,IAAI,OAAO,KAAK,SAAS,EACjCvmB,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAI0C,EAAO,OAAQ1C,IAAK,CACtC,MAAMgB,EAAM0B,EAAO,OAAO,IAAI1C,CAAC,EAC3BgB,IAAQ,KACVmC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAKumB,EAAM,KAAK,OAAO1oB,GAAQ,SAAWA,EAAM,GAAGA,CAAG,EAAE,CAAC,CAErE,CACA,OAAO,IAAIkC,EAAO,cAAef,EAAc,KAAKgB,CAAO,CAAC,CAC9D,CACA,UAAW,CACT,MAAO,QAAQ,KAAK,WAAW,KAAK,KAAK,SAAS,GACpD,CACF,EACIgmB,GAAc,cAAcniB,CAAK,CACnC,YACA,QACA,YAAY4C,EAAY+f,EAAQ,CAC9B,MAAK,EACL,KAAK,YAAc/f,EACnB,KAAK,QAAU+f,CACjB,CACA,IAAI,cAAe,CACjB,MAAO,CAAC,KAAK,WAAW,CAC1B,CACA,SAASzgB,EAAK,CACZ,MAAMxG,EAASwG,EAAI,IAAI,KAAK,WAAW,EACvC,OAAO,KAAK,QAAUxG,EAAO,UAAS,EAAKA,EAAO,OAAM,CAC1D,CACA,UAAW,CACT,MAAO,GAAG,KAAK,WAAW,OAAO,KAAK,QAAU,OAAS,EAAE,MAC7D,CACF,EACA,SAASknB,GAAatB,EAAaG,EAAgB,CACjD,MAAMpP,EAAQ,CAAA,EACd,UAAWqG,KAAQ4I,EAAa,CAE9B,GADIG,EAAe,SAAS/I,EAAK,MAAM,GACnCA,EAAK,YAAc,OAAQ,SAC/B,MAAMsJ,EAAQtJ,EAAK,QAAUA,EAAK,SAAW,IAAM,GAAGA,EAAK,UAAU,YAAW,CAAE,GAAK,GAAGA,EAAK,UAAU,YAAW,CAAE,IAAIA,EAAK,MAAM,IAC/HtF,EAAYsF,EAAK,SAAW,IAAM+I,EAAe,CAAC,EAAI/I,EAAK,OAC3DmK,EAAS1f,GAAIiQ,CAAS,EAC5B,OAAQsF,EAAK,UAAS,CACpB,IAAK,MACHrG,EAAM2P,CAAK,EAAIa,EAAO,IAAG,EACzB,MACF,IAAK,MACHxQ,EAAM2P,CAAK,EAAIa,EAAO,KAAI,EAC1B,MACF,IAAK,QACHxQ,EAAM2P,CAAK,EAAIa,EAAO,MAAK,EAC3B,MACF,IAAK,MACHxQ,EAAM2P,CAAK,EAAIa,EAAO,IAAG,EACzB,MACF,IAAK,MACHxQ,EAAM2P,CAAK,EAAIa,EAAO,IAAG,EACzB,KACR,CACE,CACA,OAAOxQ,CACT,CACA,SAASyQ,GAAa5gB,EAAK6gB,EAAU,CACnC,MAAMhC,EAASD,GAASiC,CAAQ,EAE1BC,EADS,IAAI9B,GAAOH,CAAM,EACX,MAAK,EAC1B,IAAI7nB,EAASgJ,EAIb,GAHI8gB,EAAM,YAAc,SACtB9pB,EAASA,EAAO,OAAO8pB,EAAM,SAAS,GAEpCA,EAAM,eAAe,OAAS,EAAG,CACnC,MAAMC,EAAUL,GAAaI,EAAM,YAAaA,EAAM,cAAc,EAMpE,GAJA9pB,EADcA,EAAO,QAAQ,GAAG8pB,EAAM,cAAc,EACrC,IAAIC,CAAO,EACtBD,EAAM,aAAe,SACvB9pB,EAASA,EAAO,OAAO8pB,EAAM,UAAU,GAErC,CAACA,EAAM,UAAW,CACpB,MAAME,EAAe,CAAA,EACrB,UAAWxK,KAAQsK,EAAM,YACvB,GAAItK,EAAK,YAAc,OAAQ,CAC7B,MAAMsJ,EAAQtJ,EAAK,QAAUA,EAAK,SAAW,IAAM,GAAGA,EAAK,UAAU,YAAW,CAAE,GAAK,GAAGA,EAAK,UAAU,YAAW,CAAE,IAAIA,EAAK,MAAM,IACrIwK,EAAa,KAAKlB,CAAK,CACzB,MACEkB,EAAa,KAAKxK,EAAK,OAASA,EAAK,MAAM,EAG/Cxf,EAASA,EAAO,OAAO,GAAGgqB,CAAY,CACxC,CACF,SACM,CAACF,EAAM,UAAW,CACpB,MAAMG,EAAcH,EAAM,YAAY,IAAKtK,GAASA,EAAK,MAAM,EAC/Dxf,EAASA,EAAO,OAAO,GAAGiqB,CAAW,EACrC,MAAMC,EAAY,CAAA,EAClB,UAAW1K,KAAQsK,EAAM,YACnBtK,EAAK,QAAU,SACjB0K,EAAU1K,EAAK,MAAM,EAAIA,EAAK,OAG9B,OAAO,KAAK0K,CAAS,EAAE,OAAS,IAClClqB,EAASA,EAAO,OAAOkqB,CAAS,EAEpC,CAEF,GAAIJ,EAAM,aAAa,OAAS,EAAG,CACjC,MAAMxjB,EAAUwjB,EAAM,aAAa,IAAKtK,GAASA,EAAK,MAAM,EACtD2K,EAASL,EAAM,aAAa,IAAKtK,GAASA,EAAK,SAAS,EAC9Dxf,EAASA,EAAO,OAAOsG,EAAS6jB,CAAM,CACxC,CACA,OAAIL,EAAM,QAAU,SAClB9pB,EAASA,EAAO,KAAK8pB,EAAM,KAAK,GAE3B9pB,CACT,CAGG,IAACoqB,GAAY,MAAMC,CAAW,CAC/B,OAAO,SAA2B,IAAI,IACtC,OAAO,SAA2B,IAAI,IACtC,SACA,aACA,YAAY/jB,EAASiQ,EAAa,CAChC,KAAK,SAAWjQ,EAChB,KAAK,aAAeiQ,EACpB,UAAWzT,KAAQwD,EAAQ,SACzBxD,EAAK,OAAM,CAEf,CACA,IAAI,OAAQ,CACV,MAAO,CAAC,KAAK,OAAQ,KAAK,aAAa,MAAM,CAC/C,CACA,IAAI,SAAU,CACZ,MAAO,CAAC,GAAG,KAAK,YAAY,CAC9B,CACA,IAAI,QAAS,CACX,MAAM9C,EAAS,CAAA,EACf,UAAWmF,KAAQ,KAAK,aACtBnF,EAAOmF,CAAI,EAAI,KAAK,SAAS,IAAIA,CAAI,EAAE,MAEzC,OAAOnF,CACT,CACA,IAAI,QAAS,CACX,OAAI,KAAK,aAAa,SAAW,EAAU,EACpC,KAAK,SAAS,IAAI,KAAK,aAAa,CAAC,CAAC,EAAE,MACjD,CACA,IAAImF,EAAM,CACR,MAAMpG,EAAS,KAAK,SAAS,IAAIoG,CAAI,EACrC,GAAI,CAACpG,EACH,MAAM,IAAID,EAAoBqG,EAAM,KAAK,YAAY,EAEvD,OAAO,IAAInC,EAAOmC,EAAMpG,CAAM,CAChC,CACA,IAAIW,EAAO,CACT,GAAIA,EAAQ,GAAKA,GAAS,KAAK,OAC7B,MAAM,IAAIf,EACR,oBACA,aAAae,CAAK,qCAAqC,KAAK,MAAM,OAC1E,EAEI,MAAMM,EAAS,CAAA,EACf,UAAWmF,KAAQ,KAAK,aACtBnF,EAAOmF,CAAI,EAAI,KAAK,SAAS,IAAIA,CAAI,EAAE,IAAIzF,CAAK,EAElD,OAAOM,CACT,CACA,EAAE,OAAO,QAAQ,GAAI,CACnB,QAASF,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAC/B,MAAM,KAAK,IAAIA,CAAC,CAEpB,CACA,MAAO,CACL,OAAO,KAAK,OAAO,QAAQ,EAAC,CAC9B,CACA,SAAU,CACR,MAAME,EAAS,CAAA,EACf,QAASF,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAC/BE,EAAO,KAAK,KAAK,IAAIF,CAAC,CAAC,EAEzB,OAAOE,CACT,CACA,OAAQ,CACN,MAAMsqB,EAAgC,IAAI,IAC1C,SAAW,CAACnlB,EAAMrC,CAAI,IAAK,KAAK,SAC9BwnB,EAAc,IAAInlB,EAAMrC,EAAK,MAAK,CAAE,EAEtC,OAAO,IAAIunB,EAAWC,EAAe,CAAC,GAAG,KAAK,YAAY,CAAC,CAC7D,CACA,OAAQ,CACN,OAAO,KAAK,MAAK,CACnB,CACA,MAAO,CACL,OAAO5C,GAAgB,IAAI,CAC7B,CACA,UAAUphB,EAAS,CACjB,UAAWnB,KAAQmB,EACjB,GAAI,CAAC,KAAK,SAAS,IAAInB,CAAI,EACzB,MAAM,IAAIrG,EAAoBqG,EAAM,KAAK,YAAY,EAGzD,MAAM+V,EAA6B,IAAI,IACvC,UAAW/V,KAAQmB,EACjB4U,EAAW,IAAI/V,EAAM,KAAK,SAAS,IAAIA,CAAI,CAAC,EAE9C,OAAO,IAAIklB,EAAWnP,EAAY,CAAC,GAAG5U,CAAO,CAAC,CAChD,CACA,QAAQA,EAAS,CACf,UAAWnB,KAAQmB,EACjB,GAAI,CAAC,KAAK,SAAS,IAAInB,CAAI,EACzB,MAAM,IAAIrG,EAAoBqG,EAAM,KAAK,YAAY,EAGzD,MAAMolB,EAAU,IAAI,IAAIjkB,CAAO,EACzB4U,EAA6B,IAAI,IACjCsP,EAAW,CAAA,EACjB,UAAWrlB,KAAQ,KAAK,aACjBolB,EAAQ,IAAIplB,CAAI,IACnB+V,EAAW,IAAI/V,EAAM,KAAK,SAAS,IAAIA,CAAI,CAAC,EAC5CqlB,EAAS,KAAKrlB,CAAI,GAGtB,OAAO,IAAIklB,EAAWnP,EAAYsP,CAAQ,CAC5C,CACA,KAAKjmB,EAAI,EAAG,CACV,OAAO,KAAK,MAAM,EAAG,KAAK,IAAIA,EAAG,KAAK,MAAM,CAAC,CAC/C,CACA,KAAKA,EAAI,EAAG,CACV,MAAMjE,EAAQ,KAAK,IAAI,EAAG,KAAK,OAASiE,CAAC,EACzC,OAAO,KAAK,MAAMjE,EAAO,KAAK,MAAM,CACtC,CACA,MAAMA,EAAOC,EAAK,CAChB,MAAMkqB,EAAclqB,IAAQ,OAAS,KAAK,OAAS,KAAK,IAAIA,EAAK,KAAK,MAAM,EACtEmqB,EAAgB,KAAK,IAAI,EAAGpqB,CAAK,EACjC4a,EAA6B,IAAI,IACvC,UAAW/V,KAAQ,KAAK,aACtB+V,EAAW,IAAI/V,EAAM,KAAK,SAAS,IAAIA,CAAI,EAAE,MAAMulB,EAAeD,CAAW,CAAC,EAEhF,OAAO,IAAIJ,EAAWnP,EAAY,CAAC,GAAG,KAAK,YAAY,CAAC,CAC1D,CACA,WAAW/V,EAAMwlB,EAAkB,CACjC,GAAIA,aAA4B7jB,EAAM,CACpC,MAAMtE,EAASmoB,EAAiB,SAAS,IAAI,EACvCC,EAAc,IAAI,IAAI,KAAK,QAAQ,EACzCA,EAAY,IAAIzlB,EAAM3C,EAAO,MAAM,EACnC,MAAMqoB,EAAY,KAAK,aAAa,SAAS1lB,CAAI,EAAI,CAAC,GAAG,KAAK,YAAY,EAAI,CAAC,GAAG,KAAK,aAAcA,CAAI,EACzG,OAAO,IAAIklB,EAAWO,EAAaC,CAAS,CAC9C,CACA,IAAIC,EACJ,GAAI,OAAOH,GAAqB,WAAY,CAC1C,MAAMtnB,EAAKsnB,EACXG,EAAe,CAAA,EACf,QAAShrB,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAC/BgrB,EAAa,KAAKznB,EAAG,KAAK,IAAIvD,CAAC,CAAC,CAAC,CAErC,SACEgrB,EAAeH,EACXG,EAAa,SAAW,KAAK,OAC/B,MAAM,IAAI5rB,GACR,WAAWiG,CAAI,gBAAgB2lB,EAAa,MAAM,cAAc,KAAK,MAAM,EACrF,EAGI,MAAMvkB,EAAQwkB,GAAaD,CAAY,EACjCE,EAASC,GAAY1kB,EAAOukB,CAAY,EACxC5P,EAAa,IAAI,IAAI,KAAK,QAAQ,EACxCA,EAAW,IAAI/V,EAAM6lB,CAAM,EAC3B,MAAMR,EAAW,KAAK,aAAa,SAASrlB,CAAI,EAAI,CAAC,GAAG,KAAK,YAAY,EAAI,CAAC,GAAG,KAAK,aAAcA,CAAI,EACxG,OAAO,IAAIklB,EAAWnP,EAAYsP,CAAQ,CAC5C,CACA,OAAOzqB,EAAO,CACZ,GAAIA,EAAM,SAAW,KAAK,QAAUA,EAAM,QAAQ,OAAS,GAAK,KAAK,aAAa,OAAS,EACzF,MAAM,IAAIb,GACR,gCAAgCa,EAAM,MAAM,2BAA2B,KAAK,MAAM,OAC1F,EAEI,MAAMmb,EAAa,IAAI,IAAI,KAAK,QAAQ,EAClCsP,EAAW,CAAC,GAAG,KAAK,YAAY,EACtC,UAAWrlB,KAAQpF,EAAM,QACvBmb,EAAW,IAAI/V,EAAMpF,EAAM,SAAS,IAAIoF,CAAI,CAAC,EACxC,KAAK,aAAa,SAASA,CAAI,GAClCqlB,EAAS,KAAKrlB,CAAI,EAGtB,OAAO,IAAIklB,EAAWnP,EAAYsP,CAAQ,CAC5C,CACA,OAAOniB,EAAO,CACZ,IAAIrI,EAAS,KACb,SAAW,CAACmF,EAAM9B,CAAE,IAAK,OAAO,QAAQgF,CAAK,EAAG,CAC9C,GAAI,KAAK,SAAW,EAAG,CACrBrI,EAASA,EAAO,WAAWmF,EAAM,CAAA,CAAE,EACnC,QACF,CACA,MAAMqe,EAAQngB,EAAG,KAAK,IAAI,CAAC,CAAC,EAC5B,GAAImgB,aAAiB1c,EAAM,CACzB9G,EAASA,EAAO,WAAWmF,EAAMqe,EAAM,SAAS,IAAI,EAAE,SAAS,EAC/D,QACF,CACA,MAAMziB,EAAS,CAACyiB,CAAK,EACrB,QAAS1jB,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAC/BiB,EAAO,KAAKsC,EAAG,KAAK,IAAIvD,CAAC,CAAC,CAAC,EAE7BE,EAASA,EAAO,WAAWmF,EAAMpE,CAAM,CACzC,CACA,OAAOf,CACT,CACA,OAAOD,EAAOwb,EAAIxa,EAAQ,CACxB,OAAOid,GAAO,KAAMje,EAAOwb,EAAIxa,CAAM,CACvC,CACA,OAAOhC,EAAQkM,EAAS,CACtB,OAAOkT,GAAO,KAAMpf,EAAQkM,CAAO,CACrC,CACA,OAAO3E,EAAS2E,EAAS,CACvB,OAAO2T,GAAO,KAAMtY,EAAS2E,CAAO,CACtC,CACA,OAAOlK,EAAQkK,EAAS,CACtB,OAAOwU,GAAO,KAAM1e,EAAQkK,CAAO,CACrC,CACA,SAAS3E,EAAS2E,EAAS,CACzB,KAAM,CAAE,OAAAigB,EAAQ,MAAAC,CAAK,EAAKlgB,EAC1B,GAAIigB,IAAW,QAAUC,IAAU,OACjC,MAAM,IAAIxsB,EACR,oBACA,sDACR,EAEI,GAAIusB,IAAW,QAAUC,IAAU,OACjC,MAAM,IAAIxsB,EACR,oBACA,qDACR,EAEI,UAAWmE,KAAQwD,EACjB,GAAI,CAAC,KAAK,SAAS,IAAIxD,CAAI,EACzB,MAAM,IAAIhE,EAAoBgE,EAAM,KAAK,YAAY,EAGzD,MAAMsoB,EAASF,GAAUC,EACzB,GAAI,CAAC,KAAK,SAAS,IAAIC,CAAM,EAC3B,MAAM,IAAItsB,EAAoBssB,EAAQ,KAAK,YAAY,EAEzD,MAAMna,EAAY,KAAK,aAAa,OAAQ5D,GAAM,CAAC/G,EAAQ,SAAS+G,CAAC,CAAC,EAChEge,EAAYpa,EAAU,QAAQma,CAAM,EACpCE,EAAYJ,IAAW,OAASG,EAAYA,EAAY,EACxDb,EAAW,CAAC,GAAGvZ,EAAU,MAAM,EAAGqa,CAAS,EAAG,GAAGhlB,EAAS,GAAG2K,EAAU,MAAMqa,CAAS,CAAC,EAC7F,OAAO,IAAIjB,EAAW,IAAI,IAAI,KAAK,QAAQ,EAAGG,CAAQ,CACxD,CACA,OAAOe,EAAS,CACd,UAAWC,KAAW,OAAO,KAAKD,CAAO,EACvC,GAAI,CAAC,KAAK,SAAS,IAAIC,CAAO,EAC5B,MAAM,IAAI1sB,EAAoB0sB,EAAS,KAAK,YAAY,EAG5D,MAAMtQ,EAA6B,IAAI,IACjCsP,EAAW,CAAA,EACjB,UAAWrlB,KAAQ,KAAK,aAAc,CACpC,MAAMsmB,EAAUF,EAAQpmB,CAAI,GAAKA,EACjC+V,EAAW,IAAIuQ,EAAS,KAAK,SAAS,IAAItmB,CAAI,CAAC,EAC/CqlB,EAAS,KAAKiB,CAAO,CACvB,CACA,OAAO,IAAIpB,EAAWnP,EAAYsP,CAAQ,CAC5C,CACA,OAAOkB,EAAiB,CACtB,GAAIA,aAA2B5kB,EAAM,CAEnC,MAAM6kB,EADWD,EAEjB,GAAIC,EAAO,MAAQ,QAAUA,EAAO,iBAAiB1iB,IAAc0iB,EAAO,kBAAkBpjB,EAAa,CACvG,MAAMmB,EAAaiiB,EAAO,MAAM,aAAa,CAAC,EACxChiB,EAAUgiB,EAAO,OAAO,OACxBxoB,EAAS,KAAK,SAAS,IAAIuG,CAAU,EAC3C,GAAIvG,EAAQ,CACV,IAAIyoB,EAAS,EACb,QAAS9rB,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAAK,CACpC,MAAMmB,EAAIkC,EAAO,IAAIrD,CAAC,EACtB,GAAImB,IAAM,MAAQ0I,IAAY,KAAM,SACpC,IAAIkiB,EAAO,GACX,OAAQF,EAAO,IAAG,CAChB,IAAK,KACHE,EAAO5qB,IAAM0I,EACb,MACF,IAAK,MACHkiB,EAAO5qB,IAAM0I,EACb,MACF,IAAK,KACHkiB,EAAO5qB,EAAI0I,EACX,MACF,IAAK,MACHkiB,EAAO5qB,GAAK0I,EACZ,MACF,IAAK,KACHkiB,EAAO5qB,EAAI0I,EACX,MACF,IAAK,MACHkiB,EAAO5qB,GAAK0I,EACZ,KAChB,CACgBkiB,GAAMD,GACZ,CACA,GAAIA,IAAW,KAAK,OAClB,OAAO,KAET,GAAIA,IAAW,EACb,OAAO,KAAK,MAAM,EAAG,CAAC,EAExB,MAAME,EAAW,IAAI,WAAWF,CAAM,EACtC,IAAIG,EAAO,EACX,QAASjsB,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAAK,CACpC,MAAMmB,EAAIkC,EAAO,IAAIrD,CAAC,EACtB,GAAImB,IAAM,MAAQ0I,IAAY,KAAM,SACpC,IAAIkiB,EAAO,GACX,OAAQF,EAAO,IAAG,CAChB,IAAK,KACHE,EAAO5qB,IAAM0I,EACb,MACF,IAAK,MACHkiB,EAAO5qB,IAAM0I,EACb,MACF,IAAK,KACHkiB,EAAO5qB,EAAI0I,EACX,MACF,IAAK,MACHkiB,EAAO5qB,GAAK0I,EACZ,MACF,IAAK,KACHkiB,EAAO5qB,EAAI0I,EACX,MACF,IAAK,MACHkiB,EAAO5qB,GAAK0I,EACZ,KAChB,CACgBkiB,IAAMC,EAASC,GAAM,EAAIjsB,EAC/B,CACA,OAAO,KAAK,oBAAoBgsB,CAAQ,CAC1C,CACF,CACA,MAAME,EAAaN,EAAgB,SAAS,IAAI,EAChD,IAAIO,EAAS,EACb,QAASnsB,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAC3BksB,EAAW,IAAIlsB,CAAC,IAAM,IACxBmsB,IAGJ,GAAIA,IAAW,KAAK,OAClB,OAAO,KAET,GAAIA,IAAW,EACb,OAAO,KAAK,MAAM,EAAG,CAAC,EAExB,MAAMC,EAAW,IAAI,WAAWD,CAAM,EACtC,IAAIE,EAAO,EACX,QAASrsB,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAC3BksB,EAAW,IAAIlsB,CAAC,IAAM,KACxBosB,EAASC,GAAM,EAAIrsB,GAGvB,OAAO,KAAK,oBAAoBosB,CAAQ,CAC1C,CACA,MAAMtlB,EAAY8kB,EAClB,IAAIztB,EAAQ,EACZ,QAAS,EAAI,EAAG,EAAI,KAAK,OAAQ,IAC3B2I,EAAU,KAAK,IAAI,CAAC,CAAC,GACvB3I,IAGJ,GAAIA,IAAU,KAAK,OACjB,OAAO,KAET,GAAIA,IAAU,EACZ,OAAO,KAAK,MAAM,EAAG,CAAC,EAExB,MAAMyC,EAAU,IAAI,WAAWzC,CAAK,EACpC,IAAI6pB,EAAM,EACV,QAAS,EAAI,EAAG,EAAI,KAAK,OAAQ,IAC3BlhB,EAAU,KAAK,IAAI,CAAC,CAAC,IACvBlG,EAAQonB,GAAK,EAAI,GAGrB,OAAO,KAAK,oBAAoBpnB,CAAO,CACzC,CACA,MAAM2C,EAAI,CACR,GAAI,KAAK,SAAW,EAClB,OAAO,IAAIgnB,EAA2B,IAAI,IAAO,CAAC,GAAG,KAAK,YAAY,CAAC,EAEzE,MAAMpc,EAAO,CAAA,EACb,QAASnO,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAC/BmO,EAAK,KAAK5K,EAAG,KAAK,IAAIvD,CAAC,CAAC,CAAC,EAE3B,OAAOuqB,EAAW,SAASpc,CAAI,CACjC,CACA,MAAMlP,EAAQsK,EAAIxJ,EAAO,CACvB,MAAMkb,EAAU9Q,GAAIlL,CAAM,EACpBqtB,EAAWvsB,EACjB,IAAIgJ,EACJ,OAAQQ,EAAE,CACR,IAAK,IACHR,EAAOkS,EAAQ,GAAGqR,CAAQ,EAC1B,MACF,IAAK,KACHvjB,EAAOkS,EAAQ,IAAIqR,CAAQ,EAC3B,MACF,IAAK,IACHvjB,EAAOkS,EAAQ,GAAGqR,CAAQ,EAC1B,MACF,IAAK,KACHvjB,EAAOkS,EAAQ,IAAIqR,CAAQ,EAC3B,MACF,IAAK,IACHvjB,EAAOkS,EAAQ,GAAGqR,CAAQ,EAC1B,MACF,IAAK,KACHvjB,EAAOkS,EAAQ,IAAIqR,CAAQ,EAC3B,KACR,CACI,OAAO,KAAK,OAAOvjB,CAAI,CACzB,CACA,OAAOvC,EAASL,EAAO,CACrB,MAAMmK,EAAO,MAAM,QAAQ9J,CAAO,EAAIA,EAAU,CAACA,CAAO,EAClD6jB,EAAS,MAAM,QAAQlkB,CAAK,EAAIA,EAAQmK,EAAK,IAAI,IAAMnK,GAAS,KAAK,EAC3E,UAAWd,KAAQiL,EACjB,GAAI,CAAC,KAAK,SAAS,IAAIjL,CAAI,EACzB,MAAM,IAAIrG,EAAoBqG,EAAM,KAAK,YAAY,EAGzD,GAAIiL,EAAK,SAAW,EAAG,CACrB,MAAMic,EAAU,KAAK,SAAS,IAAIjc,EAAK,CAAC,CAAC,EACnCuJ,EAAO,IAAI,MAAM,KAAK,MAAM,EAClC,QAAS7Z,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAAK6Z,EAAK7Z,CAAC,EAAIusB,EAAQ,IAAIvsB,CAAC,EAC7D,MAAMwsB,EAAOnC,EAAO,CAAC,IAAM,OACrB+B,EAAW,MAAM,KAAK,CAAE,OAAQ,KAAK,QAAU,CAACxb,EAAG5Q,IAAMA,CAAC,EAChEosB,EAAS,KAAK,CAACjoB,EAAGC,IAAM,CACtB,MAAMqoB,EAAK5S,EAAK1V,CAAC,EACXuoB,EAAK7S,EAAKzV,CAAC,EACXuoB,EAAUF,GAAO,KACjBG,EAAUF,GAAO,KACvB,GAAIC,GAAWC,EAAS,MAAO,GAC/B,GAAID,EAAS,MAAO,GACpB,GAAIC,EAAS,MAAO,GACpB,IAAIC,EAAM,EACV,OAAI,OAAOJ,GAAO,UAAY,OAAOC,GAAO,SAC1CG,EAAMJ,EAAKC,EACF,OAAOD,GAAO,UAAY,OAAOC,GAAO,SACjDG,EAAMJ,EAAKC,EAAK,GAAKD,EAAKC,EAAK,EAAI,EAC1B,OAAOD,GAAO,WAAa,OAAOC,GAAO,UAClDG,GAAOJ,EAAK,EAAI,IAAMC,EAAK,EAAI,GACtBD,aAAc,MAAQC,aAAc,OAC7CG,EAAMJ,EAAG,UAAYC,EAAG,QAAO,GAE1BF,EAAO,CAACK,EAAMA,CACvB,CAAC,EACD,MAAMC,EAAgB,IAAI,WAAWV,CAAQ,EACvCtB,EAA8B,IAAI,IACxC,UAAWzlB,KAAQ,KAAK,aACtBylB,EAAY,IAAIzlB,EAAM,KAAK,SAAS,IAAIA,CAAI,EAAE,KAAKynB,CAAa,CAAC,EAEnE,OAAO,IAAIvC,EAAWO,EAAa,CAAC,GAAG,KAAK,YAAY,CAAC,CAC3D,CACA,GAAIxa,EAAK,SAAW,GAAK,KAAK,SAAS,IAAIA,EAAK,CAAC,CAAC,EAAE,QAAU,SAAsB,KAAK,SAAS,IAAIA,EAAK,CAAC,CAAC,EAAE,QAAU,OAAuB,KAAK,SAAS,IAAIA,EAAK,CAAC,CAAC,EAAE,QAAU,OAAoB,CACvM,MAAMyc,EAAK,KAAK,SAAS,IAAIzc,EAAK,CAAC,CAAC,EAC9B0c,EAAK,KAAK,SAAS,IAAI1c,EAAK,CAAC,CAAC,EAC9B2c,EAAK,IAAI,MAAM,KAAK,MAAM,EAC1BC,EAAK,IAAI,MAAM,KAAK,MAAM,EAChC,QAASltB,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAC/BitB,EAAGjtB,CAAC,EAAI+sB,EAAG,IAAI/sB,CAAC,EAChBktB,EAAGltB,CAAC,EAAIgtB,EAAG,IAAIhtB,CAAC,EAElB,MAAMmtB,EAAK9C,EAAO,CAAC,IAAM,OACnB+C,EAAK/C,EAAO,CAAC,IAAM,OACnB+B,EAAW,MAAM,KAAK,CAAE,OAAQ,KAAK,QAAU,CAAC,EAAGpsB,IAAMA,CAAC,EAChEosB,EAAS,KAAK,CAACjoB,EAAGC,IAAM,CACtB,MAAMipB,EAAKJ,EAAG9oB,CAAC,EACTmpB,EAAKL,EAAG7oB,CAAC,EACTmpB,EAASF,IAAO,KAChBG,EAASF,IAAO,KACtB,GAAI,CAACC,GAAU,CAACC,EAAQ,CACtB,GAAID,EAAQ,MAAO,GACnB,GAAIC,EAAQ,MAAO,GACnB,MAAMC,EAAOJ,EAAKC,EAAK,GAAKD,EAAKC,EAAK,EAAI,EAC1C,GAAIG,IAAS,EAAG,OAAON,EAAK,CAACM,EAAOA,CACtC,CACA,MAAMC,EAAKR,EAAG/oB,CAAC,EACTwpB,EAAKT,EAAG9oB,CAAC,EACTwpB,EAASF,IAAO,KAChBG,EAASF,IAAO,KACtB,GAAIC,GAAUC,EAAQ,MAAO,GAC7B,GAAID,EAAQ,MAAO,GACnB,GAAIC,EAAQ,MAAO,GACnB,MAAMC,EAAOJ,EAAKC,EAClB,OAAOP,EAAK,CAACU,EAAOA,CACtB,CAAC,EACD,MAAMhB,EAAgB,IAAI,WAAWV,CAAQ,EAC7C,OAAO,KAAK,oBAAoBU,CAAa,CAC/C,CACA,MAAMiB,EAAazd,EAAK,IAAKjL,GAAS,CACpC,MAAMrC,EAAO,KAAK,SAAS,IAAIqC,CAAI,EAC7BwU,EAAO,IAAI,MAAM,KAAK,MAAM,EAClC,QAAS7Z,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAC/B6Z,EAAK7Z,CAAC,EAAIgD,EAAK,IAAIhD,CAAC,EAEtB,OAAO6Z,CACT,CAAC,EACKjZ,EAAU,MAAM,KAAK,CAAE,OAAQ,KAAK,QAAU,CAACgQ,EAAG5Q,IAAMA,CAAC,EAC/DY,EAAQ,KAAK,CAACuD,EAAGC,IAAM,CACrB,QAASmJ,EAAI,EAAGA,EAAI+C,EAAK,OAAQ/C,IAAK,CACpC,MAAMkf,EAAKsB,EAAWxgB,CAAC,EAAEpJ,CAAC,EACpBuoB,EAAKqB,EAAWxgB,CAAC,EAAEnJ,CAAC,EACpBuoB,EAAUF,GAAO,KACjBG,EAAUF,GAAO,KACvB,GAAIC,GAAWC,EAAS,SACxB,GAAID,EAAS,MAAO,GACpB,GAAIC,EAAS,MAAO,GACpB,IAAIC,EAAM,EAUV,GATIJ,aAAc,MAAQC,aAAc,KACtCG,EAAMJ,EAAG,UAAYC,EAAG,QAAO,EACtB,OAAOD,GAAO,UAAY,OAAOC,GAAO,SACjDG,EAAMJ,EAAKC,EAAK,GAAKD,EAAKC,EAAK,EAAI,EAC1B,OAAOD,GAAO,UAAY,OAAOC,GAAO,SACjDG,EAAMJ,EAAKC,EACF,OAAOD,GAAO,WAAa,OAAOC,GAAO,YAClDG,GAAOJ,EAAK,EAAI,IAAMC,EAAK,EAAI,IAE7BG,IAAQ,EACV,OAAOxC,EAAO9c,CAAC,IAAM,OAAS,CAACsf,EAAMA,CAEzC,CACA,MAAO,EACT,CAAC,EACD,MAAMjS,EAAe,IAAI,WAAWha,CAAO,EACrCwa,EAA6B,IAAI,IACvC,UAAW/V,KAAQ,KAAK,aACtB+V,EAAW,IAAI/V,EAAM,KAAK,SAAS,IAAIA,CAAI,EAAE,KAAKuV,CAAY,CAAC,EAEjE,OAAO,IAAI2P,EAAWnP,EAAY,CAAC,GAAG,KAAK,YAAY,CAAC,CAC1D,CACA,OAAO5U,EAASulB,EAAO,QAAS,CAC9B,MAAMzb,EAAO9J,IAAY,OAAS,KAAK,aAAe,MAAM,QAAQA,CAAO,EAAIA,EAAU,CAACA,CAAO,EACjG,UAAWnB,KAAQiL,EACjB,GAAI,CAAC,KAAK,SAAS,IAAIjL,CAAI,EACzB,MAAM,IAAIrG,EAAoBqG,EAAM,KAAK,YAAY,EAGzD,MAAMW,EAAuB,IAAI,IAC3BpF,EAAU,CAAA,EAChB,GAAImrB,IAAS,QACX,QAAS,EAAI,EAAG,EAAI,KAAK,OAAQ,IAAK,CACpC,MAAM9lB,EAAM,KAAK,QAAQ,EAAGqK,CAAI,EAC3BtK,EAAK,IAAIC,CAAG,IACfD,EAAK,IAAIC,CAAG,EACZrF,EAAQ,KAAK,CAAC,EAElB,KACK,CACL,MAAMotB,EAA4B,IAAI,IAChC7nB,EAAQ,CAAA,EACd,QAASnG,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAAK,CACpC,MAAMiG,EAAM,KAAK,QAAQjG,EAAGsQ,CAAI,EAC3B0d,EAAU,IAAI/nB,CAAG,GACpBE,EAAM,KAAKF,CAAG,EAEhB+nB,EAAU,IAAI/nB,EAAKjG,CAAC,CACtB,CACA,UAAWiG,KAAOE,EAChBvF,EAAQ,KAAKotB,EAAU,IAAI/nB,CAAG,CAAC,CAEnC,CACA,OAAO,KAAK,eAAerF,CAAO,CACpC,CACA,OAAO6D,EAAG0G,EAAS,CACjB,GAAI,KAAK,SAAW,EAClB,OAAO,KAAK,MAAK,EAEnB,IAAIhN,EACJ,GAAIsG,GAAK,EACPtG,EAAQ,KAAK,IAAI,KAAK,MAAMsG,CAAC,EAAG,KAAK,MAAM,UAClCA,EAAI,GAAKA,EAAI,EACtBtG,EAAQ,KAAK,IAAI,EAAG,KAAK,MAAMsG,EAAI,KAAK,MAAM,CAAC,MAE/C,OAAM,IAAI5F,EACR,oBACA,qCAAqC4F,CAAC,EAC9C,EAEI,MAAMwpB,EAAM9iB,GAAS,OAAS,OAAS+iB,GAAa/iB,EAAQ,IAAI,EAAI,KAAK,OACnEvK,EAAU,MAAM,KAAK,CAAE,OAAQ,KAAK,QAAU,CAACgQ,EAAG5Q,IAAMA,CAAC,EAC/D,QAAS,EAAIY,EAAQ,OAAS,EAAG,EAAI,EAAG,IAAK,CAC3C,MAAM2S,EAAI,KAAK,MAAM0a,EAAG,GAAM,EAAI,EAAE,EAC9BE,EAAMvtB,EAAQ,CAAC,EACrBA,EAAQ,CAAC,EAAIA,EAAQ2S,CAAC,EACtB3S,EAAQ2S,CAAC,EAAI4a,CACf,CACA,OAAO,KAAK,eAAevtB,EAAQ,MAAM,EAAGzC,CAAK,CAAC,CACpD,CACA,WAAW8a,EAAM,CACf,OAAO,IAAID,GAAQ,KAAMC,CAAI,CAC/B,CACA,KAAKhZ,EAAOwb,EAAIqB,EAAM,QAAS3R,EAAS,CACtC,OAAO0R,GAAS,KAAM5c,EAAOwb,EAAIqB,EAAK3R,CAAO,CAC/C,CACA,MAAMA,EAAS,CACb,OAAO6V,GAAM,KAAM7V,CAAO,CAC5B,CACA,KAAKA,EAAS,CACZ,OAAOiX,GAAK,KAAMjX,CAAO,CAC3B,CACA,QAAQlM,EAAQ,CACd,GAAI,CAAC,KAAK,SAAS,IAAIA,CAAM,EAC3B,MAAM,IAAID,EAAoBC,EAAQ,KAAK,YAAY,EAEzD,MAAMmvB,EAAa,KAAK,SAAS,IAAInvB,CAAM,EACrCovB,EAAgB,KAAK,aAAa,OAAQ5pB,GAAMA,IAAMxF,CAAM,EAC5DqvB,EAAe,CAAA,EACrB,UAAWjpB,KAAQ,KAAK,aACtBipB,EAAajpB,CAAI,EAAI,CAAA,EAEvB,QAASrF,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAAK,CACpC,MAAMgB,EAAMotB,EAAW,IAAIpuB,CAAC,EAC5B,GAAIgB,IAAQ,KAAM,CAChBstB,EAAarvB,CAAM,EAAE,KAAK,IAAI,EAC9B,UAAWoG,KAAQgpB,EACjBC,EAAajpB,CAAI,EAAE,KAAK,KAAK,SAAS,IAAIA,CAAI,EAAE,IAAIrF,CAAC,CAAC,CAE1D,SAAW,MAAM,QAAQgB,CAAG,EAAG,CAC7B,GAAIA,EAAI,SAAW,EACjB,SAEF,UAAW0e,KAAQ1e,EAAK,CACtBstB,EAAarvB,CAAM,EAAE,KAAKygB,IAAS,OAAS,KAAOA,CAAI,EACvD,UAAWra,KAAQgpB,EACjBC,EAAajpB,CAAI,EAAE,KAAK,KAAK,SAAS,IAAIA,CAAI,EAAE,IAAIrF,CAAC,CAAC,CAE1D,CACF,KAAO,CACLsuB,EAAarvB,CAAM,EAAE,KAAK+B,CAAG,EAC7B,UAAWqE,KAAQgpB,EACjBC,EAAajpB,CAAI,EAAE,KAAK,KAAK,SAAS,IAAIA,CAAI,EAAE,IAAIrF,CAAC,CAAC,CAE1D,CACF,CACA,OAAOuqB,EAAW,YAAY+D,CAAY,CAC5C,CACA,UAAUlL,EAAc,CACtB,OAAOD,GAAU,KAAMC,CAAY,CACrC,CACA,OAAO,UAAUK,EAAQ,CACvB,OAAOD,GAAO,GAAGC,CAAM,CACzB,CACA,QAAQ7jB,EAAO0Q,EAAM,CACnB,MAAM8B,EAAQ,CAAA,EACd,UAAW/M,KAAQiL,EAAM,CACvB,MAAMnP,EAAI,KAAK,SAAS,IAAIkE,CAAI,EAAE,IAAIzF,CAAK,EACvCuB,IAAM,KACRiR,EAAM,KAAK,QAAQ,EACVjR,aAAa,KACtBiR,EAAM,KAAK,MAAMjR,EAAE,QAAO,CAAE,EAAE,EACrB,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAAY,OAAOA,GAAM,UACxEiR,EAAM,KAAK,KAAK,OAAOjR,CAAC,GAAG,OAAOA,CAAC,CAAC,EAAE,EAEtCiR,EAAM,KAAK,QAAQ,KAAK,UAAUjR,CAAC,CAAC,EAAE,CAE1C,CACA,OAAOiR,EAAM,KAAK,GAAG,CACvB,CACA,eAAexR,EAAS,CACtB,MAAMga,EAAe,IAAI,WAAWha,CAAO,EAC3C,OAAO,KAAK,oBAAoBga,CAAY,CAC9C,CACA,oBAAoBA,EAAc,CAChC,MAAMQ,EAA6B,IAAI,IACvC,UAAW/V,KAAQ,KAAK,aACtB+V,EAAW,IAAI/V,EAAM,KAAK,SAAS,IAAIA,CAAI,EAAE,KAAKuV,CAAY,CAAC,EAEjE,OAAO,IAAI2P,EAAWnP,EAAY,CAAC,GAAG,KAAK,YAAY,CAAC,CAC1D,CACA,SAAS5U,EAAS,CAChB,MAAM8J,EAAO9J,IAAY,OAAS,KAAK,aAAe,MAAM,QAAQA,CAAO,EAAIA,EAAU,CAACA,CAAO,EACjG,UAAWnB,KAAQiL,EACjB,GAAI,CAAC,KAAK,SAAS,IAAIjL,CAAI,EACzB,MAAM,IAAIrG,EAAoBqG,EAAM,KAAK,YAAY,EAGzD,MAAMzE,EAAU,CAAA,EAChB,QAASZ,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAAK,CACpC,IAAIkB,EAAU,GACd,UAAWmE,KAAQiL,EACjB,GAAI,KAAK,SAAS,IAAIjL,CAAI,EAAE,IAAIrF,CAAC,IAAM,KAAM,CAC3CkB,EAAU,GACV,KACF,CAEGA,GACHN,EAAQ,KAAKZ,CAAC,CAElB,CACA,OAAO,KAAK,eAAeY,CAAO,CACpC,CACA,SAAS2tB,EAAU,CACjB,GAAI,OAAOA,GAAa,SACtB,OAAO,KAAK,qBAAqBA,CAAQ,EAE3C,UAAW/hB,KAAW,OAAO,KAAK+hB,CAAQ,EACxC,GAAI,CAAC,KAAK,SAAS,IAAI/hB,CAAO,EAC5B,MAAM,IAAIxN,EAAoBwN,EAAS,KAAK,YAAY,EAG5D,MAAM4O,EAA6B,IAAI,IACvC,UAAW/V,KAAQ,KAAK,aAAc,CACpC,MAAMrC,EAAO,KAAK,SAAS,IAAIqC,CAAI,EAC7Bqb,EAAY6N,EAASlpB,CAAI,EAC/B,GAAIqb,IAAc,OAAQ,CACxB,MAAMzf,EAAS,CAAA,EACf,QAASjB,EAAI,EAAGA,EAAIgD,EAAK,OAAQhD,IAAK,CACpC,MAAMmB,EAAI6B,EAAK,IAAIhD,CAAC,EACpBiB,EAAO,KAAKE,IAAM,KAAOuf,EAAYvf,CAAC,CACxC,CACAia,EAAW,IAAI/V,EAAM8lB,GAAYnoB,EAAK,MAAO/B,CAAM,CAAC,CACtD,MACEma,EAAW,IAAI/V,EAAMrC,CAAI,CAE7B,CACA,OAAO,IAAIunB,EAAWnP,EAAY,CAAC,GAAG,KAAK,YAAY,CAAC,CAC1D,CACA,qBAAqB6N,EAAW,CAC9B,MAAM7N,EAA6B,IAAI,IACvC,UAAW/V,KAAQ,KAAK,aAAc,CACpC,MAAMrC,EAAO,KAAK,SAAS,IAAIqC,CAAI,EACnC,GAAIrC,EAAK,YAAc,EAAG,CACxBoY,EAAW,IAAI/V,EAAMrC,CAAI,EACzB,QACF,CACA,MAAM/B,EAAS,CAAA,EACf,QAAS,EAAI,EAAG,EAAI+B,EAAK,OAAQ,IAC/B/B,EAAO,KAAK+B,EAAK,IAAI,CAAC,CAAC,EAEzB,GAAIimB,IAAc,UAChB,QAAS,EAAI,EAAG,EAAIhoB,EAAO,OAAQ,IAC7BA,EAAO,CAAC,IAAM,MAAQA,EAAO,EAAI,CAAC,IAAM,OAC1CA,EAAO,CAAC,EAAIA,EAAO,EAAI,CAAC,OAI5B,SAAS,EAAIA,EAAO,OAAS,EAAG,GAAK,EAAG,IAClCA,EAAO,CAAC,IAAM,MAAQA,EAAO,EAAI,CAAC,IAAM,OAC1CA,EAAO,CAAC,EAAIA,EAAO,EAAI,CAAC,GAI9Bma,EAAW,IAAI/V,EAAM8lB,GAAYnoB,EAAK,MAAO/B,CAAM,CAAC,CACtD,CACA,OAAO,IAAIspB,EAAWnP,EAAY,CAAC,GAAG,KAAK,YAAY,CAAC,CAC1D,CACA,KAAK2I,EAAQ,CACX,UAAWvX,KAAW,OAAO,KAAKuX,CAAM,EACtC,GAAI,CAAC,KAAK,SAAS,IAAIvX,CAAO,EAC5B,MAAM,IAAIxN,EAAoBwN,EAAS,KAAK,YAAY,EAG5D,MAAM4O,EAA6B,IAAI,IACvC,UAAW/V,KAAQ,KAAK,aAAc,CACpC,MAAM0B,EAAcgd,EAAO1e,CAAI,EAC/B,GAAI0B,EAAa,CAEf,MAAMynB,EADS,IAAItrB,EAAOmC,EAAM,KAAK,SAAS,IAAIA,CAAI,CAAC,EACjC,KAAK0B,CAAW,EACtCqU,EAAW,IAAI/V,EAAMmpB,EAAO,MAAM,CACpC,MACEpT,EAAW,IAAI/V,EAAM,KAAK,SAAS,IAAIA,CAAI,CAAC,CAEhD,CACA,OAAO,IAAIklB,EAAWnP,EAAY,CAAC,GAAG,KAAK,YAAY,CAAC,CAC1D,CACA,SAASjQ,EAAS,CAChB,MAAMsjB,EAAUtjB,GAAS,SAAW,GAC9BujB,EAAUvjB,GAAS,SAAW,GAC9B,CAACuE,EAAOif,CAAK,EAAI,KAAK,MAC5B,GAAIA,IAAU,GAAKjf,IAAU,EAC3B,MAAO;AAAA,WACFif,CAAK,WAEZ,MAAMC,EAAU,KAAK,aACrB,IAAIC,EACJ,GAAID,EAAQ,OAASF,EAAS,CAC5B,MAAMI,EAAO,KAAK,MAAMJ,EAAU,CAAC,EACnCG,EAAc,CAAC,GAAGD,EAAQ,MAAM,EAAGE,CAAI,EAAG,MAAO,GAAGF,EAAQ,MAAMA,EAAQ,OAASE,CAAI,CAAC,CAC1F,MACED,EAAc,CAAC,GAAGD,CAAO,EAE3B,IAAIG,EACJ,GAAIrf,EAAQ+e,EAAS,CACnB,MAAMK,EAAO,KAAK,MAAML,EAAU,CAAC,EACnCM,EAAa,CACX,GAAG,MAAM,KAAK,CAAE,OAAQD,CAAI,EAAI,CAACle,EAAG5Q,IAAMA,CAAC,EAC3C,GAEA,GAAG,MAAM,KAAK,CAAE,OAAQ8uB,CAAI,EAAI,CAACle,EAAG5Q,IAAM0P,EAAQof,EAAO9uB,CAAC,CAClE,CACI,MACE+uB,EAAa,MAAM,KAAK,CAAE,OAAQrf,CAAK,EAAI,CAACkB,EAAG5Q,IAAMA,CAAC,EAExD,MAAMgvB,EAAe7tB,GACfA,IAAM,KAAa,OACnBA,aAAa,KAAaA,EAAE,YAAW,EACvC,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAC1D,OAAOA,CAAC,EAEV,KAAK,UAAUA,CAAC,EAEnB8tB,EAAY,CAAC,GAAI,GAAGJ,CAAW,EAC/BK,EAAW,CAAA,EACjB,UAAWruB,KAAOkuB,EAAY,CAC5B,GAAIluB,IAAQ,GAAI,CACdquB,EAAS,KAAKD,EAAU,IAAI,IAAM,KAAK,CAAC,EACxC,QACF,CACA,MAAME,EAAQ,CAAC,OAAOtuB,CAAG,CAAC,EAC1B,UAAW2L,KAAWqiB,EAChBriB,IAAY,MACd2iB,EAAM,KAAK,KAAK,EAEhBA,EAAM,KAAKH,EAAY,KAAK,SAAS,IAAIxiB,CAAO,EAAE,IAAI3L,CAAG,CAAC,CAAC,EAG/DquB,EAAS,KAAKC,CAAK,CACrB,CACA,MAAMC,EAAYH,EAAU,IAAI,CAACjjB,EAAGqjB,IAAO,CACzC,IAAIC,EAAOtjB,EAAE,OACb,UAAWM,KAAO4iB,EAChBI,EAAO,KAAK,IAAIA,EAAMhjB,EAAI+iB,CAAE,EAAE,MAAM,EAEtC,OAAOC,CACT,CAAC,EACK3J,EAAM,CAAC9jB,EAAG0tB,EAAGF,IACbA,IAAO,EAAUxtB,EAAE,SAAS0tB,CAAC,EAC1B1tB,EAAE,OAAO0tB,CAAC,EAEbC,EAAM,IACNpkB,EAAQ,CAAA,EACRqkB,EAAa,KAAYR,EAAU,IAAI,CAACjjB,EAAGqjB,IAAO1J,EAAI3Z,EAAGojB,EAAUC,CAAE,EAAGA,CAAE,CAAC,EAAE,KAAK,KAAU,EAAI,KAChGK,EAAY,KAAiBN,EAAU,IAAKG,GAAMC,EAAI,OAAOD,CAAC,CAAC,EAAE,KAAK,KAAoB,EAAI,KAC9FI,EAAY,KAAiBP,EAAU,IAAKG,GAAMC,EAAI,OAAOD,CAAC,CAAC,EAAE,KAAK,KAAoB,EAAI,KAC9FK,EAAe,KAAiBR,EAAU,IAAKG,GAAMC,EAAI,OAAOD,CAAC,CAAC,EAAE,KAAK,KAAoB,EAAI,KACvGnkB,EAAM,KAAKskB,CAAS,EACpBtkB,EAAM,KAAKqkB,CAAU,EACrBrkB,EAAM,KAAKukB,CAAS,EACpB,UAAWrjB,KAAO4iB,EAChB9jB,EAAM,KAAK,KAAYkB,EAAI,IAAI,CAAC8G,EAAMic,IAAO1J,EAAIvS,EAAMgc,EAAUC,CAAE,EAAGA,CAAE,CAAC,EAAE,KAAK,KAAU,EAAI,IAAS,EAEzG,OAAAjkB,EAAM,KAAKwkB,CAAY,EACvBxkB,EAAM,KAAK,GAAGsE,CAAK,WAAWif,CAAK,UAAU,EACtCvjB,EAAM,KAAK;AAAA,CAAI,CACxB,CACA,MAAMD,EAAS,CACb,QAAQ,IAAI,KAAK,SAASA,CAAO,CAAC,CACpC,CACA,UAAW,CAET,MAAMwO,EAAgB,CAAE,KADN,CAAC,QAAS,OAAQ,MAAO,MAAO,KAAK,CAChB,EACvC,UAAWtU,KAAQ,KAAK,aAAc,CACpC,MAAMwqB,EAAS,KAAK,SAAS,IAAIxqB,CAAI,EAC/BoB,EAAQopB,EAAO,MACrB,GAAIppB,IAAU,OAAuBA,IAAU,MAAmB,CAChE,MAAM/D,EAAS,IAAIQ,EAAOmC,EAAMwqB,CAAM,EAChC1xB,EAAQuE,EAAO,OAASA,EAAO,UAC/B6H,EAAO7H,EAAO,KAAI,EAClBotB,EAAMptB,EAAO,IAAG,EAChBqtB,EAAMrtB,EAAO,IAAG,EAChBstB,EAAMttB,EAAO,IAAG,EACtBiX,EAActU,CAAI,EAAI,CAAClH,EAAOoM,EAAMulB,EAAKC,EAAKC,CAAG,CACnD,CACF,CACA,OAAOzF,EAAW,YAAY5Q,CAAa,CAC7C,CACA,aAAc,CACZ,IAAI7Y,EAAQ,EACZ,UAAWuE,KAAQ,KAAK,aACtBvE,GAAS,KAAK,SAAS,IAAIuE,CAAI,EAAE,qBAAoB,EAEvD,OAAOvE,CACT,CACA,MAAO,CACL,KAAM,CAAC4O,EAAOif,CAAK,EAAI,KAAK,MACtBvjB,EAAQ,CAAA,EACdA,EAAM,KAAK,cAAcsE,CAAK,WAAWif,CAAK,UAAU,EACxDvjB,EAAM,KAAK,EAAE,EACb,MAAM6kB,EAAe,KAAK,IAAI,EAAG,GAAG,KAAK,aAAa,IAAKxrB,GAAMA,EAAE,MAAM,CAAC,EACpEqH,EAAS,GAAG,SAAS,OAAOmkB,CAAY,CAAC,KAAK,QAAQ,OAAO,EAAE,CAAC,KAAK,aAAa,OAAO,EAAE,CAAC,WAClG7kB,EAAM,KAAKU,CAAM,EACjBV,EAAM,KAAK,IAAS,OAAOU,EAAO,MAAM,CAAC,EACzC,IAAIokB,EAAc,EAClB,UAAW7qB,KAAQ,KAAK,aAAc,CACpC,MAAMwqB,EAAS,KAAK,SAAS,IAAIxqB,CAAI,EAC/BoB,EAAQopB,EAAO,MACfM,EAAYN,EAAO,UACnBO,EAAMP,EAAO,qBAAoB,EACvCK,GAAeE,EACfhlB,EAAM,KACJ,GAAG/F,EAAK,OAAO4qB,CAAY,CAAC,KAAKxpB,EAAM,OAAO,EAAE,CAAC,KAAK,OAAO0pB,CAAS,EAAE,OAAO,EAAE,CAAC,KAAKE,GAAYD,CAAG,CAAC,EAC/G,CACI,CACAhlB,EAAM,KAAK,IAAS,OAAOU,EAAO,MAAM,CAAC,EACzCV,EAAM,KAAK,iBAAiBilB,GAAYH,CAAW,CAAC,EAAE,EACtD,QAAQ,IAAI9kB,EAAM,KAAK;AAAA,CAAI,CAAC,CAC9B,CACA,OAAO,YAAY7K,EAAM,CACvB,MAAM0Y,EAAO,OAAO,KAAK1Y,CAAI,EAC7B,GAAI0Y,EAAK,SAAW,EAClB,OAAOsR,EAAW,MAAK,EAEzB,MAAM+F,EAAWrX,EAAK,CAAC,EACjBzJ,EAAWjP,EAAK+vB,CAAQ,EAAE,OAChC,UAAWrqB,KAAOgT,EAChB,GAAI1Y,EAAK0F,CAAG,EAAE,SAAWuJ,EACvB,MAAM,IAAIpQ,GACR,WAAW6G,CAAG,gBAAgB1F,EAAK0F,CAAG,EAAE,MAAM,cAAcuJ,CAAQ,EAC9E,EAGI,MAAMhJ,EAA0B,IAAI,IACpC,UAAWP,KAAOgT,EAAM,CACtB,MAAMhY,EAASV,EAAK0F,CAAG,EACjBQ,EAAQwkB,GAAahqB,CAAM,EAC3B+B,EAAOmoB,GAAY1kB,EAAOxF,CAAM,EACtCuF,EAAQ,IAAIP,EAAKjD,CAAI,CACvB,CACA,OAAO,IAAIunB,EAAW/jB,EAASyS,CAAI,CACrC,CACA,OAAO,SAAS9K,EAAM,CACpB,GAAIA,EAAK,SAAW,EAClB,OAAOoc,EAAW,MAAK,EAEzB,MAAM3G,EAA4B,IAAI,IACtC,UAAWtX,KAAO6B,EAChB,UAAWlI,KAAO,OAAO,KAAKqG,CAAG,EAC/BsX,EAAU,IAAI3d,CAAG,EAGrB,MAAMkkB,EAAc,CAAC,GAAGvG,CAAS,EAC3BrjB,EAAO,CAAA,EACb,UAAW8E,KAAQ8kB,EACjB5pB,EAAK8E,CAAI,EAAI,CAAA,EAEf,UAAWiH,KAAO6B,EAAM,CACtB,MAAMtH,EAAIyF,EACV,UAAWjH,KAAQ8kB,EAAa,CAC9B,MAAMpqB,EAAQsF,KAAQwB,EAAIA,EAAExB,CAAI,EAAI,KACpC9E,EAAK8E,CAAI,EAAE,KAAKtF,IAAU,OAAS,KAAOA,CAAK,CACjD,CACF,CACA,OAAOwqB,EAAW,YAAYhqB,CAAI,CACpC,CACA,OAAO,OAAQ,CACb,OAAO,IAAIgqB,EAA2B,IAAI,IAAO,CAAA,CAAE,CACrD,CACA,OAAO,MAAMllB,EAAM7E,EAAOC,EAAK8vB,EAAO,EAAG,CACvC,GAAIA,IAAS,EACX,MAAM,IAAI1xB,EAAc,oBAA6C,uBAAuB,EAE9F,GAAI2B,GAASC,EACX,MAAM,IAAI5B,EACR,oBACA,UAAU2B,CAAK,4BAA4BC,CAAG,GACtD,EAEI,MAAMhB,EAAS,KAAK,MAAMgB,EAAMD,GAAS+vB,CAAI,EACvChwB,EAAO,IAAI,aAAad,CAAM,EACpC,QAASO,EAAI,EAAGA,EAAIP,EAAQO,IAC1BO,EAAKP,CAAC,EAAIQ,EAAQR,EAAIuwB,EAExB,MAAM5vB,EAAO,IAAIpB,EAASE,EAAQ,EAAI,EAChCuD,EAAO,IAAI3C,EAAcE,EAAMI,CAAI,EACnC6F,EAA0B,IAAI,IACpC,OAAAA,EAAQ,IAAInB,EAAMrC,CAAI,EACf,IAAIunB,EAAW/jB,EAAS,CAACnB,CAAI,CAAC,CACvC,CACA,OAAO,SAASA,EAAM7E,EAAOC,EAAKtC,EAAO,CACvC,GAAIA,EAAQ,EACV,MAAM,IAAIU,EAAc,oBAA6C,0BAA0B,EAEjG,MAAM0B,EAAO,IAAI,aAAapC,CAAK,EAC7BoyB,GAAQ9vB,EAAMD,IAAUrC,EAAQ,GACtC,QAAS6B,EAAI,EAAGA,EAAI7B,EAAO6B,IACzBO,EAAKP,CAAC,EAAIQ,EAAQR,EAAIuwB,EAExB,MAAM5vB,EAAO,IAAIpB,EAASpB,EAAO,EAAI,EAC/B6E,EAAO,IAAI3C,EAAcE,EAAMI,CAAI,EACnC6F,EAA0B,IAAI,IACpC,OAAAA,EAAQ,IAAInB,EAAMrC,CAAI,EACf,IAAIunB,EAAW/jB,EAAS,CAACnB,CAAI,CAAC,CACvC,CACA,aAAa,QAAQmR,EAAOrL,EAAU,GAAI,CACxC,IAAID,EACJ,GAAI,OAAOsL,GAAU,SACnB,GAAI,CACF,MAAMga,EAAS,CAAA,EACf,gBAAiBlf,KAASkF,EACxBga,EAAO,KAAK,OAAO,SAASlf,CAAK,EAAIA,EAAQ,OAAO,KAAKA,CAAK,CAAC,EAEjEpG,EAAU,OAAO,OAAOslB,CAAM,EAAE,SAASrlB,EAAQ,UAAY,OAAO,CACtE,OAAS6D,EAAK,CACZ,GAAIA,aAAe1P,EAAS,MAAM0P,EAClC,MAAMjQ,EAAUiQ,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAI1P,EAAQ,mCAAmCP,CAAO,EAAE,CAChE,SACSoM,EAAQ,QAAU,SAC3BD,EAAUsL,UACDA,EAAM,WAAW,SAAS,GAAKA,EAAM,WAAW,UAAU,EACnE,GAAI,CACF,MAAMia,EAAW,MAAM,MAAMja,CAAK,EAClC,GAAI,CAACia,EAAS,GACZ,MAAM,IAAInxB,EACR,6BAA6BkX,CAAK,WAAW,OAAOia,EAAS,MAAM,CAAC,IAAIA,EAAS,UAAU,EACvG,EAEQvlB,EAAU,MAAMulB,EAAS,KAAI,CAC/B,OAASzhB,EAAK,CACZ,GAAIA,aAAe1P,EAAS,MAAM0P,EAClC,MAAMjQ,EAAUiQ,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAI1P,EAAQ,6BAA6BkX,CAAK,MAAMzX,CAAO,EAAE,CACrE,KAEA,IAAI,CAEFmM,EAAU,MADC,KAAM,QAAO,uCAAa,GAClB,SAASsL,EAAOrL,EAAQ,UAAY,OAAO,CAChE,OAAS6D,EAAK,CACZ,GAAIA,aAAe1P,EAAS,MAAM0P,EAClC,MAAMjQ,EAAUiQ,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAI1P,EAAQ,4BAA4BkX,CAAK,MAAMzX,CAAO,EAAE,CACpE,CAEF,MAAM2xB,EAASzlB,GAASC,EAASC,CAAO,EACxC,OAAOwlB,GAAyBD,EAAO,OAAQA,EAAO,QAASA,EAAO,aAAa,CACrF,CACA,aAAc,UAAUE,EAAMzlB,EAAU,GAAI,CAC1C,gBAAiBmG,KAAS5C,GAAckiB,EAAMzlB,CAAO,EACnD,MAAMwlB,GAAyBrf,EAAM,OAAQA,EAAM,WAAYA,EAAM,aAAa,CAEtF,CACA,OAAO,QAAQsf,EAAMzlB,EAAU,GAAI,CACjC,MAAM0lB,EAActG,EAAW,MAAK,EAC9BuG,EAAOlJ,GAAgBiJ,CAAW,EAChB,OAAAC,EAAK,QAAQ,KAAKA,CAAI,EAE9CA,EAAK,QAAU,SAAY,CACzB,MAAMN,EAAS,CAAA,EACf,gBAAiBlf,KAASiZ,EAAW,UAAUqG,EAAMzlB,CAAO,EAC1DqlB,EAAO,KAAKlf,CAAK,EAEnB,OAAIkf,EAAO,SAAW,EAAUjG,EAAW,MAAK,EAC5CiG,EAAO,SAAW,EAAUA,EAAO,CAAC,EACjChN,GAAO,GAAGgN,CAAM,CACzB,EACOM,CACT,CACA,aAAc,aAAaF,EAAMzlB,EAAU,GAAI,CAC7C,gBAAiBmG,KAASD,GAAiBuf,EAAMzlB,CAAO,EACtD,MAAMof,EAAW,SAASjZ,CAAK,CAEnC,CACA,OAAO,WAAWsf,EAAMzlB,EAAU,GAAI,CACpC,MAAM0lB,EAActG,EAAW,MAAK,EAC9BuG,EAAOlJ,GAAgBiJ,CAAW,EAChB,OAAAC,EAAK,QAAQ,KAAKA,CAAI,EAE9CA,EAAK,QAAU,SAAY,CACzB,MAAMN,EAAS,CAAA,EACf,gBAAiBlf,KAASiZ,EAAW,aAAaqG,EAAMzlB,CAAO,EAC7DqlB,EAAO,KAAKlf,CAAK,EAEnB,OAAIkf,EAAO,SAAW,EAAUjG,EAAW,MAAK,EAC5CiG,EAAO,SAAW,EAAUA,EAAO,CAAC,EACjChN,GAAO,GAAGgN,CAAM,CACzB,EACOM,CACT,CACA,MAAMC,EAAmBC,EAAc,CACrC,IAAIriB,EACAsiB,EACA9lB,EACA,OAAO4lB,GAAsB,UAC/BpiB,EAAWoiB,EACX5lB,EAAU6lB,GAAgB,CAAA,GACjBD,GAAqB,MAAQ,OAAOA,GAAsB,UAAY,UAAWA,GAAqB,OAAOA,EAAkB,OAAU,YAClJE,EAAWF,EACX5lB,EAAU6lB,GAAgB,CAAA,GAE1B7lB,EAAU4lB,GAAqB,CAAA,EAEjC,KAAM,CAAE,OAAAjlB,EAAQ,KAAAqC,GAAS,KAAK,aAAY,EACpC+iB,EAAYhjB,GAASpC,EAAQqC,EAAMhD,CAAO,EAChD,GAAI8lB,EAAU,CACZ,MAAMliB,EAASkiB,EACf,OAAO,IAAI,QAAQ,CAACtY,EAASC,IAAW,CACtC,IAAIuY,EAAU,GACd,MAAMC,EAAQpiB,GAAQ,CAChBmiB,IACJA,EAAU,GACVvY,EAAO,IAAItZ,EAAQ,kCAAkC0P,EAAI,OAAO,EAAE,CAAC,EACrE,EACAD,EAAO,KAAK,QAASqiB,CAAI,EACzBriB,EAAO,MAAMmiB,EAAW,QAAUliB,GAAQ,CACxC,GAAIA,EACFoiB,EAAKpiB,CAAG,MACH,CACL,GAAImiB,EAAS,OACbA,EAAU,GACVpiB,EAAO,eAAe,QAASqiB,CAAI,EACnCzY,EAAO,CACT,CACF,CAAC,CACH,CAAC,CACH,CACA,OAAIhK,EACK,OAAO,uCAAa,EAAE,KAC1BE,GAAOA,EAAG,UAAUF,EAAUuiB,EAAW,OAAO,EAAE,MAAOliB,GAAQ,CAChE,MAAMjQ,EAAUiQ,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAI1P,EAAQ,6BAA6BqP,CAAQ,MAAM5P,CAAO,EAAE,CACxE,CAAC,CACT,EAEWmyB,CACT,CACA,aAAa,SAAS1a,EAAOrL,EAAU,GAAI,CACzC,IAAID,EACJ,GAAIC,EAAQ,QAAU,SACpBD,EAAUsL,MAEV,IAAI,CAEFtL,EAAU,MADC,KAAM,QAAO,uCAAa,GAClB,SAASsL,EAAO,OAAO,CAC5C,OAASxH,EAAK,CACZ,GAAIA,aAAe1P,EAAS,MAAM0P,EAClC,MAAMjQ,EAAUiQ,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAI1P,EAAQ,6BAA6BkX,CAAK,MAAMzX,CAAO,EAAE,CACrE,CAEF,IAAI2xB,EAAS,KAAK,MAAMxlB,CAAO,EAC/B,GAAIC,EAAQ,KAAM,CAChB,MAAMiH,EAAQjH,EAAQ,KAAK,MAAM,GAAG,EACpC,UAAWkmB,KAAQjf,EACjB,GAAIse,IAAW,MAAQ,OAAOA,GAAW,UAAY,CAAC,MAAM,QAAQA,CAAM,EACxEA,EAASA,EAAOW,CAAI,MAEpB,OAAM,IAAI/xB,EAAQ,cAAc6L,EAAQ,IAAI,iBAAiBkmB,CAAI,oBAAoB,CAG3F,CACA,GAAI,CAAC,MAAM,QAAQX,CAAM,EACvB,MAAM,IAAIpxB,EAAQ,0CAA0C,EAE9D,OAAOirB,EAAW,SAASmG,CAAM,CACnC,CACA,OAAOK,EAAmBC,EAAc,CACtC,IAAIriB,EACAxD,EACA,OAAO4lB,GAAsB,UAC/BpiB,EAAWoiB,EACX5lB,EAAU6lB,GAAgB,CAAA,GAE1B7lB,EAAU4lB,GAAqB,CAAA,EAEjC,KAAM,CAAE,OAAAjlB,EAAQ,KAAAqC,GAAS,KAAK,aAAY,EACpCmjB,EAAa9f,GAAU1F,EAAQqC,EAAMhD,CAAO,EAClD,OAAIwD,EACK,OAAO,uCAAa,EAAE,KAC1BE,GAAOA,EAAG,UAAUF,EAAU2iB,EAAY,OAAO,EAAE,MAAOtiB,GAAQ,CACjE,MAAMjQ,EAAUiQ,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAI1P,EAAQ,8BAA8BqP,CAAQ,MAAM5P,CAAO,EAAE,CACzE,CAAC,CACT,EAEWuyB,CACT,CACA,aAAa,WAAW9a,EAAOrL,EAAU,GAAI,CAC3C,IAAID,EACJ,GAAIC,EAAQ,QAAU,SACpBD,EAAUsL,MAEV,IAAI,CAEFtL,EAAU,MADC,KAAM,QAAO,uCAAa,GAClB,SAASsL,EAAO,OAAO,CAC5C,OAASxH,EAAK,CACZ,GAAIA,aAAe1P,EAAS,MAAM0P,EAClC,MAAMjQ,EAAUiQ,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAI1P,EAAQ,+BAA+BkX,CAAK,MAAMzX,CAAO,EAAE,CACvE,CAGF,MAAMoP,EADQjD,EAAQ,MAAM;AAAA,CAAI,EAAE,OAAQS,GAASA,EAAK,KAAI,IAAO,EAAE,EAClD,IAAKA,GAAS,KAAK,MAAMA,CAAI,CAAC,EACjD,OAAO4e,EAAW,SAASpc,CAAI,CACjC,CACA,aAAa,UAAUQ,EAAUxD,EAAU,GAAI,CAC7C,MAAMulB,EAAS,MAAMhd,GAAc/E,EAAUxD,CAAO,EACpD,GAAIulB,EAAO,OAAO,SAAW,EAC3B,OAAOnG,EAAW,MAAK,EAEzB,MAAM/jB,EAA0B,IAAI,IACpC,UAAWnB,KAAQqrB,EAAO,OAAQ,CAChC,MAAMjqB,EAAQiqB,EAAO,cAAcrrB,CAAI,GAAK,MACtCpE,EAASyvB,EAAO,QAAQrrB,CAAI,EAClCmB,EAAQ,IAAInB,EAAM8lB,GAAY1kB,EAAOxF,CAAM,CAAC,CAC9C,CACA,OAAO,IAAIspB,EAAW/jB,EAAS,CAAC,GAAGkqB,EAAO,MAAM,CAAC,CACnD,CACA,aAAa,YAAY/hB,EAAUxD,EAAU,GAAI,CAC/C,MAAMulB,EAAS,MAAM3c,GAAgBpF,EAAUxD,CAAO,EACtD,GAAIulB,EAAO,OAAO,SAAW,EAC3B,OAAOnG,EAAW,MAAK,EAEzB,MAAM/jB,EAA0B,IAAI,IACpC,UAAWnB,KAAQqrB,EAAO,OAAQ,CAChC,MAAMjqB,EAAQiqB,EAAO,cAAcrrB,CAAI,GAAK,MACtCpE,EAASyvB,EAAO,QAAQrrB,CAAI,EAClCmB,EAAQ,IAAInB,EAAM8lB,GAAY1kB,EAAOxF,CAAM,CAAC,CAC9C,CACA,OAAO,IAAIspB,EAAW/jB,EAAS,CAAC,GAAGkqB,EAAO,MAAM,CAAC,CACnD,CACA,MAAM,QAAQ/hB,EAAUxD,EAAU,GAAI,CACpC,KAAM,CAAE,OAAAW,EAAQ,KAAAqC,GAAS,KAAK,aAAY,EAC1C,MAAMyG,GAAejG,EAAU7C,EAAQqC,EAAMhD,CAAO,CACtD,CACA,MAAM,UAAUwD,EAAUxD,EAAU,GAAI,CACtC,MAAMW,EAAS,KAAK,aACdtF,EAAU,CAAA,EAChB,UAAWnB,KAAQyG,EAAQ,CACzB,MAAM9I,EAAO,KAAK,SAAS,IAAIqC,CAAI,EAC7BpE,EAAS,CAAA,EACf,QAASjB,EAAI,EAAGA,EAAIgD,EAAK,OAAQhD,IAC/BiB,EAAO,KAAK+B,EAAK,IAAIhD,CAAC,CAAC,EAEzBwG,EAAQnB,CAAI,EAAI,CAAE,OAAApE,EAAQ,MAAO+B,EAAK,KAAK,CAC7C,CACA,MAAM2S,GAAiBhH,EAAU7C,EAAQtF,EAAS2E,CAAO,CAC3D,CAEA,MAAM,SAAU,CACd,OAAOoL,GAAa,CAClB,YAAa,KAAK,aAClB,gBAAkBlR,GAAS,CACzB,MAAMrC,EAAO,KAAK,SAAS,IAAIqC,CAAI,EAC7BpE,EAAS,CAAA,EACf,QAASjB,EAAI,EAAGA,EAAIgD,EAAK,OAAQhD,IAC/BiB,EAAO,KAAK+B,EAAK,IAAIhD,CAAC,CAAC,EAEzB,MAAO,CAAE,OAAAiB,EAAQ,MAAO+B,EAAK,KAAK,CACpC,CACN,CAAK,CACH,CAEA,OAAO,UAAUgU,EAAO,CACtB,MAAM0Z,EAAS3Z,GAAeC,CAAK,EACnC,GAAI0Z,EAAO,OAAO,SAAW,EAC3B,OAAOnG,EAAW,MAAK,EAEzB,MAAM/jB,EAA0B,IAAI,IACpC,UAAWnB,KAAQqrB,EAAO,OAAQ,CAChC,MAAMjqB,EAAQiqB,EAAO,cAAcrrB,CAAI,GAAK,MACtCpE,EAASyvB,EAAO,QAAQrrB,CAAI,EAClCmB,EAAQ,IAAInB,EAAM8lB,GAAY1kB,EAAOxF,CAAM,CAAC,CAC9C,CACA,OAAO,IAAIspB,EAAW/jB,EAAS,CAAC,GAAGkqB,EAAO,MAAM,CAAC,CACnD,CACA,MAAM,YAAa,CACjB,IAAIpb,EACJ,GAAI,CAEFA,EAAQ,MAAM,OADK,eAErB,MAAQ,CACN,MAAM,IAAIhW,EACR,0GACR,CACI,CACA,MAAM0X,EAAQ,MAAM,KAAK,QAAO,EAChC,OAAO1B,EAAM,WAAW0B,EAAO,QAAQ,CACzC,CACA,aAAa,aAAa7H,EAAQ,CAChC,IAAImG,EACJ,GAAI,CAEFA,EAAQ,MAAM,OADK,eAErB,MAAQ,CACN,MAAM,IAAIhW,EACR,4GACR,CACI,CACA,MAAM0X,EAAQ1B,EAAM,aAAanG,CAAM,EACvC,OAAOob,EAAW,UAAUvT,CAAK,CACnC,CACA,SAASrI,EAAU,CACjB,KAAM,CAAE,OAAA7C,EAAQ,KAAAqC,GAAS,KAAK,aAAY,EACpCojB,EAAe5f,GAAY7F,EAAQqC,CAAI,EAC7C,OAAIQ,EACK,OAAO,uCAAa,EAAE,KAC1BE,GAAOA,EAAG,UAAUF,EAAU4iB,EAAc,OAAO,EAAE,MAAOviB,GAAQ,CACnE,MAAMjQ,EAAUiQ,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAI1P,EAAQ,gCAAgCqP,CAAQ,MAAM5P,CAAO,EAAE,CAC3E,CAAC,CACT,EAEWwyB,CACT,CACA,MAAMtM,EAAW9Z,EAAS,CACxB,KAAM,CAAE,OAAAW,EAAQ,KAAAqC,GAAS,KAAK,aAAY,EAC1C,OAAO6W,GAASC,EAAWnZ,EAAQqC,EAAMhD,CAAO,CAClD,CACA,cAAe,CACb,MAAMW,EAAS,KAAK,aACdqC,EAAO,CAAA,EACb,QAASnO,EAAI,EAAGA,EAAI,KAAK,OAAQA,IAAK,CACpC,MAAMsM,EAAM,CAAA,EACZ,UAAWjH,KAAQ,KAAK,aACtBiH,EAAI,KAAK,KAAK,SAAS,IAAIjH,CAAI,EAAE,IAAIrF,CAAC,CAAC,EAEzCmO,EAAK,KAAK7B,CAAG,CACf,CACA,MAAO,CAAE,OAAAR,EAAQ,KAAAqC,CAAI,CACvB,CACA,MAAMlO,EAAO,CACX,OAAOykB,GAAM,KAAMzkB,CAAK,CAC1B,CACA,aAAaA,EAAO,CAClB,OAAO2kB,GAAa,KAAM3kB,CAAK,CACjC,CACA,WAAWA,EAAO,CAChB,OAAO4kB,GAAW,KAAM5kB,CAAK,CAC/B,CACA,MAAM8pB,EAAU,CACd,OAAOD,GAAa,KAAMC,CAAQ,CACpC,CACA,OAAO,eAAeyH,EAAWC,EAAU,CACzC,MAAM9J,EAAM6J,EAAU,WAAW,GAAG,EAAIA,EAAU,MAAM,CAAC,EAAIA,EAC7DjH,EAAW,SAAS,IAAI5C,EAAI,YAAW,EAAI8J,CAAQ,CACrD,CACA,OAAO,eAAeD,EAAWE,EAAU,CACzC,MAAM/J,EAAM6J,EAAU,WAAW,GAAG,EAAIA,EAAU,MAAM,CAAC,EAAIA,EAC7DjH,EAAW,SAAS,IAAI5C,EAAI,YAAW,EAAI+J,CAAQ,CACrD,CACA,aAAa,SAAS/iB,EAAUxD,EAAS,CACvC,MAAMwc,EAAMhZ,EAAS,MAAM,GAAG,EAAE,IAAG,GAAI,YAAW,EAClD,GAAI,CAACgZ,EACH,MAAM,IAAIroB,EAAQ,+CAA+CqP,CAAQ,GAAG,EAE9E,MAAMgjB,EAASpH,EAAW,SAAS,IAAI5C,CAAG,EAC1C,GAAI,CAACgK,EACH,MAAM,IAAIryB,EACR,wCAAwCqoB,CAAG,oCAAoCA,CAAG,+BAC1F,EAEI,MAAM9Y,EAAK,KAAM,QAAO,uCAAa,EACrC,IAAIxL,EACJ,GAAI,CACFA,EAAS,MAAMwL,EAAG,SAASF,CAAQ,CACrC,OAASK,EAAK,CACZ,MAAMjQ,EAAUiQ,aAAe,MAAQA,EAAI,QAAU,OAAOA,CAAG,EAC/D,MAAM,IAAI1P,EAAQ,wBAAwBqP,CAAQ,MAAM5P,CAAO,EAAE,CACnE,CACA,OAAO4yB,EAAOtuB,EAAQ8H,CAAO,CAC/B,CAEA,MAAM,OAAOwD,EAAUxD,EAAS,CAC9B,MAAMwc,EAAMhZ,EAAS,MAAM,GAAG,EAAE,IAAG,GAAI,YAAW,EAClD,GAAI,CAACgZ,EACH,MAAM,IAAIroB,EAAQ,+CAA+CqP,CAAQ,GAAG,EAE9E,MAAMijB,EAASrH,EAAW,SAAS,IAAI5C,CAAG,EAC1C,GAAI,CAACiK,EACH,MAAM,IAAItyB,EACR,wCAAwCqoB,CAAG,oCAAoCA,CAAG,+BAC1F,EAEI,MAAMiK,EAAO,KAAMjjB,EAAUxD,CAAO,CACtC,CACF,EACA,SAAS+iB,GAAa2D,EAAM,CAC1B,IAAIhwB,EAAIgwB,EAAO,EACf,MAAO,IAAM,CACXhwB,EAAIA,EAAI,WAAa,EACrB,IAAIiwB,EAAI,KAAK,KAAKjwB,EAAIA,IAAM,GAAI,EAAIA,CAAC,EACrC,OAAAiwB,EAAIA,EAAI,KAAK,KAAKA,EAAIA,IAAM,EAAG,GAAKA,CAAC,EAAIA,IAChCA,EAAIA,IAAM,MAAQ,GAAK,UAClC,CACF,CACA,SAASnB,GAAyB7kB,EAAQimB,EAAYrlB,EAAe,CACnE,GAAIZ,EAAO,SAAW,EACpB,OAAOwe,GAAU,MAAK,EAExB,MAAM9jB,EAA0B,IAAI,IACpC,UAAWnB,KAAQyG,EAAQ,CACzB,MAAMrF,EAAQiG,EAAcrH,CAAI,GAAK,OAC/B2sB,EAAYD,EAAW1sB,CAAI,EAC3B4sB,EAAcC,GAAoBF,EAAWvrB,CAAK,EACxDD,EAAQ,IAAInB,EAAM8lB,GAAY1kB,EAAOwrB,CAAW,CAAC,CACnD,CACA,OAAO,IAAI3H,GAAU9jB,EAAS,CAAC,GAAGsF,CAAM,CAAC,CAC3C,CACA,SAASomB,GAAoBjxB,EAAQwF,EAAO,CAC1C,OAAQA,EAAK,CACX,IAAK,MACL,IAAK,MACH,OAAOxF,EAAO,IAAKE,GAAMA,IAAM,KAAO,KAAO,OAAOA,CAAC,CAAC,EACxD,IAAK,OACH,OAAOF,EAAO,IAAKE,GACbA,IAAM,KAAa,KAChBA,EAAE,YAAW,IAAO,MAC5B,EACH,IAAK,OACH,OAAOF,EAAO,IAAKE,GAAMA,IAAM,KAAO,KAAO,IAAI,KAAKA,CAAC,CAAC,EAE1D,QACE,OAAOF,CACb,CACA,CACA,SAASgqB,GAAahqB,EAAQ,CAC5B,UAAWE,KAAKF,EACd,GAAIE,GAAM,KACV,IAAI,OAAOA,GAAM,SAAU,MAAO,MAClC,GAAI,OAAOA,GAAM,SAAU,MAAO,OAClC,GAAI,OAAOA,GAAM,UAAW,MAAO,OACnC,GAAIA,aAAa,KAAM,MAAO,OAC9B,GAAI,MAAM,QAAQA,CAAC,GAAK,OAAOA,GAAM,SAAU,MAAO,SAExD,MAAO,KACT,CACA,SAASgqB,GAAY1kB,EAAOxF,EAAQ,CAClC,OAAQwF,EAAK,CACX,IAAK,MACH,OAAOpG,EAAc,KAAKY,CAAM,EAClC,IAAK,MACH,OAAOG,GAAY,KAAKH,CAAM,EAChC,IAAK,OACH,OAAOK,EAAW,KAAKL,CAAM,EAC/B,IAAK,OACH,OAAOkB,EAAc,KAAKlB,CAAM,EAClC,IAAK,OACH,OAAOoB,EAAW,KAAKpB,CAAM,EAC/B,IAAK,SACH,OAAOsB,GAAa,KAAKtB,CAAM,EACjC,QACE,MAAM,IAAIpC,EACR,oBACA,8CAA8C4H,CAAK,EAC3D,CACA,CACA,CACA,SAAS4pB,GAAYzuB,EAAO,CAC1B,OAAIA,EAAQ,KAAa,GAAGA,CAAK,KAC7BA,EAAQ,KAAO,KAAa,IAAIA,EAAQ,MAAM,QAAQ,CAAC,CAAC,MACxDA,EAAQ,KAAO,KAAO,KAAa,IAAIA,GAAS,KAAO,OAAO,QAAQ,CAAC,CAAC,MACrE,IAAIA,GAAS,KAAO,KAAO,OAAO,QAAQ,CAAC,CAAC,KACrD,CACAsD,GAA0B,CAACsB,EAASiQ,IAAgB,IAAI6T,GAAU9jB,EAASiQ,CAAW,CAAC,EAGvF,SAAS0b,GAAiBpyB,EAAO,CAC/B,OAAI,OAAOA,GAAU,SAAiB,MAClC,OAAOA,GAAU,SAAiB,OAClC,OAAOA,GAAU,UAAkB,OACnCA,aAAiB,KAAa,OAC3B,KACT,CACA,SAASqyB,GAAsB3rB,EAAOxF,EAAQ,CAC5C,OAAQwF,EAAK,CACX,IAAK,MACH,OAAOpG,EAAc,KAAKY,CAAM,EAClC,IAAK,OACH,OAAOK,EAAW,KAAKL,CAAM,EAC/B,IAAK,OACH,OAAOkB,EAAc,KAAKlB,CAAM,EAClC,IAAK,OACH,OAAOoB,EAAW,KAAKpB,CAAM,EAC/B,QACE,OAAOZ,EAAc,KAAKY,CAAM,CACtC,CACA,CACA,IAAIoxB,GAAW,cAAcrrB,CAAK,CAChC,SACA,WACA,YAAYsrB,EAASC,EAAW,CAC9B,MAAK,EACL,KAAK,SAAWD,EAChB,KAAK,WAAaC,CACpB,CACA,IAAI,cAAe,CACjB,MAAM7qB,EAAuB,IAAI,IACjC,UAAW8qB,KAAU,KAAK,SAAU,CAClC,UAAWtwB,KAAKswB,EAAO,UAAU,aAAc9qB,EAAK,IAAIxF,CAAC,EACzD,UAAWA,KAAKswB,EAAO,MAAM,aAAc9qB,EAAK,IAAIxF,CAAC,CACvD,CACA,GAAI,KAAK,WACP,UAAWA,KAAK,KAAK,WAAW,aAAcwF,EAAK,IAAIxF,CAAC,EAE1D,MAAO,CAAC,GAAGwF,CAAI,CACjB,CACA,UAAW,CACT,MAAM0K,EAAQ,KAAK,SAAS,IAAK7E,GAAM,QAAQA,EAAE,UAAU,SAAQ,CAAE,SAASA,EAAE,MAAM,SAAQ,CAAE,EAAE,EAClG,OAAI,KAAK,YACP6E,EAAM,KAAK,QAAQ,KAAK,WAAW,SAAQ,CAAE,EAAE,EAE1C,QAAQA,EAAM,KAAK,GAAG,CAAC,MAChC,CACA,SAASlJ,EAAK,CACZ,MAAMzH,EAAMyH,EAAI,OACVupB,EAAmB,KAAK,SAAS,IAAKllB,GAAMA,EAAE,UAAU,SAASrE,CAAG,CAAC,EACrEwpB,EAAe,KAAK,SAAS,IAAKnlB,GAAMA,EAAE,MAAM,SAASrE,CAAG,CAAC,EAC7DypB,EAAkB,KAAK,WAAa,KAAK,WAAW,SAASzpB,CAAG,EAAI,KACpE/F,EAAU,CAAA,EAChB,IAAIyvB,EAAgB,KACpB,QAAS5yB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,IAAI6yB,EAAU,GACd,QAAStf,EAAI,EAAGA,EAAI,KAAK,SAAS,OAAQA,IAExC,GADakf,EAAiBlf,CAAC,EAAE,IAAIvT,CAAC,IACzB,GAAM,CACjB,MAAMgB,EAAM0xB,EAAanf,CAAC,EAAE,IAAIvT,CAAC,EACjCmD,EAAQ,KAAKnC,CAAG,EACZ4xB,IAAkB,MAAQ5xB,IAAQ,OACpC4xB,EAAgBT,GAAiBnxB,CAAG,GAEtC6xB,EAAU,GACV,KACF,CAEF,GAAI,CAACA,EACH,GAAIF,EAAiB,CACnB,MAAM3xB,EAAM2xB,EAAgB,IAAI3yB,CAAC,EACjCmD,EAAQ,KAAKnC,CAAG,EACZ4xB,IAAkB,MAAQ5xB,IAAQ,OACpC4xB,EAAgBT,GAAiBnxB,CAAG,EAExC,MACEmC,EAAQ,KAAK,IAAI,CAGvB,CAEA,MAAMH,EAAOovB,GADCQ,GAAiB,MACWzvB,CAAO,EACjD,OAAO,IAAID,EAAO,GAAIF,CAAI,CAC5B,CACF,EACI8vB,GAAc,KAAM,CACtB,WACA,YAAYC,EAAW,CACrB,KAAK,WAAaA,CACpB,CACA,KAAKhzB,EAAO,CACV,MAAMgJ,EAAOhJ,aAAiBiH,EAAOjH,EAAQ,IAAI0I,EAAY1I,CAAK,EAClE,OAAO,IAAIizB,GAAY,CAAC,CAAE,UAAW,KAAK,WAAY,MAAOjqB,CAAI,CAAE,CAAC,CACtE,CACF,EACIiqB,GAAc,KAAM,CACtB,SACA,YAAYV,EAAS,CACnB,KAAK,SAAWA,CAClB,CACA,KAAKS,EAAW,CACd,OAAO,IAAIE,GAAmB,KAAK,SAAUF,CAAS,CACxD,CACA,UAAUhzB,EAAO,CACf,MAAMgJ,EAAOhJ,aAAiBiH,EAAOjH,EAAQ,IAAI0I,EAAY1I,CAAK,EAClE,OAAO,IAAIsyB,GAAS,KAAK,SAAUtpB,CAAI,CACzC,CACF,EACIkqB,GAAqB,KAAM,CAC7B,SACA,WACA,YAAYX,EAASS,EAAW,CAC9B,KAAK,SAAWT,EAChB,KAAK,WAAaS,CACpB,CACA,KAAKhzB,EAAO,CACV,MAAMgJ,EAAOhJ,aAAiBiH,EAAOjH,EAAQ,IAAI0I,EAAY1I,CAAK,EAClE,OAAO,IAAIizB,GAAY,CAAC,GAAG,KAAK,SAAU,CAAE,UAAW,KAAK,WAAY,MAAOjqB,CAAI,CAAE,CAAC,CACxF,CACF,EACA,SAASmqB,GAAKH,EAAW,CACvB,OAAO,IAAID,GAAYC,CAAS,CAClC,CAGA,IAAII,GAAkB,cAAcnsB,CAAK,CACvC,OACA,IACA,YAAYiD,EAAOV,EAAI,CACrB,MAAK,EACL,KAAK,OAASU,EACd,KAAK,IAAMV,CACb,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,OAAO,YACrB,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,QAAQ,KAAK,GAAG,IAClD,CACA,SAASL,EAAK,CACZ,MAAMxG,EAAS,KAAK,OAAO,SAASwG,CAAG,EACjC/F,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAI0C,EAAO,OAAQ1C,IAAK,CACtC,MAAMgB,EAAM0B,EAAO,IAAI1C,CAAC,EACxB,GAAIgB,IAAQ,KACVmC,EAAQ,KAAK,IAAI,MAEjB,QAAQ,KAAK,IAAG,CACd,IAAK,cACHA,EAAQ,KAAKnC,EAAI,aAAa,EAC9B,MACF,IAAK,cACHmC,EAAQ,KAAKnC,EAAI,aAAa,EAC9B,MACF,IAAK,OACHmC,EAAQ,KAAKnC,EAAI,MAAM,EACvB,KACZ,CAEI,CACA,OAAO,IAAIkC,EAAO,GAAI5B,EAAW,KAAK6B,CAAO,CAAC,CAChD,CACF,EACIiwB,GAAqB,cAAcpsB,CAAK,CAC1C,OACA,SACA,YAAYiD,EAAOpH,EAAS,CAC1B,MAAK,EACL,KAAK,OAASoH,EACd,KAAK,SAAWpH,CAClB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,OAAO,YACrB,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,kBAAkB,KAAK,QAAQ,IACjE,CACA,SAASqG,EAAK,CACZ,MAAMxG,EAAS,KAAK,OAAO,SAASwG,CAAG,EACjC/F,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAI0C,EAAO,OAAQ1C,IAAK,CACtC,MAAMgB,EAAM0B,EAAO,IAAI1C,CAAC,EACxBmD,EAAQ,KAAKnC,IAAQ,KAAO,KAAOA,EAAI,SAAS,KAAK,QAAQ,CAAC,CAChE,CACA,OAAO,IAAIkC,EAAO,GAAIf,EAAc,KAAKgB,CAAO,CAAC,CACnD,CACF,EACIkwB,GAAuB,cAAcrsB,CAAK,CAC5C,OACA,QACA,YAAYiD,EAAOtH,EAAQ,CACzB,MAAK,EACL,KAAK,OAASsH,EACd,KAAK,QAAUtH,CACjB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,OAAO,YACrB,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,oBAAoB,KAAK,OAAO,IAClE,CACA,SAASuG,EAAK,CACZ,MAAMxG,EAAS,KAAK,OAAO,SAASwG,CAAG,EACjC/F,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAI0C,EAAO,OAAQ1C,IAAK,CACtC,MAAMgB,EAAM0B,EAAO,IAAI1C,CAAC,EACxBmD,EAAQ,KAAKnC,IAAQ,KAAO,KAAOA,EAAI,WAAW,KAAK,OAAO,CAAC,CACjE,CACA,OAAO,IAAIkC,EAAO,GAAIf,EAAc,KAAKgB,CAAO,CAAC,CACnD,CACF,EACImwB,GAAqB,cAActsB,CAAK,CAC1C,OACA,QACA,YAAYiD,EAAOrH,EAAQ,CACzB,MAAK,EACL,KAAK,OAASqH,EACd,KAAK,QAAUrH,CACjB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,OAAO,YACrB,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,kBAAkB,KAAK,OAAO,IAChE,CACA,SAASsG,EAAK,CACZ,MAAMxG,EAAS,KAAK,OAAO,SAASwG,CAAG,EACjC/F,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAI0C,EAAO,OAAQ1C,IAAK,CACtC,MAAMgB,EAAM0B,EAAO,IAAI1C,CAAC,EACxBmD,EAAQ,KAAKnC,IAAQ,KAAO,KAAOA,EAAI,SAAS,KAAK,OAAO,CAAC,CAC/D,CACA,OAAO,IAAIkC,EAAO,GAAIf,EAAc,KAAKgB,CAAO,CAAC,CACnD,CACF,EACIowB,GAAoB,cAAcvsB,CAAK,CACzC,OACA,SACA,aACA,YAAYiD,EAAOpH,EAASC,EAAa,CACvC,MAAK,EACL,KAAK,OAASmH,EACd,KAAK,SAAWpH,EAChB,KAAK,aAAeC,CACtB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,OAAO,YACrB,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,iBAAiB,KAAK,QAAQ,OAAO,KAAK,YAAY,IACxF,CACA,SAASoG,EAAK,CACZ,MAAMxG,EAAS,KAAK,OAAO,SAASwG,CAAG,EACjC/F,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAI0C,EAAO,OAAQ1C,IAAK,CACtC,MAAMgB,EAAM0B,EAAO,IAAI1C,CAAC,EACxBmD,EAAQ,KAAKnC,IAAQ,KAAO,KAAOA,EAAI,WAAW,KAAK,SAAU,KAAK,YAAY,CAAC,CACrF,CACA,OAAO,IAAIkC,EAAO,GAAI5B,EAAW,KAAK6B,CAAO,CAAC,CAChD,CACF,EACIqwB,GAAkB,cAAcxsB,CAAK,CACvC,OACA,OACA,KACA,YAAYiD,EAAOzJ,EAAOC,EAAK,CAC7B,MAAK,EACL,KAAK,OAASwJ,EACd,KAAK,OAASzJ,EACd,KAAK,KAAOC,CACd,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,OAAO,YACrB,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,cAAc,KAAK,MAAM,GAAG,KAAK,OAAS,OAAS,KAAK,KAAK,IAAI,GAAK,EAAE,GAC1G,CACA,SAASyI,EAAK,CACZ,MAAMxG,EAAS,KAAK,OAAO,SAASwG,CAAG,EACjC/F,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAI0C,EAAO,OAAQ1C,IAAK,CACtC,MAAMgB,EAAM0B,EAAO,IAAI1C,CAAC,EACxBmD,EAAQ,KAAKnC,IAAQ,KAAO,KAAOA,EAAI,MAAM,KAAK,OAAQ,KAAK,IAAI,CAAC,CACtE,CACA,OAAO,IAAIkC,EAAO,GAAI5B,EAAW,KAAK6B,CAAO,CAAC,CAChD,CACF,EACIswB,GAAmB,cAAczsB,CAAK,CACxC,OACA,YAAYiD,EAAO,CACjB,MAAK,EACL,KAAK,OAASA,CAChB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,OAAO,YACrB,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,eAClC,CACA,SAASf,EAAK,CACZ,MAAMxG,EAAS,KAAK,OAAO,SAASwG,CAAG,EACjC/F,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAI0C,EAAO,OAAQ1C,IAAK,CACtC,MAAMgB,EAAM0B,EAAO,IAAI1C,CAAC,EACxBmD,EAAQ,KAAKnC,IAAQ,KAAO,KAAOA,EAAI,MAAM,CAC/C,CACA,OAAO,IAAIkC,EAAO,GAAI7C,EAAc,KAAK8C,CAAO,CAAC,CACnD,CACF,EACIuwB,GAAmB,cAAc1sB,CAAK,CACxC,OACA,YAAYoL,EAAO,CACjB,MAAK,EACL,KAAK,OAASA,CAChB,CACA,IAAI,cAAe,CACjB,MAAM1K,EAAuB,IAAI,IACjC,UAAW2pB,KAAQ,KAAK,OACtB,GAAIA,aAAgBrqB,EAClB,UAAW9E,KAAKmvB,EAAK,aAAc3pB,EAAK,IAAIxF,CAAC,EAGjD,MAAO,CAAC,GAAGwF,CAAI,CACjB,CACA,UAAW,CAET,MAAO,UADO,KAAK,OAAO,IAAKisB,GAAMA,aAAa3sB,EAAO2sB,EAAE,SAAQ,EAAK,IAAIA,CAAC,GAAG,EACzD,KAAK,IAAI,CAAC,GACnC,CACA,SAASzqB,EAAK,CACZ,MAAMzH,EAAMyH,EAAI,OACV0qB,EAAiB,KAAK,OAAO,IAAKvC,GAClCA,aAAgBrqB,EAAaqqB,EAAK,SAASnoB,CAAG,EAC3CmoB,CACR,EACKluB,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,IAAIkB,EAAU,GACVhB,EAAS,GACb,UAAWmxB,KAAQuC,EACjB,GAAI,OAAOvC,GAAS,SAClBnxB,GAAUmxB,MACL,CACL,MAAMrwB,EAAMqwB,EAAK,IAAIrxB,CAAC,EACtB,GAAIgB,IAAQ,KAAM,CAChBE,EAAU,GACV,KACF,CACAhB,GAAUc,CACZ,CAEFmC,EAAQ,KAAKjC,EAAU,KAAOhB,CAAM,CACtC,CACA,OAAO,IAAIgD,EAAO,GAAI5B,EAAW,KAAK6B,CAAO,CAAC,CAChD,CACF,EACI0wB,GAAqB,KAAM,CAC7B,MACA,YAAY9qB,EAAM,CAChB,KAAK,MAAQA,CACf,CACA,aAAc,CACZ,OAAO,IAAIoqB,GAAgB,KAAK,MAAO,aAAa,CACtD,CACA,aAAc,CACZ,OAAO,IAAIA,GAAgB,KAAK,MAAO,aAAa,CACtD,CACA,MAAO,CACL,OAAO,IAAIA,GAAgB,KAAK,MAAO,MAAM,CAC/C,CACA,SAAStwB,EAAS,CAChB,OAAO,IAAIuwB,GAAmB,KAAK,MAAOvwB,CAAO,CACnD,CACA,WAAWF,EAAQ,CACjB,OAAO,IAAI0wB,GAAqB,KAAK,MAAO1wB,CAAM,CACpD,CACA,SAASC,EAAQ,CACf,OAAO,IAAI0wB,GAAmB,KAAK,MAAO1wB,CAAM,CAClD,CACA,QAAQC,EAASC,EAAa,CAC5B,OAAO,IAAIywB,GAAkB,KAAK,MAAO1wB,EAASC,CAAW,CAC/D,CACA,MAAMtC,EAAOC,EAAK,CAChB,OAAO,IAAI+yB,GAAgB,KAAK,MAAOhzB,EAAOC,CAAG,CACnD,CACA,QAAS,CACP,OAAO,IAAIgzB,GAAiB,KAAK,KAAK,CACxC,CACA,UAAUrhB,EAAO,CACf,OAAO,IAAIshB,GAAiB,CAAC,KAAK,MAAO,GAAGthB,CAAK,CAAC,CACpD,CACF,EAGA,SAAS0hB,GAAqBvvB,EAAMgF,EAAI,CACtC,OAAQA,EAAE,CACR,IAAK,OACH,OAAOhF,EAAK,YAAW,EACzB,IAAK,QACH,OAAOA,EAAK,SAAQ,EAAK,EAC3B,IAAK,MACH,OAAOA,EAAK,QAAO,EACrB,IAAK,OACH,OAAOA,EAAK,SAAQ,EACtB,IAAK,SACH,OAAOA,EAAK,WAAU,EACxB,IAAK,SACH,OAAOA,EAAK,WAAU,EACxB,IAAK,YACH,OAAOA,EAAK,OAAM,EACpB,IAAK,YAAa,CAChB,MAAM/D,EAAQ,IAAI,KAAK+D,EAAK,YAAW,EAAI,EAAG,CAAC,EACzCX,EAAOW,EAAK,QAAO,EAAK/D,EAAM,QAAO,EACrCqD,EAAS,IAAM,GAAK,GAAK,GAC/B,OAAO,KAAK,MAAMD,EAAOC,CAAM,CACjC,CACA,IAAK,aAAc,CACjB,MAAMC,EAAS,IAAI,KAAKS,EAAK,QAAO,CAAE,EACtCT,EAAO,SAAS,EAAG,EAAG,EAAG,CAAC,EAC1BA,EAAO,QAAQA,EAAO,UAAY,GAAKA,EAAO,OAAM,EAAK,GAAK,CAAC,EAC/D,MAAMC,EAAO,IAAI,KAAKD,EAAO,YAAW,EAAI,EAAG,CAAC,EAC1CE,GAAWF,EAAO,UAAYC,EAAK,QAAO,IAAO,IAAM,GAAK,GAAK,IACvE,MAAO,GAAI,KAAK,OAAOC,EAAU,GAAKD,EAAK,OAAM,EAAK,GAAK,GAAK,CAAC,CACnE,CACA,IAAK,UACH,OAAO,KAAK,MAAMQ,EAAK,SAAQ,EAAK,CAAC,EAAI,EAC3C,IAAK,YACH,OAAOA,EAAK,QAAO,CACzB,CACA,CACA,IAAIwvB,EAAoB,cAAc/sB,CAAK,CACzC,OACA,IACA,YAAYiD,EAAOV,EAAI,CACrB,MAAK,EACL,KAAK,OAASU,EACd,KAAK,IAAMV,CACb,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,OAAO,YACrB,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,OAAO,KAAK,GAAG,IACjD,CACA,SAASL,EAAK,CACZ,MAAMxG,EAAS,KAAK,OAAO,SAASwG,CAAG,EACjC/F,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAI0C,EAAO,OAAQ1C,IAAK,CACtC,MAAMgB,EAAM0B,EAAO,IAAI1C,CAAC,EACxBmD,EAAQ,KAAKnC,IAAQ,KAAO,KAAO8yB,GAAqB9yB,EAAK,KAAK,GAAG,CAAC,CACxE,CACA,OAAO,IAAIkC,EAAO,GAAI7C,EAAc,KAAK8C,CAAO,CAAC,CACnD,CACF,EACI6wB,GAAmB,cAAchtB,CAAK,CACxC,OACA,MACA,YAAYiD,EAAO/F,EAAM,CACvB,MAAK,EACL,KAAK,OAAS+F,EACd,KAAK,MAAQ/F,CACf,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,OAAO,YACrB,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,iBAAiB,KAAK,KAAK,IAC7D,CACA,SAASgF,EAAK,CACZ,MAAMxG,EAAS,KAAK,OAAO,SAASwG,CAAG,EACjC/F,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAI0C,EAAO,OAAQ1C,IAAK,CACtC,MAAMgB,EAAM0B,EAAO,IAAI1C,CAAC,EACpBgB,IAAQ,KACVmC,EAAQ,KAAK,IAAI,EAEjBA,EAAQ,KAAK8wB,GAAcjzB,EAAK,KAAK,KAAK,CAAC,CAE/C,CACA,OAAO,IAAIkC,EAAO,GAAIb,EAAW,KAAKc,CAAO,CAAC,CAChD,CACF,EACI+wB,GAAe,cAAcltB,CAAK,CACpC,MACA,OACA,MACA,YAAYqC,EAAMC,EAAOpF,EAAM,CAC7B,MAAK,EACL,KAAK,MAAQmF,EACb,KAAK,OAASC,EACd,KAAK,MAAQpF,CACf,CACA,IAAI,cAAe,CACjB,MAAO,CAAC,GAAmB,IAAI,IAAI,CAAC,GAAG,KAAK,MAAM,aAAc,GAAG,KAAK,OAAO,YAAY,CAAC,CAAC,CAC/F,CACA,UAAW,CACT,MAAO,YAAY,KAAK,MAAM,SAAQ,CAAE,KAAK,KAAK,OAAO,SAAQ,CAAE,MAAM,KAAK,KAAK,IACrF,CACA,SAASgF,EAAK,CACZ,MAAMM,EAAa,KAAK,MAAM,SAASN,CAAG,EACpCO,EAAc,KAAK,OAAO,SAASP,CAAG,EACtCzH,EAAM+H,EAAW,OACjBrG,EAAU,CAAA,EAChB,QAASnD,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmE,EAAIqF,EAAW,IAAIxJ,CAAC,EACpBoE,EAAIqF,EAAY,IAAIzJ,CAAC,EAC3B,GAAImE,IAAM,MAAQC,IAAM,KACtBjB,EAAQ,KAAK,IAAI,MACZ,CACL,MAAMyB,EAAST,EAAE,QAAO,EAAKC,EAAE,QAAO,EACtCjB,EAAQ,KAAKgxB,GAAoBvvB,EAAQ,KAAK,KAAK,CAAC,CACtD,CACF,CACA,OAAO,IAAI1B,EAAO,GAAI7C,EAAc,KAAK8C,CAAO,CAAC,CACnD,CACF,EACA,SAASgxB,GAAoBC,EAAIlwB,EAAM,CACrC,OAAQA,EAAI,CACV,IAAK,eACH,OAAOkwB,EACT,IAAK,UACH,OAAOA,EAAK,IACd,IAAK,UACH,OAAOA,GAAM,IAAM,IACrB,IAAK,QACH,OAAOA,GAAM,IAAM,GAAK,IAC1B,IAAK,OACH,OAAOA,GAAM,IAAM,GAAK,GAAK,GACnC,CACA,CACA,SAASH,GAAc1vB,EAAML,EAAM,CACjC,OAAQA,EAAI,CACV,IAAK,OACH,OAAO,IAAI,KAAKK,EAAK,YAAW,EAAI,EAAG,CAAC,EAC1C,IAAK,QACH,OAAO,IAAI,KAAKA,EAAK,YAAW,EAAIA,EAAK,SAAQ,EAAI,CAAC,EACxD,IAAK,MACH,OAAO,IAAI,KAAKA,EAAK,YAAW,EAAIA,EAAK,SAAQ,EAAIA,EAAK,SAAS,EACrE,IAAK,OACH,OAAO,IAAI,KAAKA,EAAK,YAAW,EAAIA,EAAK,SAAQ,EAAIA,EAAK,QAAO,EAAIA,EAAK,SAAQ,CAAE,EACtF,IAAK,SACH,OAAO,IAAI,KAAKA,EAAK,YAAW,EAAIA,EAAK,SAAQ,EAAIA,EAAK,QAAO,EAAIA,EAAK,SAAQ,EAAIA,EAAK,WAAU,CAAE,EACzG,IAAK,SACH,OAAO,IAAI,KAAKA,EAAK,YAAW,EAAIA,EAAK,SAAQ,EAAIA,EAAK,QAAO,EAAIA,EAAK,WAAYA,EAAK,aAAcA,EAAK,YAAY,CAChI,CACA,CACG,IAAC8vB,GAAmB,KAAM,CAC3B,MACA,YAAYtrB,EAAM,CAChB,KAAK,MAAQA,CACf,CACA,MAAO,CACL,OAAO,IAAIgrB,EAAkB,KAAK,MAAO,MAAM,CACjD,CACA,OAAQ,CACN,OAAO,IAAIA,EAAkB,KAAK,MAAO,OAAO,CAClD,CACA,KAAM,CACJ,OAAO,IAAIA,EAAkB,KAAK,MAAO,KAAK,CAChD,CACA,MAAO,CACL,OAAO,IAAIA,EAAkB,KAAK,MAAO,MAAM,CACjD,CACA,QAAS,CACP,OAAO,IAAIA,EAAkB,KAAK,MAAO,QAAQ,CACnD,CACA,QAAS,CACP,OAAO,IAAIA,EAAkB,KAAK,MAAO,QAAQ,CACnD,CACA,WAAY,CACV,OAAO,IAAIA,EAAkB,KAAK,MAAO,WAAW,CACtD,CACA,WAAY,CACV,OAAO,IAAIA,EAAkB,KAAK,MAAO,WAAW,CACtD,CACA,YAAa,CACX,OAAO,IAAIA,EAAkB,KAAK,MAAO,YAAY,CACvD,CACA,SAAU,CACR,OAAO,IAAIA,EAAkB,KAAK,MAAO,SAAS,CACpD,CACA,WAAY,CACV,OAAO,IAAIA,EAAkB,KAAK,MAAO,WAAW,CACtD,CACA,SAAS7vB,EAAM,CACb,OAAO,IAAI8vB,GAAiB,KAAK,MAAO9vB,CAAI,CAC9C,CACA,KAAKjE,EAAOiE,EAAO,OAAQ,CACzB,OAAO,IAAIgwB,GAAa,KAAK,MAAOj0B,EAAOiE,CAAI,CACjD,CACF,EAGIowB,GAAoB,cAActtB,CAAK,CACzC,QACA,YACA,YAAY3D,EAAQkkB,EAAa,GAAO,CACtC,MAAK,EACL,KAAK,QAAUlkB,EACf,KAAK,YAAckkB,CACrB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,QAAQ,YACtB,CACA,aAAapjB,EAAGC,EAAG,CACjB,OAAO,KAAK,YAAc,CAACmwB,GAAcpwB,EAAGC,CAAC,EAAImwB,GAAcpwB,EAAGC,CAAC,CACrE,CACF,EACIowB,GAAiB,MAAMC,WAAwBH,EAAkB,CACnE,UAAW,CACT,MAAO,QAAQ,KAAK,QAAQ,SAAQ,CAAE,GACxC,CACA,eAAe9H,EAAM,CACnB,OAAO,IAAIiI,GAAgB,KAAK,QAASjI,CAAI,CAC/C,CACA,SAAStjB,EAAK,CACZ,MAAMxG,EAAS,KAAK,QAAQ,SAASwG,CAAG,EAClCzH,EAAMiB,EAAO,OACbgyB,EAAU,CAAA,EAChB,QAAS10B,EAAI,EAAGA,EAAIyB,EAAKzB,IACvB00B,EAAQ,KAAK,CAAE,MAAOhyB,EAAO,IAAI1C,CAAC,EAAG,IAAKA,EAAG,EAE/C00B,EAAQ,KAAK,CAACvwB,EAAGC,IAAM,KAAK,aAAaD,EAAE,MAAOC,EAAE,KAAK,CAAC,EAC1D,MAAMuwB,EAAQ,IAAI,MAAMlzB,CAAG,EAC3B,IAAImzB,EAAO,EACX,QAAS50B,EAAI,EAAGA,EAAI00B,EAAQ,OAAQ10B,IAC9BA,EAAI,GAAKu0B,GAAcG,EAAQ10B,CAAC,EAAE,MAAO00B,EAAQ10B,EAAI,CAAC,EAAE,KAAK,IAAM,IACrE40B,EAAO50B,EAAI,GAEb20B,EAAMD,EAAQ10B,CAAC,EAAE,GAAG,EAAI40B,EAE1B,OAAO,IAAI1xB,EAAO,OAAQ7C,EAAc,KAAKs0B,CAAK,CAAC,CACrD,CACF,EACIE,GAAsB,MAAMC,WAA6BR,EAAkB,CAC7E,UAAW,CACT,MAAO,cAAc,KAAK,QAAQ,SAAQ,CAAE,GAC9C,CACA,eAAe9H,EAAM,CACnB,OAAO,IAAIsI,GAAqB,KAAK,QAAStI,CAAI,CACpD,CACA,SAAStjB,EAAK,CACZ,MAAMxG,EAAS,KAAK,QAAQ,SAASwG,CAAG,EAClCzH,EAAMiB,EAAO,OACbgyB,EAAU,CAAA,EAChB,QAAS10B,EAAI,EAAGA,EAAIyB,EAAKzB,IACvB00B,EAAQ,KAAK,CAAE,MAAOhyB,EAAO,IAAI1C,CAAC,EAAG,IAAKA,EAAG,EAE/C00B,EAAQ,KAAK,CAACvwB,EAAGC,IAAM,KAAK,aAAaD,EAAE,MAAOC,EAAE,KAAK,CAAC,EAC1D,MAAMuwB,EAAQ,IAAI,MAAMlzB,CAAG,EAC3B,IAAImzB,EAAO,EACX,QAAS50B,EAAI,EAAGA,EAAI00B,EAAQ,OAAQ10B,IAC9BA,EAAI,GAAKu0B,GAAcG,EAAQ10B,CAAC,EAAE,MAAO00B,EAAQ10B,EAAI,CAAC,EAAE,KAAK,IAAM,GACrE40B,IAEFD,EAAMD,EAAQ10B,CAAC,EAAE,GAAG,EAAI40B,EAE1B,OAAO,IAAI1xB,EAAO,aAAc7C,EAAc,KAAKs0B,CAAK,CAAC,CAC3D,CACF,EACII,GAAsB,MAAMC,WAA6BV,EAAkB,CAC7E,UAAW,CACT,MAAO,cAAc,KAAK,QAAQ,SAAQ,CAAE,GAC9C,CACA,eAAe9H,EAAM,CACnB,OAAO,IAAIwI,GAAqB,KAAK,QAASxI,CAAI,CACpD,CACA,SAAStjB,EAAK,CACZ,MAAMxG,EAAS,KAAK,QAAQ,SAASwG,CAAG,EAClCzH,EAAMiB,EAAO,OACbzB,EAAS,IAAI,MAAMQ,CAAG,EAC5B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAKiB,EAAOjB,CAAC,EAAI0C,EAAO,IAAI1C,CAAC,EACtD,MAAM00B,EAAU,MAAM,KAAK,CAAE,OAAQjzB,CAAG,EAAI,CAACmP,EAAG5Q,IAAMA,CAAC,EACvD00B,EAAQ,KAAK,CAACvwB,EAAGC,IAAM,KAAK,aAAanD,EAAOkD,CAAC,EAAGlD,EAAOmD,CAAC,CAAC,CAAC,EAC9D,MAAMuwB,EAAQ,IAAI,MAAMlzB,CAAG,EAC3B,QAASzB,EAAI,EAAGA,EAAI00B,EAAQ,OAAQ10B,IAClC20B,EAAMD,EAAQ10B,CAAC,CAAC,EAAIA,EAAI,EAE1B,OAAO,IAAIkD,EAAO,aAAc7C,EAAc,KAAKs0B,CAAK,CAAC,CAC3D,CACF,EACIM,GAAwB,MAAMC,WAA+BZ,EAAkB,CACjF,UAAW,CACT,MAAO,gBAAgB,KAAK,QAAQ,SAAQ,CAAE,GAChD,CACA,eAAe9H,EAAM,CACnB,OAAO,IAAI0I,GAAuB,KAAK,QAAS1I,CAAI,CACtD,CACA,SAAStjB,EAAK,CACZ,MAAMxG,EAAS,KAAK,QAAQ,SAASwG,CAAG,EAClCzH,EAAMiB,EAAO,OACnB,GAAIjB,GAAO,EAAG,CACZ,MAAM0B,EAAU,IAAI,MAAM1B,CAAG,EAAE,KAAK,CAAC,EACrC,OAAO,IAAIyB,EAAO,eAAgB7C,EAAc,KAAK8C,CAAO,CAAC,CAC/D,CACA,MAAMuxB,EAAU,CAAA,EAChB,QAAS10B,EAAI,EAAGA,EAAIyB,EAAKzB,IACvB00B,EAAQ,KAAK,CAAE,MAAOhyB,EAAO,IAAI1C,CAAC,EAAG,IAAKA,EAAG,EAE/C00B,EAAQ,KAAK,CAACvwB,EAAGC,IAAM,KAAK,aAAaD,EAAE,MAAOC,EAAE,KAAK,CAAC,EAC1D,MAAMuwB,EAAQ,IAAI,MAAMlzB,CAAG,EAC3B,IAAImzB,EAAO,EACX,QAAS50B,EAAI,EAAGA,EAAI00B,EAAQ,OAAQ10B,IAC9BA,EAAI,GAAKu0B,GAAcG,EAAQ10B,CAAC,EAAE,MAAO00B,EAAQ10B,EAAI,CAAC,EAAE,KAAK,IAAM,IACrE40B,EAAO50B,EAAI,GAEb20B,EAAMD,EAAQ10B,CAAC,EAAE,GAAG,GAAK40B,EAAO,IAAMnzB,EAAM,GAE9C,OAAO,IAAIyB,EAAO,eAAgB7C,EAAc,KAAKs0B,CAAK,CAAC,CAC7D,CACF,EACIQ,GAAkB,MAAMC,WAAyBd,EAAkB,CACrE,GACA,YAAYjxB,EAAQ,EAAGkkB,EAAa,GAAO,CACzC,MAAMlkB,EAAQkkB,CAAU,EACxB,KAAK,GAAK,CACZ,CACA,UAAW,CACT,MAAO,SAAS,KAAK,QAAQ,SAAQ,CAAE,KAAK,KAAK,EAAE,GACrD,CACA,eAAeiF,EAAM,CACnB,OAAO,IAAI4I,GAAiB,KAAK,QAAS,KAAK,GAAI5I,CAAI,CACzD,CACA,SAAStjB,EAAK,CACZ,MAAMxG,EAAS,KAAK,QAAQ,SAASwG,CAAG,EAClCzH,EAAMiB,EAAO,OACbgyB,EAAU,CAAA,EAChB,QAAS,EAAI,EAAG,EAAIjzB,EAAK,IACvBizB,EAAQ,KAAK,CAAE,MAAOhyB,EAAO,IAAI,CAAC,EAAG,IAAK,EAAG,EAE/CgyB,EAAQ,KAAK,CAACvwB,EAAGC,IAAM,KAAK,aAAaD,EAAE,MAAOC,EAAE,KAAK,CAAC,EAC1D,MAAMjB,EAAU,IAAI,MAAM1B,CAAG,EAC7B,QAAS,EAAI,EAAG,EAAIizB,EAAQ,OAAQ,IAClCvxB,EAAQuxB,EAAQ,CAAC,EAAE,GAAG,EAAI,KAAK,MAAM,EAAI,KAAK,GAAKjzB,CAAG,EAAI,EAE5D,OAAO,IAAIyB,EAAO,QAAS7C,EAAc,KAAK8C,CAAO,CAAC,CACxD,CACF,EACA,SAASoxB,GAAcpwB,EAAGC,EAAG,CAC3B,GAAID,IAAM,MAAQC,IAAM,KAAM,MAAO,GACrC,GAAID,IAAM,KAAM,MAAO,GACvB,GAAIC,IAAM,KAAM,MAAO,GACvB,GAAI,OAAOD,GAAM,UAAY,OAAOC,GAAM,SACxC,OAAOD,EAAIC,EAEb,GAAI,OAAOD,GAAM,UAAY,OAAOC,GAAM,SACxC,OAAOD,EAAIC,EAAI,GAAKD,EAAIC,EAAI,EAAI,EAElC,GAAID,aAAa,MAAQC,aAAa,KACpC,OAAOD,EAAE,UAAYC,EAAE,QAAO,EAEhC,MAAMixB,EAAK,OAAOlxB,GAAM,SAAWA,EAAI,OAAOA,GAAM,SAAW,GAAGA,CAAC,GAAK,OAAOA,GAAM,UAAY,GAAGA,CAAC,GAAK,SACpGmxB,EAAK,OAAOlxB,GAAM,SAAWA,EAAI,OAAOA,GAAM,SAAW,GAAGA,CAAC,GAAK,OAAOA,GAAM,UAAY,GAAGA,CAAC,GAAK,SAC1G,OAAOixB,EAAKC,EAAK,GAAKD,EAAKC,EAAK,EAAI,CACtC,CACA,IAAIC,GAAiB,cAAcvuB,CAAK,CACtC,QACA,YAAY3D,EAAQ,CAClB,MAAK,EACL,KAAK,QAAUA,CACjB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,QAAQ,YACtB,CACF,EACImyB,GAAa,cAAcD,EAAe,CAC5C,UAAW,CACT,MAAO,UAAU,KAAK,QAAQ,SAAQ,CAAE,GAC1C,CACA,SAASrsB,EAAK,CACZ,MAAMxG,EAAS,KAAK,QAAQ,SAASwG,CAAG,EAClCzH,EAAMiB,EAAO,OACbS,EAAU,IAAI,MAAM1B,CAAG,EAC7B,IAAI6Y,EAAM,EACV,QAASta,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmB,EAAIuB,EAAO,IAAI1C,CAAC,EAClBmB,IAAM,MAAQ,OAAOA,GAAM,WAC7BmZ,GAAOnZ,GAETgC,EAAQnD,CAAC,EAAIsa,CACf,CACA,OAAO,IAAIpX,EAAO,SAAU7C,EAAc,KAAK8C,CAAO,CAAC,CACzD,CACF,EACIsyB,GAAa,cAAcF,EAAe,CAC5C,UAAW,CACT,MAAO,UAAU,KAAK,QAAQ,SAAQ,CAAE,GAC1C,CACA,SAASrsB,EAAK,CACZ,MAAMxG,EAAS,KAAK,QAAQ,SAASwG,CAAG,EAClCzH,EAAMiB,EAAO,OACbS,EAAU,IAAI,MAAM1B,CAAG,EAC7B,IAAIuuB,EAAM,KACV,QAAShwB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmB,EAAIuB,EAAO,IAAI1C,CAAC,EAClBmB,IAAM,MAAQ,OAAOA,GAAM,WAC7B6uB,EAAMA,IAAQ,KAAO7uB,EAAI,KAAK,IAAI6uB,EAAK7uB,CAAC,GAE1CgC,EAAQnD,CAAC,EAAIgwB,CACf,CACA,OAAO,IAAI9sB,EAAO,SAAU7C,EAAc,KAAK8C,CAAO,CAAC,CACzD,CACF,EACIuyB,GAAa,cAAcH,EAAe,CAC5C,UAAW,CACT,MAAO,UAAU,KAAK,QAAQ,SAAQ,CAAE,GAC1C,CACA,SAASrsB,EAAK,CACZ,MAAMxG,EAAS,KAAK,QAAQ,SAASwG,CAAG,EAClCzH,EAAMiB,EAAO,OACbS,EAAU,IAAI,MAAM1B,CAAG,EAC7B,IAAIsuB,EAAM,KACV,QAAS/vB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmB,EAAIuB,EAAO,IAAI1C,CAAC,EAClBmB,IAAM,MAAQ,OAAOA,GAAM,WAC7B4uB,EAAMA,IAAQ,KAAO5uB,EAAI,KAAK,IAAI4uB,EAAK5uB,CAAC,GAE1CgC,EAAQnD,CAAC,EAAI+vB,CACf,CACA,OAAO,IAAI7sB,EAAO,SAAU7C,EAAc,KAAK8C,CAAO,CAAC,CACzD,CACF,EACIwyB,GAAc,cAAcJ,EAAe,CAC7C,UAAW,CACT,MAAO,WAAW,KAAK,QAAQ,SAAQ,CAAE,GAC3C,CACA,SAASrsB,EAAK,CACZ,MAAMxG,EAAS,KAAK,QAAQ,SAASwG,CAAG,EAClCzH,EAAMiB,EAAO,OACbS,EAAU,IAAI,MAAM1B,CAAG,EAC7B,IAAIm0B,EAAO,EACX,QAAS51B,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmB,EAAIuB,EAAO,IAAI1C,CAAC,EAClBmB,IAAM,MAAQ,OAAOA,GAAM,WAC7By0B,GAAQz0B,GAEVgC,EAAQnD,CAAC,EAAI41B,CACf,CACA,OAAO,IAAI1yB,EAAO,UAAW7C,EAAc,KAAK8C,CAAO,CAAC,CAC1D,CACF,EACI0yB,GAAe,cAAcN,EAAe,CAC9C,UAAW,CACT,MAAO,YAAY,KAAK,QAAQ,SAAQ,CAAE,GAC5C,CACA,SAASrsB,EAAK,CACZ,MAAMxG,EAAS,KAAK,QAAQ,SAASwG,CAAG,EAClCzH,EAAMiB,EAAO,OACbS,EAAU,IAAI,MAAM1B,CAAG,EAC7B,IAAItD,EAAQ,EACZ,QAAS6B,EAAI,EAAGA,EAAIyB,EAAKzB,IACb0C,EAAO,IAAI1C,CAAC,IACZ,MACR7B,IAEFgF,EAAQnD,CAAC,EAAI7B,EAEf,OAAO,IAAI+E,EAAO,WAAY7C,EAAc,KAAK8C,CAAO,CAAC,CAC3D,CACF,EACI2yB,GAAa,cAAc9uB,CAAK,CAClC,QACA,QACA,YAAY3D,EAAQ2gB,EAAQ,CAC1B,MAAK,EACL,KAAK,QAAU3gB,EACf,KAAK,QAAU2gB,CACjB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,QAAQ,YACtB,CACF,EACI+R,GAAY,cAAcD,EAAW,CACvC,UAAW,CACT,MAAO,SAAS,KAAK,QAAQ,SAAQ,CAAE,KAAK,KAAK,OAAO,GAC1D,CACA,SAAS5sB,EAAK,CACZ,MAAMxG,EAAS,KAAK,QAAQ,SAASwG,CAAG,EAClCzH,EAAMiB,EAAO,OACbS,EAAU,IAAI,MAAM1B,CAAG,EAC7B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMg2B,EAASh2B,EAAI,KAAK,QACxB,GAAIg2B,EAAS,GAAKA,GAAUv0B,EAC1B0B,EAAQnD,CAAC,EAAI,SACR,CACL,MAAMmB,EAAIuB,EAAO,IAAIszB,CAAM,EAC3B7yB,EAAQnD,CAAC,EAAImB,IAAM,MAAQ,OAAOA,GAAM,SAAWA,EAAI,IACzD,CACF,CACA,OAAO,IAAI+B,EAAO,QAAS7C,EAAc,KAAK8C,CAAO,CAAC,CACxD,CACF,EACI8yB,GAAW,cAAcH,EAAW,CACtC,UAAW,CACT,MAAO,QAAQ,KAAK,QAAQ,SAAQ,CAAE,KAAK,KAAK,OAAO,GACzD,CACA,SAAS5sB,EAAK,CACZ,MAAMxG,EAAS,KAAK,QAAQ,SAASwG,CAAG,EAClCzH,EAAMiB,EAAO,OACbS,EAAU,IAAI,MAAM1B,CAAG,EAC7B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMk2B,EAAUl2B,EAAI,KAAK,QACzB,GAAIk2B,EAAU,GAAKA,GAAWz0B,EAC5B0B,EAAQnD,CAAC,EAAI,SACR,CACL,MAAMm2B,EAAOzzB,EAAO,IAAI1C,CAAC,EACnBo2B,EAAO1zB,EAAO,IAAIwzB,CAAO,EAC3BC,IAAS,MAAQ,OAAOA,GAAS,UAAYC,IAAS,MAAQ,OAAOA,GAAS,SAChFjzB,EAAQnD,CAAC,EAAIm2B,EAAOC,EAEpBjzB,EAAQnD,CAAC,EAAI,IAEjB,CACF,CACA,OAAO,IAAIkD,EAAO,OAAQ7C,EAAc,KAAK8C,CAAO,CAAC,CACvD,CACF,EACIkzB,GAAgB,cAAcP,EAAW,CAC3C,UAAW,CACT,MAAO,aAAa,KAAK,QAAQ,SAAQ,CAAE,KAAK,KAAK,OAAO,GAC9D,CACA,SAAS5sB,EAAK,CACZ,MAAMxG,EAAS,KAAK,QAAQ,SAASwG,CAAG,EAClCzH,EAAMiB,EAAO,OACbS,EAAU,IAAI,MAAM1B,CAAG,EAC7B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMk2B,EAAUl2B,EAAI,KAAK,QACzB,GAAIk2B,EAAU,GAAKA,GAAWz0B,EAC5B0B,EAAQnD,CAAC,EAAI,SACR,CACL,MAAMm2B,EAAOzzB,EAAO,IAAI1C,CAAC,EACnBo2B,EAAO1zB,EAAO,IAAIwzB,CAAO,EAC3BC,IAAS,MAAQ,OAAOA,GAAS,UAAYC,IAAS,MAAQ,OAAOA,GAAS,UAAYA,IAAS,EACrGjzB,EAAQnD,CAAC,GAAKm2B,EAAOC,GAAQA,EAE7BjzB,EAAQnD,CAAC,EAAI,IAEjB,CACF,CACA,OAAO,IAAIkD,EAAO,YAAa7C,EAAc,KAAK8C,CAAO,CAAC,CAC5D,CACF,EACImzB,GAAc,cAActvB,CAAK,CACnC,QACA,YACA,YAAY3D,EAAQkzB,EAAY,CAC9B,MAAK,EACL,KAAK,QAAUlzB,EACf,KAAK,YAAckzB,CACrB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,QAAQ,YACtB,CACA,kBAAkBrtB,EAAK,CACrB,MAAMxG,EAAS,KAAK,QAAQ,SAASwG,CAAG,EAClCzH,EAAMiB,EAAO,OACbzB,EAAS,CAAA,EACf,QAASjB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmB,EAAIuB,EAAO,IAAI1C,CAAC,EACtBiB,EAAO,KAAKE,IAAM,MAAQ,OAAOA,GAAM,SAAWA,EAAI,IAAI,CAC5D,CACA,OAAOF,CACT,CACF,EACIu1B,GAAkB,cAAcF,EAAY,CAC9C,UAAW,CACT,MAAO,eAAe,KAAK,QAAQ,SAAQ,CAAE,KAAK,KAAK,WAAW,GACpE,CACA,SAASptB,EAAK,CACZ,MAAMjI,EAAS,KAAK,kBAAkBiI,CAAG,EACnCzH,EAAMR,EAAO,OACbkC,EAAU,IAAI,MAAM1B,CAAG,EAC7B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IACvB,GAAIA,EAAI,KAAK,YAAc,EACzBmD,EAAQnD,CAAC,EAAI,SACR,CACL,IAAIsa,EAAM,EACNnc,EAAQ,EACZ,QAASoV,EAAIvT,EAAI,KAAK,YAAc,EAAGuT,GAAKvT,EAAGuT,IAAK,CAClD,MAAMpS,EAAIF,EAAOsS,CAAC,EACdpS,IAAM,OACRmZ,GAAOnZ,EACPhD,IAEJ,CACAgF,EAAQnD,CAAC,EAAI7B,EAAQ,EAAImc,EAAMnc,EAAQ,IACzC,CAEF,OAAO,IAAI+E,EAAO,cAAe7C,EAAc,KAAK8C,CAAO,CAAC,CAC9D,CACF,EACIszB,GAAiB,cAAcH,EAAY,CAC7C,UAAW,CACT,MAAO,cAAc,KAAK,QAAQ,SAAQ,CAAE,KAAK,KAAK,WAAW,GACnE,CACA,SAASptB,EAAK,CACZ,MAAMjI,EAAS,KAAK,kBAAkBiI,CAAG,EACnCzH,EAAMR,EAAO,OACbkC,EAAU,IAAI,MAAM1B,CAAG,EAC7B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IACvB,GAAIA,EAAI,KAAK,YAAc,EACzBmD,EAAQnD,CAAC,EAAI,SACR,CACL,IAAIsa,EAAM,EACV,QAAS/G,EAAIvT,EAAI,KAAK,YAAc,EAAGuT,GAAKvT,EAAGuT,IAAK,CAClD,MAAMpS,EAAIF,EAAOsS,CAAC,EACdpS,IAAM,OACRmZ,GAAOnZ,EAEX,CACAgC,EAAQnD,CAAC,EAAIsa,CACf,CAEF,OAAO,IAAIpX,EAAO,aAAc7C,EAAc,KAAK8C,CAAO,CAAC,CAC7D,CACF,EACIuzB,GAAiB,cAAcJ,EAAY,CAC7C,UAAW,CACT,MAAO,cAAc,KAAK,QAAQ,SAAQ,CAAE,KAAK,KAAK,WAAW,GACnE,CACA,SAASptB,EAAK,CACZ,MAAMjI,EAAS,KAAK,kBAAkBiI,CAAG,EACnCzH,EAAMR,EAAO,OACbkC,EAAU,IAAI,MAAM1B,CAAG,EAC7B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IACvB,GAAIA,EAAI,KAAK,YAAc,EACzBmD,EAAQnD,CAAC,EAAI,SACR,CACL,MAAM22B,EAAa,CAAA,EACnB,QAASpjB,EAAIvT,EAAI,KAAK,YAAc,EAAGuT,GAAKvT,EAAGuT,IAAK,CAClD,MAAMpS,EAAIF,EAAOsS,CAAC,EACdpS,IAAM,MACRw1B,EAAW,KAAKx1B,CAAC,CAErB,CACA,GAAIw1B,EAAW,OAAS,EACtBxzB,EAAQnD,CAAC,EAAI,SACR,CACL,IAAIsa,EAAM,EACV,UAAWnZ,KAAKw1B,EAAYrc,GAAOnZ,EACnC,MAAMoJ,EAAO+P,EAAMqc,EAAW,OAC9B,IAAIC,EAAY,EAChB,UAAWz1B,KAAKw1B,EAAYC,IAAcz1B,EAAIoJ,IAASpJ,EAAIoJ,GAC3DpH,EAAQnD,CAAC,EAAI,KAAK,KAAK42B,GAAaD,EAAW,OAAS,EAAE,CAC5D,CACF,CAEF,OAAO,IAAIzzB,EAAO,aAAc7C,EAAc,KAAK8C,CAAO,CAAC,CAC7D,CACF,EACI0zB,GAAiB,cAAcP,EAAY,CAC7C,UAAW,CACT,MAAO,cAAc,KAAK,QAAQ,SAAQ,CAAE,KAAK,KAAK,WAAW,GACnE,CACA,SAASptB,EAAK,CACZ,MAAMjI,EAAS,KAAK,kBAAkBiI,CAAG,EACnCzH,EAAMR,EAAO,OACbkC,EAAU,IAAI,MAAM1B,CAAG,EAC7B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IACvB,GAAIA,EAAI,KAAK,YAAc,EACzBmD,EAAQnD,CAAC,EAAI,SACR,CACL,IAAI+vB,EAAM,KACV,QAASxc,EAAIvT,EAAI,KAAK,YAAc,EAAGuT,GAAKvT,EAAGuT,IAAK,CAClD,MAAMpS,EAAIF,EAAOsS,CAAC,EACdpS,IAAM,OACR4uB,EAAMA,IAAQ,KAAO5uB,EAAI,KAAK,IAAI4uB,EAAK5uB,CAAC,EAE5C,CACAgC,EAAQnD,CAAC,EAAI+vB,CACf,CAEF,OAAO,IAAI7sB,EAAO,aAAc7C,EAAc,KAAK8C,CAAO,CAAC,CAC7D,CACF,EACI2zB,GAAiB,cAAcR,EAAY,CAC7C,UAAW,CACT,MAAO,cAAc,KAAK,QAAQ,SAAQ,CAAE,KAAK,KAAK,WAAW,GACnE,CACA,SAASptB,EAAK,CACZ,MAAMjI,EAAS,KAAK,kBAAkBiI,CAAG,EACnCzH,EAAMR,EAAO,OACbkC,EAAU,IAAI,MAAM1B,CAAG,EAC7B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IACvB,GAAIA,EAAI,KAAK,YAAc,EACzBmD,EAAQnD,CAAC,EAAI,SACR,CACL,IAAIgwB,EAAM,KACV,QAASzc,EAAIvT,EAAI,KAAK,YAAc,EAAGuT,GAAKvT,EAAGuT,IAAK,CAClD,MAAMpS,EAAIF,EAAOsS,CAAC,EACdpS,IAAM,OACR6uB,EAAMA,IAAQ,KAAO7uB,EAAI,KAAK,IAAI6uB,EAAK7uB,CAAC,EAE5C,CACAgC,EAAQnD,CAAC,EAAIgwB,CACf,CAEF,OAAO,IAAI9sB,EAAO,aAAc7C,EAAc,KAAK8C,CAAO,CAAC,CAC7D,CACF,EACI4zB,GAAU,cAAc/vB,CAAK,CAC/B,QACA,OACA,YAAY3D,EAAQ2zB,EAAO,CACzB,MAAK,EACL,KAAK,QAAU3zB,EACf,KAAK,OAAS2zB,CAChB,CACA,IAAI,cAAe,CACjB,OAAO,KAAK,QAAQ,YACtB,CACA,UAAW,CACT,MAAO,OAAO,KAAK,QAAQ,SAAQ,CAAE,KAAK,KAAK,MAAM,GACvD,CACA,SAAS9tB,EAAK,CACZ,MAAMxG,EAAS,KAAK,QAAQ,SAASwG,CAAG,EAClCzH,EAAMiB,EAAO,OACbS,EAAU,IAAI,MAAM1B,CAAG,EAC7B,IAAIw1B,EAAO,KACX,QAASj3B,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMmB,EAAIuB,EAAO,IAAI1C,CAAC,EAClBmB,IAAM,MAAQ,OAAOA,GAAM,WACzB81B,IAAS,KACXA,EAAO91B,EAEP81B,EAAO,KAAK,OAAS91B,GAAK,EAAI,KAAK,QAAU81B,GAE/C9zB,EAAQnD,CAAC,EAAIi3B,CAIjB,CACA,OAAO,IAAI/zB,EAAO,MAAO7C,EAAc,KAAK8C,CAAO,CAAC,CACtD,CACF,EACI+zB,GAAwB,cAAclwB,CAAK,CAC7C,OACA,eACA,YAAYiD,EAAOktB,EAAe,CAChC,MAAK,EACL,KAAK,OAASltB,EACd,KAAK,eAAiBktB,CACxB,CACA,IAAI,cAAe,CACjB,MAAO,CAAC,GAAmB,IAAI,IAAI,CAAC,GAAG,KAAK,OAAO,aAAc,GAAG,KAAK,cAAc,CAAC,CAAC,CAC3F,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,SAAS,KAAK,eAAe,KAAK,IAAI,CAAC,GACzE,CACA,SAASjuB,EAAK,CACZ,MAAMzH,EAAMyH,EAAI,OACV/F,EAAU,IAAI,MAAM1B,CAAG,EACvB21B,EAA+B,IAAI,IACnCC,EAAW,KAAK,eAAe,IAAKhyB,GAAS6D,EAAI,IAAI7D,CAAI,EAAE,MAAM,EACvE,QAAS,EAAI,EAAG,EAAI5D,EAAK,IAAK,CAC5B,MAAMwE,EAAMqxB,GAAcD,EAAU,CAAC,EAC/Bje,EAAQge,EAAa,IAAInxB,CAAG,EAC9BmT,EACFA,EAAM,KAAK,CAAC,EAEZge,EAAa,IAAInxB,EAAK,CAAC,CAAC,CAAC,CAE7B,CACA,MAAMwQ,EAAcvN,EAAI,QACxB,UAAWtI,KAAWw2B,EAAa,SAAU,CAC3C,MAAMxc,EAAe,IAAI,WAAWha,CAAO,EACrCwa,EAA6B,IAAI,IACvC,UAAW/V,KAAQoR,EACjB2E,EAAW,IAAI/V,EAAM6D,EAAI,IAAI7D,CAAI,EAAE,OAAO,KAAKuV,CAAY,CAAC,EAE9D,MAAM2c,EAAQ,IAAIjN,GAAUlP,EAAY3E,CAAW,EAC7C+gB,EAAY,KAAK,OAAO,SAASD,CAAK,EAC5C,QAASv3B,EAAI,EAAGA,EAAIY,EAAQ,OAAQZ,IAClCmD,EAAQvC,EAAQZ,CAAC,CAAC,EAAIw3B,EAAU,IAAIx3B,CAAC,CAEzC,CACA,OAAO,IAAIkD,EAAO,OAAQ7C,EAAc,KAAK8C,CAAO,CAAC,CACvD,CACF,EACA,SAASm0B,GAAc9wB,EAAS5G,EAAO,CACrC,MAAMwS,EAAQ,CAAA,EACd,UAAWnT,KAAUuH,EAAS,CAC5B,MAAMrF,EAAIlC,EAAO,IAAIW,CAAK,EACtBuB,IAAM,KACRiR,EAAM,KAAK,QAAQ,EACVjR,aAAa,KACtBiR,EAAM,KAAK,MAAMjR,EAAE,QAAO,CAAE,EAAE,EACrB,OAAOA,GAAM,UAAY,OAAOA,GAAM,UAAY,OAAOA,GAAM,UACxEiR,EAAM,KAAK,KAAK,OAAOjR,CAAC,GAAG,OAAOA,CAAC,CAAC,EAAE,EAEtCiR,EAAM,KAAK,QAAQ,KAAK,UAAUjR,CAAC,CAAC,EAAE,CAE1C,CACA,OAAOiR,EAAM,KAAK,GAAG,CACvB,CACG,IAACqlB,GAAoB,cAAczwB,CAAK,CACzC,OACA,UACA,WACA,YAAYiD,EAAOytB,EAAUzO,EAAY,MAAO,CAC9C,MAAK,EACL,KAAK,OAAShf,EACd,KAAK,UAAYytB,EACjB,KAAK,WAAazO,CACpB,CACA,IAAI,cAAe,CACjB,MAAO,CAAC,GAAmB,IAAI,IAAI,CAAC,GAAG,KAAK,OAAO,aAAc,KAAK,SAAS,CAAC,CAAC,CACnF,CACA,UAAW,CACT,MAAO,GAAG,KAAK,OAAO,SAAQ,CAAE,YAAY,KAAK,SAAS,KAAK,KAAK,UAAU,GAChF,CACA,SAAS/f,EAAK,CACZ,MAAMzH,EAAMyH,EAAI,OACVqe,EAAa,KAAK,aAAe,OACjCoQ,EAAgBC,GAAsB,KAAK,OAAQrQ,CAAU,EAC7DmQ,EAAWxuB,EAAI,IAAI,KAAK,SAAS,EAAE,OACnCtI,EAAU,CAAA,EAChB,QAASZ,EAAI,EAAGA,EAAIyB,EAAKzB,IAAKY,EAAQ,KAAKZ,CAAC,EAC5C,MAAM63B,EAAMtQ,EAAa,GAAK,EAC9B3mB,EAAQ,KAAK,CAACuD,EAAGC,IAAMyzB,EAAMtD,GAAcmD,EAAS,IAAIvzB,CAAC,EAAGuzB,EAAS,IAAItzB,CAAC,CAAC,CAAC,EAC5E,MAAMwW,EAAe,IAAI,WAAWha,CAAO,EACrC6V,EAAcvN,EAAI,QAClBkS,EAA6B,IAAI,IACvC,UAAW/V,KAAQoR,EACjB2E,EAAW,IAAI/V,EAAM6D,EAAI,IAAI7D,CAAI,EAAE,OAAO,KAAKuV,CAAY,CAAC,EAE9D,MAAMkd,EAAW,IAAIxN,GAAUlP,EAAY3E,CAAW,EAChDshB,EAAeJ,EAAc,SAASG,CAAQ,EAC9C30B,EAAU,IAAI,MAAM1B,CAAG,EAC7B,QAASzB,EAAI,EAAGA,EAAIyB,EAAKzB,IACvBmD,EAAQvC,EAAQZ,CAAC,CAAC,EAAI+3B,EAAa,IAAI/3B,CAAC,EAE1C,OAAO,IAAIkD,EAAO,UAAW7C,EAAc,KAAK8C,CAAO,CAAC,CAC1D,CACF,EACA,SAASy0B,GAAsB7uB,EAAMwe,EAAY,CAC/C,GAAIxe,aAAgBurB,GAClB,OAAOvrB,EAAK,eAAewe,CAAU,EAEvC,GAAIxe,aAAgBmuB,GAAuB,CACzC,MAAMS,EAAgBC,GAAsB7uB,EAAK,OAAQwe,CAAU,EACnE,OAAO,IAAI2P,GAAsBS,EAAe5uB,EAAK,cAAiB,CACxE,CACA,OAAOA,CACT,CACA/B,EAAK,UAAU,KAAO,UAAW,CAC/B,OAAO,IAAIwtB,GAAe,IAAI,CAChC,EACAxtB,EAAK,UAAU,UAAY,UAAW,CACpC,OAAO,IAAI6tB,GAAoB,IAAI,CACrC,EACA7tB,EAAK,UAAU,UAAY,UAAW,CACpC,OAAO,IAAI+tB,GAAoB,IAAI,CACrC,EACA/tB,EAAK,UAAU,YAAc,UAAW,CACtC,OAAO,IAAIiuB,GAAsB,IAAI,CACvC,EACAjuB,EAAK,UAAU,MAAQ,SAASvC,EAAG,CACjC,OAAO,IAAI0wB,GAAgB,KAAM1wB,CAAC,CACpC,EACAuC,EAAK,UAAU,OAAS,UAAW,CACjC,OAAO,IAAIwuB,GAAW,IAAI,CAC5B,EACAxuB,EAAK,UAAU,OAAS,UAAW,CACjC,OAAO,IAAIyuB,GAAW,IAAI,CAC5B,EACAzuB,EAAK,UAAU,OAAS,UAAW,CACjC,OAAO,IAAI0uB,GAAW,IAAI,CAC5B,EACA1uB,EAAK,UAAU,QAAU,UAAW,CAClC,OAAO,IAAI2uB,GAAY,IAAI,CAC7B,EACA3uB,EAAK,UAAU,SAAW,UAAW,CACnC,OAAO,IAAI6uB,GAAa,IAAI,CAC9B,EACA7uB,EAAK,UAAU,MAAQ,SAASgd,EAAQ,CACtC,OAAO,IAAI+R,GAAU,KAAM/R,CAAM,CACnC,EACAhd,EAAK,UAAU,KAAO,SAASgd,EAAS,EAAG,CACzC,OAAO,IAAIiS,GAAS,KAAMjS,CAAM,CAClC,EACAhd,EAAK,UAAU,UAAY,SAASgd,EAAS,EAAG,CAC9C,OAAO,IAAIqS,GAAc,KAAMrS,CAAM,CACvC,EACAhd,EAAK,UAAU,YAAc,SAASuvB,EAAY,CAChD,OAAO,IAAIC,GAAgB,KAAMD,CAAU,CAC7C,EACAvvB,EAAK,UAAU,WAAa,SAASuvB,EAAY,CAC/C,OAAO,IAAIE,GAAe,KAAMF,CAAU,CAC5C,EACAvvB,EAAK,UAAU,WAAa,SAASuvB,EAAY,CAC/C,OAAO,IAAIG,GAAe,KAAMH,CAAU,CAC5C,EACAvvB,EAAK,UAAU,WAAa,SAASuvB,EAAY,CAC/C,OAAO,IAAIM,GAAe,KAAMN,CAAU,CAC5C,EACAvvB,EAAK,UAAU,WAAa,SAASuvB,EAAY,CAC/C,OAAO,IAAIO,GAAe,KAAMP,CAAU,CAC5C,EACAvvB,EAAK,UAAU,IAAM,SAASgwB,EAAO,CACnC,OAAO,IAAID,GAAQ,KAAMC,CAAK,CAChC,EACAhwB,EAAK,UAAU,KAAO,YAAYmwB,EAAe,CAC/C,OAAO,IAAID,GAAsB,KAAMC,CAAa,CACtD,EACAnwB,EAAK,UAAU,QAAU,SAAS/H,EAAQgqB,EAAY,MAAO,CAC3D,OAAO,IAAIwO,GAAkB,KAAMx4B,EAAQgqB,CAAS,CACtD,EAGA,SAAS+O,GAAG7pB,EAAM,CAChB,OAAOmc,GAAU,SAASnc,CAAI,CAChC"}