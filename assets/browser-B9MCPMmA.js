function Re(){const e=typeof navigator<"u"&&navigator.hardwareConcurrency?navigator.hardwareConcurrency:2;return Array.from({length:e},()=>({model:"browser"}))}function Te(){return"browser"}function Fe(){return"unknown"}function Le(){return"/tmp"}const Ve=`
`;var Ue={cpus:Re,platform:Te,arch:Fe,tmpdir:Le,EOL:Ve},je=(e=>(e.Float64="f64",e.Int32="i32",e.Int64="i64",e.Utf8="utf8",e.Boolean="bool",e.Date="date",e.DateTime="datetime",e.Null="null",e.BigInt="bigint",e.Object="object",e))(je||{}),Be=(e=>(e.COLUMN_NOT_FOUND="COLUMN_NOT_FOUND",e.TYPE_MISMATCH="TYPE_MISMATCH",e.SHAPE_MISMATCH="SHAPE_MISMATCH",e.PARSE_ERROR="PARSE_ERROR",e.IO_ERROR="IO_ERROR",e.OUT_OF_MEMORY="OUT_OF_MEMORY",e.INVALID_OPERATION="INVALID_OPERATION",e))(Be||{}),F=class extends Error{code;constructor(e,t){super(t),this.name="FrameKitError",this.code=e}},j=class extends F{constructor(e,t){super("COLUMN_NOT_FOUND",`Column '${e}' not found. Available columns: [${t.join(", ")}]`),this.name="ColumnNotFoundError"}},wt=class extends F{constructor(e){super("TYPE_MISMATCH",e),this.name="TypeMismatchError"}},ht=class extends F{constructor(e){super("SHAPE_MISMATCH",e),this.name="ShapeMismatchError"}},nt=class extends F{constructor(e){super("PARSE_ERROR",e),this.name="ParseError"}},A=class extends F{constructor(e){super("IO_ERROR",e),this.name="IOError"}},V=class Rt{_buffer;_length;constructor(t,n=!1){if(t<0)throw new F("INVALID_OPERATION",`BitArray length must be non-negative, got ${t}`);this._length=t;const s=Math.ceil(t/8);this._buffer=new Uint8Array(s),n&&this._buffer.fill(255)}get length(){return this._length}get byteLength(){return this._buffer.byteLength}get(t){return this._boundsCheck(t),this.getUnsafe(t)}getUnsafe(t){const n=t>>3,s=t&7;return(this._buffer[n]&1<<s)!==0}set(t,n){this._boundsCheck(t),this.setUnsafe(t,n)}setUnsafe(t,n){const s=t>>3,r=t&7;n?this._buffer[s]=this._buffer[s]|1<<r:this._buffer[s]=this._buffer[s]&~(1<<r)}countOnes(){let t=0;for(let n=0;n<this._length;n++)this.get(n)&&t++;return t}countZeros(){return this._length-this.countOnes()}and(t){this._lengthCheck(t);const n=new Rt(this._length);for(let s=0;s<this._buffer.length;s++)n._buffer[s]=this._buffer[s]&t._buffer[s];return n}or(t){this._lengthCheck(t);const n=new Rt(this._length);for(let s=0;s<this._buffer.length;s++)n._buffer[s]=this._buffer[s]|t._buffer[s];return n}clone(){const t=new Rt(this._length);return t._buffer.set(this._buffer),t}not(){const t=new Rt(this._length);for(let n=0;n<this._buffer.length;n++)t._buffer[n]=~this._buffer[n]&255;return t}_boundsCheck(t){if(t<0||t>=this._length)throw new F("INVALID_OPERATION",`BitArray index ${t} out of bounds for length ${this._length}`)}_lengthCheck(t){if(this._length!==t._length)throw new F("SHAPE_MISMATCH",`BitArray length mismatch: ${this._length} vs ${t._length}`)}},_t=class{_nullMask;_length;_refCount=1;constructor(e,t){this._length=e,this._nullMask=t??new V(e,!0)}get length(){return this._length}get nullCount(){return this._nullMask.countZeros()}addRef(){this._refCount++}release(){this._refCount>0&&this._refCount--}get refCount(){return this._refCount}get isShared(){return this._refCount>1}},x=class ut extends _t{dtype="f64";_data;_allValid;constructor(t,n){super(t.length,n),this._data=t,this._allValid=n===void 0}get(t){return this._boundsCheck(t),this._allValid?this._data[t]:this._nullMask.getUnsafe(t)?this._data[t]:null}slice(t,n){const s=this._data.subarray(t,n);if(this._allValid)return new ut(s);const r=new V(s.length);for(let o=0;o<s.length;o++)r.setUnsafe(o,this._nullMask.getUnsafe(t+o));return new ut(s,r)}clone(){return this._allValid?new ut(new Float64Array(this._data)):new ut(new Float64Array(this._data),this._nullMask.clone())}filter(t){if(t.length!==this._length)throw new F("SHAPE_MISMATCH",`Filter mask length ${t.length} does not match column length ${this._length}`);const n=[];for(let s=0;s<t.length;s++)t.get(s)===!0&&n.push(s);return this._takeByIndices(n)}take(t){const n=new Float64Array(t.length),s=this._allValid?void 0:new V(t.length);for(let r=0;r<t.length;r++){const o=t[r];n[r]=this._data[o],s&&s.setUnsafe(r,this._nullMask.getUnsafe(o))}return new ut(n,s)}sum(){let t=0;for(let n=0;n<this._length;n++)this._nullMask.getUnsafe(n)&&(t+=this._data[n]);return t}mean(){const t=this._length-this.nullCount;return t===0?null:this.sum()/t}min(){let t=null;for(let n=0;n<this._length;n++)if(this._nullMask.getUnsafe(n)){const s=this._data[n];(t===null||s<t)&&(t=s)}return t}max(){let t=null;for(let n=0;n<this._length;n++)if(this._nullMask.getUnsafe(n)){const s=this._data[n];(t===null||s>t)&&(t=s)}return t}estimatedMemoryBytes(){return this._length*8+this._nullMask.byteLength}static from(t){const n=new Float64Array(t.length),s=new V(t.length);let r=!1;for(let o=0;o<t.length;o++){const i=t[o];i!=null?(n[o]=i,s.setUnsafe(o,!0)):r=!0}return r?new ut(n,s):new ut(n)}_boundsCheck(t){if(t<0||t>=this._length)throw new F("INVALID_OPERATION",`Index ${t} out of bounds for column of length ${this._length}`)}_takeByIndices(t){const n=new Float64Array(t.length),s=new V(t.length);for(let r=0;r<t.length;r++){const o=t[r];n[r]=this._data[o],s.setUnsafe(r,this._nullMask.getUnsafe(o))}return new ut(n,s)}},lt=class at extends _t{dtype="i32";_data;_allValid;constructor(t,n){super(t.length,n),this._data=t,this._allValid=n===void 0}get(t){return this._boundsCheck(t),this._allValid?this._data[t]:this._nullMask.getUnsafe(t)?this._data[t]:null}slice(t,n){const s=this._data.subarray(t,n);if(this._allValid)return new at(s);const r=new V(s.length);for(let o=0;o<s.length;o++)r.setUnsafe(o,this._nullMask.getUnsafe(t+o));return new at(s,r)}clone(){return this._allValid?new at(new Int32Array(this._data)):new at(new Int32Array(this._data),this._nullMask.clone())}filter(t){if(t.length!==this._length)throw new F("SHAPE_MISMATCH",`Filter mask length ${t.length} does not match column length ${this._length}`);const n=[];for(let s=0;s<t.length;s++)t.get(s)===!0&&n.push(s);return this._takeByIndices(n)}take(t){const n=new Int32Array(t.length),s=this._allValid?void 0:new V(t.length);for(let r=0;r<t.length;r++){const o=t[r];n[r]=this._data[o],s&&s.setUnsafe(r,this._nullMask.getUnsafe(o))}return new at(n,s)}sum(){let t=0;for(let n=0;n<this._length;n++)this._nullMask.getUnsafe(n)&&(t+=this._data[n]);return t}mean(){const t=this._length-this.nullCount;return t===0?null:this.sum()/t}min(){let t=null;for(let n=0;n<this._length;n++)if(this._nullMask.getUnsafe(n)){const s=this._data[n];(t===null||s<t)&&(t=s)}return t}max(){let t=null;for(let n=0;n<this._length;n++)if(this._nullMask.getUnsafe(n)){const s=this._data[n];(t===null||s>t)&&(t=s)}return t}estimatedMemoryBytes(){return this._length*4+this._nullMask.byteLength}static from(t){const n=new Int32Array(t.length),s=new V(t.length);let r=!1;for(let o=0;o<t.length;o++){const i=t[o];i!=null?(n[o]=i,s.setUnsafe(o,!0)):r=!0}return r?new at(n,s):new at(n)}_boundsCheck(t){if(t<0||t>=this._length)throw new F("INVALID_OPERATION",`Index ${t} out of bounds for column of length ${this._length}`)}_takeByIndices(t){const n=new Int32Array(t.length),s=new V(t.length);for(let r=0;r<t.length;r++){const o=t[r];n[r]=this._data[o],s.setUnsafe(r,this._nullMask.getUnsafe(o))}return new at(n,s)}},q=class W extends _t{dtype="utf8";_data;_interned;_allValid;constructor(t,n,s){super(t.length,n),s?(this._data=null,this._interned=s):(this._data=t,this._interned=null),this._allValid=n===void 0}get isInterned(){return this._interned!==null}get(t){return this._boundsCheck(t),this._allValid?this._interned?this._interned.dictionary[this._interned.indices[t]]:this._data[t]:this._nullMask.getUnsafe(t)?this._interned?this._interned.dictionary[this._interned.indices[t]]:this._data[t]:null}slice(t,n){const s=n-t;if(this._allValid){if(this._interned){const i=this._interned.indices.slice(t,n);return new W(new Array(s),void 0,{dictionary:this._interned.dictionary,indices:i})}return new W(this._data.slice(t,n))}const r=new V(s);for(let i=0;i<s;i++)r.setUnsafe(i,this._nullMask.getUnsafe(t+i));if(this._interned){const i=this._interned.indices.slice(t,n);return new W(new Array(s),r,{dictionary:this._interned.dictionary,indices:i})}const o=this._data.slice(t,n);return new W(o,r)}clone(){return this._allValid?this._interned?new W(new Array(this._length),void 0,{dictionary:[...this._interned.dictionary],indices:new Uint32Array(this._interned.indices)}):new W([...this._data]):this._interned?new W(new Array(this._length),this._nullMask.clone(),{dictionary:[...this._interned.dictionary],indices:new Uint32Array(this._interned.indices)}):new W([...this._data],this._nullMask.clone())}filter(t){if(t.length!==this._length)throw new F("SHAPE_MISMATCH",`Filter mask length ${t.length} does not match column length ${this._length}`);const n=[];for(let s=0;s<t.length;s++)t.get(s)===!0&&n.push(s);return this._takeByIndices(n)}take(t){const n=t.length,s=this._allValid?void 0:new V(n);if(this._interned){const o=new Uint32Array(n);for(let i=0;i<n;i++){const l=t[i];o[i]=this._interned.indices[l],s&&s.setUnsafe(i,this._nullMask.getUnsafe(l))}return new W(new Array(n),s,{dictionary:this._interned.dictionary,indices:o})}const r=new Array(n);for(let o=0;o<n;o++){const i=t[o];r[o]=this._data[i],s&&s.setUnsafe(o,this._nullMask.getUnsafe(i))}return new W(r,s)}estimatedMemoryBytes(){let t=this._nullMask.byteLength;if(this._interned){for(const n of this._interned.dictionary)t+=n.length*2;t+=this._interned.indices.byteLength}else for(let n=0;n<this._length;n++)this._nullMask.get(n)&&(t+=this._data[n].length*2);return t}static from(t){const n=t.length,s=new Array(n),r=new V(n);let o=!1;for(let i=0;i<n;i++){const l=t[i];l!=null?(s[i]=l,r.set(i,!0)):(s[i]="",o=!0)}if(n>0){const i=new Set;let l=0;for(let c=0;c<n;c++)r.getUnsafe(c)&&(i.add(s[c]),l++);if(l>0&&i.size<n*.5){const c=Array.from(i),u=new Map;for(let a=0;a<c.length;a++)u.set(c[a],a);const f=new Uint32Array(n);for(let a=0;a<n;a++)r.getUnsafe(a)&&(f[a]=u.get(s[a]));return o?new W(s,r,{dictionary:c,indices:f}):new W(s,void 0,{dictionary:c,indices:f})}}return o?new W(s,r):new W(s)}_boundsCheck(t){if(t<0||t>=this._length)throw new F("INVALID_OPERATION",`Index ${t} out of bounds for column of length ${this._length}`)}_takeByIndices(t){const n=t.length,s=new V(n);if(this._interned){const o=new Uint32Array(n);for(let i=0;i<n;i++){const l=t[i];o[i]=this._interned.indices[l],s.setUnsafe(i,this._nullMask.getUnsafe(l))}return new W(new Array(n),s,{dictionary:this._interned.dictionary,indices:o})}const r=new Array(n);for(let o=0;o<n;o++){const i=t[o];r[o]=this._data[i],s.setUnsafe(o,this._nullMask.getUnsafe(i))}return new W(r,s)}},L=class xt extends _t{dtype="bool";_data;constructor(t,n){super(t.length,n),this._data=t}get(t){return this._boundsCheck(t),this._nullMask.getUnsafe(t)?this._data[t]!==0:null}slice(t,n){const s=this._data.subarray(t,n),r=new V(s.length);for(let o=0;o<s.length;o++)r.setUnsafe(o,this._nullMask.getUnsafe(t+o));return new xt(s,r)}clone(){return new xt(new Uint8Array(this._data),this._nullMask.clone())}filter(t){if(t.length!==this._length)throw new F("SHAPE_MISMATCH",`Filter mask length ${t.length} does not match column length ${this._length}`);const n=[];for(let s=0;s<t.length;s++)t.get(s)===!0&&n.push(s);return this._takeByIndices(n)}take(t){const n=new Uint8Array(t.length),s=new V(t.length);for(let r=0;r<t.length;r++){const o=t[r];n[r]=this._data[o],s.setUnsafe(r,this._nullMask.getUnsafe(o))}return new xt(n,s)}estimatedMemoryBytes(){return this._length+this._nullMask.byteLength}static from(t){const n=new Uint8Array(t.length),s=new V(t.length);for(let r=0;r<t.length;r++){const o=t[r];o!=null&&(n[r]=o?1:0,s.setUnsafe(r,!0))}return new xt(n,s)}_boundsCheck(t){if(t<0||t>=this._length)throw new F("INVALID_OPERATION",`Index ${t} out of bounds for column of length ${this._length}`)}_takeByIndices(t){const n=new Uint8Array(t.length),s=new V(t.length);for(let r=0;r<t.length;r++){const o=t[r];n[r]=this._data[o],s.setUnsafe(r,this._nullMask.getUnsafe(o))}return new xt(n,s)}},H=class Nt extends _t{dtype="date";_data;constructor(t,n){super(t.length,n),this._data=t}get(t){return this._boundsCheck(t),this._nullMask.getUnsafe(t)?new Date(this._data[t]):null}slice(t,n){const s=this._data.subarray(t,n),r=new V(s.length);for(let o=0;o<s.length;o++)r.setUnsafe(o,this._nullMask.getUnsafe(t+o));return new Nt(s,r)}clone(){return new Nt(new Float64Array(this._data),this._nullMask.clone())}filter(t){if(t.length!==this._length)throw new F("SHAPE_MISMATCH",`Filter mask length ${t.length} does not match column length ${this._length}`);const n=[];for(let s=0;s<t.length;s++)t.get(s)===!0&&n.push(s);return this._takeByIndices(n)}take(t){const n=new Float64Array(t.length),s=new V(t.length);for(let r=0;r<t.length;r++){const o=t[r];n[r]=this._data[o],s.setUnsafe(r,this._nullMask.getUnsafe(o))}return new Nt(n,s)}estimatedMemoryBytes(){return this._length*8+this._nullMask.byteLength}static from(t){const n=new Float64Array(t.length),s=new V(t.length);for(let r=0;r<t.length;r++){const o=t[r];o!=null&&(n[r]=o.getTime(),s.setUnsafe(r,!0))}return new Nt(n,s)}_boundsCheck(t){if(t<0||t>=this._length)throw new F("INVALID_OPERATION",`Index ${t} out of bounds for column of length ${this._length}`)}_takeByIndices(t){const n=new Float64Array(t.length),s=new V(t.length);for(let r=0;r<t.length;r++){const o=t[r];n[r]=this._data[o],s.setUnsafe(r,this._nullMask.getUnsafe(o))}return new Nt(n,s)}},gt=class kt extends _t{dtype="object";_data;constructor(t,n){super(t.length,n),this._data=t}get(t){return this._boundsCheck(t),this._nullMask.getUnsafe(t)?this._data[t]:null}slice(t,n){const s=this._data.slice(t,n),r=new V(s.length);for(let o=0;o<s.length;o++)r.setUnsafe(o,this._nullMask.getUnsafe(t+o));return new kt(s,r)}clone(){return new kt([...this._data],this._nullMask.clone())}filter(t){if(t.length!==this._length)throw new F("SHAPE_MISMATCH",`Filter mask length ${t.length} does not match column length ${this._length}`);const n=[];for(let s=0;s<t.length;s++)t.get(s)===!0&&n.push(s);return this._takeByIndices(n)}take(t){const n=new Array(t.length),s=new V(t.length);for(let r=0;r<t.length;r++){const o=t[r];n[r]=this._data[o],s.setUnsafe(r,this._nullMask.getUnsafe(o))}return new kt(n,s)}estimatedMemoryBytes(){return this._length*8+this._nullMask.byteLength}static from(t){const n=new Array(t.length),s=new V(t.length);for(let r=0;r<t.length;r++){const o=t[r];o!=null?(n[r]=o,s.setUnsafe(r,!0)):n[r]=null}return new kt(n,s)}_boundsCheck(t){if(t<0||t>=this._length)throw new F("INVALID_OPERATION",`Index ${t} out of bounds for column of length ${this._length}`)}_takeByIndices(t){const n=new Array(t.length),s=new V(t.length);for(let r=0;r<t.length;r++){const o=t[r];n[r]=this._data[o],s.setUnsafe(r,this._nullMask.getUnsafe(o))}return new kt(n,s)}},Pe=class{_series;constructor(e){if(e.dtype!=="utf8")throw new wt(`StringAccessor requires Series with dtype Utf8, got '${e.dtype}'`);this._series=e}toLowerCase(){return this._mapString(e=>e.toLowerCase())}toUpperCase(){return this._mapString(e=>e.toUpperCase())}trim(){return this._mapString(e=>e.trim())}startsWith(e){return this._mapBoolean(t=>t.startsWith(e))}endsWith(e){return this._mapBoolean(t=>t.endsWith(e))}contains(e){return this._mapBoolean(t=>t.includes(e))}replace(e,t){return this._mapString(n=>n.replaceAll(e,t))}split(e){const t=[],n=new V(this._series.length);for(let r=0;r<this._series.length;r++){const o=this._series.get(r);o===null?t.push([]):(t.push(o.split(e)),n.set(r,!0))}const s=new qe(t,n);return new N(this._series.name,s)}slice(e,t){return this._mapString(n=>n.slice(e,t))}length(){const e=[];for(let t=0;t<this._series.length;t++){const n=this._series.get(t);n===null?e.push(null):e.push(n.length)}return new N(this._series.name,x.from(e))}padStart(e,t){return this._mapString(n=>n.padStart(e,t))}padEnd(e,t){return this._mapString(n=>n.padEnd(e,t))}extract(e){const t=e.source;if(!t.includes("(")||t.replace(/\\\(/g,"").indexOf("(")===-1)throw new wt("extract() pattern must contain at least one capture group");const n=[];for(let s=0;s<this._series.length;s++){const r=this._series.get(s);if(r===null)n.push(null);else{const o=r.match(e);o&&o[1]!==void 0?n.push(o[1]):n.push(null)}}return new N(this._series.name,q.from(n))}_mapString(e){const t=[];for(let n=0;n<this._series.length;n++){const s=this._series.get(n);s===null?t.push(null):t.push(e(s))}return new N(this._series.name,q.from(t))}_mapBoolean(e){const t=[];for(let n=0;n<this._series.length;n++){const s=this._series.get(n);s===null?t.push(null):t.push(e(s))}return new N(this._series.name,L.from(t))}},qe=class Vt extends _t{dtype="utf8";_data;constructor(t,n){super(t.length,n),this._data=t}get(t){if(t<0||t>=this._length)throw new Error(`Index ${t} out of bounds for column of length ${this._length}`);return this._nullMask.get(t)?this._data[t]:null}slice(t,n){const s=this._data.slice(t,n),r=new V(s.length);for(let o=0;o<s.length;o++)r.set(o,this._nullMask.get(t+o));return new Vt(s,r)}clone(){return new Vt(this._data.map(t=>[...t]),this._nullMask.clone())}filter(t){const n=[];for(let s=0;s<t.length;s++)t.get(s)===!0&&n.push(s);return this._takeByIndices(n)}take(t){const n=[];for(let s=0;s<t.length;s++)n.push(t[s]);return this._takeByIndices(n)}estimatedMemoryBytes(){let t=this._nullMask.byteLength;for(let n=0;n<this._length;n++)if(this._nullMask.get(n))for(const s of this._data[n])t+=s.length*2;return t}_takeByIndices(t){const n=[],s=new V(t.length);for(let r=0;r<t.length;r++){const o=t[r];n.push(this._data[o]),s.set(r,this._nullMask.get(o))}return new Vt(n,s)}},We=class{_series;constructor(e){if(e.dtype!=="date")throw new wt(`DateAccessor requires Series with dtype Date, got '${e.dtype}'`);this._series=e}year(){return this._mapNumber(e=>e.getFullYear())}month(){return this._mapNumber(e=>e.getMonth()+1)}day(){return this._mapNumber(e=>e.getDate())}hour(){return this._mapNumber(e=>e.getHours())}minute(){return this._mapNumber(e=>e.getMinutes())}second(){return this._mapNumber(e=>e.getSeconds())}dayOfWeek(){return this._mapNumber(e=>e.getDay())}dayOfYear(){return this._mapNumber(e=>{const t=new Date(e.getFullYear(),0,0),n=e.getTime()-t.getTime(),s=1e3*60*60*24;return Math.floor(n/s)})}weekNumber(){return this._mapNumber(e=>{const t=new Date(e.getTime());t.setHours(0,0,0,0),t.setDate(t.getDate()+3-(t.getDay()+6)%7);const n=new Date(t.getFullYear(),0,4),s=(t.getTime()-n.getTime())/(1e3*60*60*24);return 1+Math.round((s-3+(n.getDay()+6)%7)/7)})}quarter(){return this._mapNumber(e=>Math.floor(e.getMonth()/3)+1)}timestamp(){return this._mapNumber(e=>e.getTime())}format(e){const t=[];for(let n=0;n<this._series.length;n++){const s=this._series.get(n);s===null?t.push(null):t.push(ze(s,e))}return new N(this._series.name,q.from(t))}diff(e,t){if(e.dtype!=="date")throw new wt(`diff() requires a Date Series, got '${e.dtype}'`);if(e.length!==this._series.length)throw new wt(`diff() requires Series of equal length, got ${this._series.length} and ${e.length}`);const n=[];for(let s=0;s<this._series.length;s++){const r=this._series.get(s),o=e.get(s);r===null||o===null?n.push(null):n.push(Ke(r,o,t))}return new N(this._series.name,x.from(n))}truncate(e){const t=[];for(let n=0;n<this._series.length;n++){const s=this._series.get(n);s===null?t.push(null):t.push(He(s,e))}return new N(this._series.name,H.from(t))}_mapNumber(e){const t=[];for(let n=0;n<this._series.length;n++){const s=this._series.get(n);s===null?t.push(null):t.push(e(s))}return new N(this._series.name,x.from(t))}};function ze(e,t){const n=r=>String(r).padStart(2,"0"),s=r=>String(r).padStart(4,"0");return t.replace("YYYY",s(e.getFullYear())).replace("MM",n(e.getMonth()+1)).replace("DD",n(e.getDate())).replace("HH",n(e.getHours())).replace("mm",n(e.getMinutes())).replace("ss",n(e.getSeconds()))}function Ke(e,t,n){const s=e.getTime(),o=t.getTime()-s;switch(n){case"second":return o/1e3;case"minute":return o/(1e3*60);case"hour":return o/(1e3*60*60);case"day":return o/(1e3*60*60*24);case"month":{const i=t.getFullYear()-e.getFullYear(),l=t.getMonth()-e.getMonth(),c=(t.getDate()-e.getDate())/30;return i*12+l+c}case"year":{const i=t.getFullYear()-e.getFullYear(),l=(t.getMonth()-e.getMonth())/12,c=(t.getDate()-e.getDate())/365;return i+l+c}}}function He(e,t){switch(t){case"year":return new Date(e.getFullYear(),0,1);case"month":return new Date(e.getFullYear(),e.getMonth(),1);case"day":return new Date(e.getFullYear(),e.getMonth(),e.getDate());case"hour":return new Date(e.getFullYear(),e.getMonth(),e.getDate(),e.getHours());case"minute":return new Date(e.getFullYear(),e.getMonth(),e.getDate(),e.getHours(),e.getMinutes());case"second":return new Date(e.getFullYear(),e.getMonth(),e.getDate(),e.getHours(),e.getMinutes(),e.getSeconds())}}var Ht;function Je(e){Ht=e}var N=class G{_name;_column;constructor(t,n){this._name=t,this._column=n}get name(){return this._name}get dtype(){return this._column.dtype}get length(){return this._column.length}get nullCount(){return this._column.nullCount}get column(){return this._column}get str(){return new Pe(this)}get dt(){return new We(this)}get(t){return this._column.get(t)}toArray(){const t=[];for(let n=0;n<this._column.length;n++)t.push(this._column.get(n));return t}sum(){return this._asNumericColumn().sum()}mean(){return this._asNumericColumn().mean()}min(){return this._asNumericColumn().min()}max(){return this._asNumericColumn().max()}std(){const t=this._asNumericColumn(),n=t.mean();if(n===null)return null;const s=t.length-t.nullCount;if(s<2)return null;let r=0;for(let o=0;o<t.length;o++){const i=t.get(o);if(i!==null){const l=i-n;r+=l*l}}return Math.sqrt(r/(s-1))}median(){const t=this._asNumericColumn(),n=[];for(let r=0;r<t.length;r++){const o=t.get(r);o!==null&&n.push(o)}if(n.length===0)return null;n.sort((r,o)=>r-o);const s=Math.floor(n.length/2);return n.length%2===0?(n[s-1]+n[s])/2:n[s]}between(t,n){const s=this._asNumericColumn(),r=[];for(let o=0;o<s.length;o++){const i=s.get(o);i===null?r.push(null):r.push(i>=t&&i<=n)}return new G(this._name,L.from(r))}cumSum(){const t=this._asNumericColumn(),n=[];let s=0;for(let r=0;r<t.length;r++){const o=t.get(r);o===null?n.push(null):(s+=o,n.push(s))}return new G(this._name,x.from(n))}abs(){const t=this._asNumericColumn(),n=[];for(let s=0;s<t.length;s++){const r=t.get(s);r===null?n.push(null):n.push(Math.abs(r))}return new G(this._name,x.from(n))}round(t=0){const n=this._asNumericColumn(),s=Math.pow(10,t),r=[];for(let o=0;o<n.length;o++){const i=n.get(o);i===null?r.push(null):r.push(Math.round(i*s)/s)}return new G(this._name,x.from(r))}eq(t){return this._compareScalar(t,(n,s)=>n===s)}neq(t){return this._compareScalar(t,(n,s)=>n!==s)}gt(t){return this._compareScalar(t,(n,s)=>n>s)}gte(t){return this._compareScalar(t,(n,s)=>n>=s)}lt(t){return this._compareScalar(t,(n,s)=>n<s)}lte(t){return this._compareScalar(t,(n,s)=>n<=s)}isIn(t){const n=new Set(t.map(r=>this._toComparable(r))),s=[];for(let r=0;r<this._column.length;r++){const o=this._column.get(r);o===null?s.push(null):s.push(n.has(this._toComparable(o)))}return new G(this._name,L.from(s))}isNull(){const t=[];for(let n=0;n<this._column.length;n++)t.push(this._column.get(n)===null);return new G(this._name,L.from(t))}isNotNull(){const t=[];for(let n=0;n<this._column.length;n++)t.push(this._column.get(n)!==null);return new G(this._name,L.from(t))}fillNull(t){const s=this.toArray().map(r=>r===null?t:r);return new G(this._name,this._buildColumn(s))}unique(){const t=new Set,n=[];for(let s=0;s<this._column.length;s++){const r=this._column.get(s),o=r===null?"__null__":String(this._toComparable(r));t.has(o)||(t.add(o),n.push(r))}return new G(this._name,this._buildColumn(n))}nUnique(){const t=new Set;for(let n=0;n<this._column.length;n++){const s=this._column.get(n),r=s===null?"__null__":String(this._toComparable(s));t.add(r)}return t.size}valueCounts(){if(!Ht)throw new F("INVALID_OPERATION","DataFrame factory not registered");const t=new Map,n=[];for(let c=0;c<this._column.length;c++){const u=this._column.get(c),f=u===null?"__null__":String(this._toComparable(u)),a=t.get(f);a?a.count++:(t.set(f,{value:u,count:1}),n.push(f))}n.sort((c,u)=>t.get(u).count-t.get(c).count);const s=[],r=[];for(const c of n){const u=t.get(c);s.push(u.value),r.push(u.count)}const o=this._buildColumn(s),i=x.from(r),l=new Map;return l.set("value",o),l.set("count",i),Ht(l,["value","count"])}cast(t){const s=this.toArray().map(o=>o===null?null:this._castValue(o,t)),r=te(t,s);return new G(this._name,r)}apply(t){const n=[];for(let o=0;o<this._column.length;o++)n.push(t(this._column.get(o)));let s="f64";for(const o of n)if(o!==null){typeof o=="string"?s="utf8":typeof o=="boolean"?s="bool":o instanceof Date?s="date":s="f64";break}const r=te(s,n);return new G(this._name,r)}_asNumericColumn(){if(this._column instanceof x)return this._column;if(this._column instanceof lt)return this._column;throw new wt(`Cannot perform numeric operation on Series with dtype '${this.dtype}'`)}_compareScalar(t,n){const s=[];for(let r=0;r<this._column.length;r++){const o=this._column.get(r);o===null?s.push(null):s.push(n(o,t))}return new G(this._name,L.from(s))}_toComparable(t){return t instanceof Date?t.getTime():t}_buildColumn(t){switch(this._column.dtype){case"f64":return x.from(t);case"i32":return lt.from(t);case"utf8":return q.from(t);case"bool":return L.from(t);case"date":return H.from(t);case"object":return gt.from(t);default:throw new F("INVALID_OPERATION",`Unsupported dtype: ${this._column.dtype}`)}}_castValue(t,n){switch(n){case"f64":case"i32":return typeof t=="number"?t:typeof t=="string"?Number(t):typeof t=="boolean"?t?1:0:t instanceof Date?t.getTime():Number(t);case"utf8":return t instanceof Date?t.toISOString():String(t);case"bool":return!!t;case"date":return t instanceof Date?t:typeof t=="number"?new Date(t):typeof t=="string"?new Date(t):new Date(String(t));default:throw new wt(`Cannot cast to dtype '${n}'`)}}};function te(e,t){switch(e){case"f64":return x.from(t);case"i32":return lt.from(t);case"utf8":return q.from(t);case"bool":return L.from(t);case"date":return H.from(t);case"object":return gt.from(t);default:throw new F("INVALID_OPERATION",`Unsupported dtype for column construction: ${e}`)}}var C=class Jt{as(t){return new Ye(this,t)}add(t){return new bt(this,St(t),"add")}sub(t){return new bt(this,St(t),"sub")}mul(t){return new bt(this,St(t),"mul")}div(t){return new bt(this,St(t),"div")}mod(t){return new bt(this,St(t),"mod")}pow(t){return new bt(this,St(t),"pow")}eq(t){return new Ct(this,yt(t),"eq")}neq(t){return new Ct(this,yt(t),"neq")}gt(t){return new Ct(this,yt(t),"gt")}gte(t){return new Ct(this,yt(t),"gte")}lt(t){return new Ct(this,yt(t),"lt")}lte(t){return new Ct(this,yt(t),"lte")}and(t){return new ne(this,ee(t),"and")}or(t){return new ne(this,ee(t),"or")}not(){return new tn(this)}_aggColumnName(){const t=this.dependencies;if(t.length===0)throw new Error("Aggregation requires a column reference");return t[0]}sum(){return new we(this._aggColumnName())}mean(){return new en(this._aggColumnName())}count(){return new nn(this._aggColumnName())}countDistinct(){return new sn(this._aggColumnName())}min(){return new rn(this._aggColumnName())}max(){return new on(this._aggColumnName())}std(){return new ln(this._aggColumnName())}first(){return new cn(this._aggColumnName())}last(){return new un(this._aggColumnName())}list(){return new an(this._aggColumnName())}mode(){return new fn(this._aggColumnName())}coalesce(...t){const n=t.map(s=>s instanceof Jt?s:new Q(s));return new hn([this,...n])}fillNull(t){const n=t instanceof Jt?t:new Q(t);return new gn(this,n)}isNull(){return new pn(this)}isNotNull(){return new mn(this)}},Ye=class{expr;name;constructor(e,t){this.expr=e,this.name=t}get dependencies(){return this.expr.dependencies}toString(){return`${this.expr.toString()} AS ${this.name}`}};function yt(e){return e instanceof C?e:new Q(e)}function St(e){return e instanceof C?e:new Q(e)}function ee(e){return e instanceof C?e:new Q(e)}function Qt(e,t){switch(e){case"f64":return x.from(t);case"utf8":return q.from(t);case"bool":return L.from(t);case"date":return H.from(t);default:return x.from(t)}}function Ge(e){return typeof e=="number"?"f64":typeof e=="string"?"utf8":typeof e=="boolean"?"bool":e instanceof Date?"date":"f64"}var Q=class extends C{_value;constructor(e){super(),this._value=e}get dependencies(){return[]}toString(){return typeof this._value=="string"?`"${this._value}"`:this._value instanceof Date?this._value.toISOString():String(this._value)}evaluate(e){const t=e.length,n=new Array(t).fill(this._value),s=Ge(this._value),r=Qt(s,n);return new N("literal",r)}},jt=class extends C{_name;constructor(e){super(),this._name=e}get dependencies(){return[this._name]}toString(){return this._name}evaluate(e){return e.col(this._name)}},Qe={add:"+",sub:"-",mul:"*",div:"/",mod:"%",pow:"**"},bt=class extends C{_left;_right;_op;constructor(e,t,n){super(),this._left=e,this._right=t,this._op=n}get dependencies(){return[...new Set([...this._left.dependencies,...this._right.dependencies])]}toString(){return`(${this._left.toString()} ${Qe[this._op]} ${this._right.toString()})`}evaluate(e){const t=this._left.evaluate(e),n=this._right.evaluate(e),s=t.length,r=[];for(let o=0;o<s;o++){const i=t.get(o),l=n.get(o);i===null||l===null?r.push(null):r.push(Ze(i,l,this._op))}return new N("",x.from(r))}};function Ze(e,t,n){switch(n){case"add":return e+t;case"sub":return e-t;case"mul":return e*t;case"div":return e/t;case"mod":return e%t;case"pow":return Math.pow(e,t)}}var Xe={eq:"==",neq:"!=",gt:">",gte:">=",lt:"<",lte:"<="},Ct=class extends C{_left;_right;_op;constructor(e,t,n){super(),this._left=e,this._right=t,this._op=n}get dependencies(){return[...new Set([...this._left.dependencies,...this._right.dependencies])]}toString(){return`(${this._left.toString()} ${Xe[this._op]} ${this._right.toString()})`}evaluate(e){if(this._left instanceof jt&&this._right instanceof Q){const o=this._left.dependencies[0],i=this._right._value,l=e.col(o).column,c=l.length,u=new Array(c);for(let f=0;f<c;f++){const a=l.get(f);a===null||i===null?u[f]=null:u[f]=Pt(a,i,this._op)}return new N("",L.from(u))}if(this._left instanceof Q&&this._right instanceof jt){const o=this._left._value,i=this._right.dependencies[0],l=e.col(i).column,c=l.length,u=new Array(c);for(let f=0;f<c;f++){const a=l.get(f);o===null||a===null?u[f]=null:u[f]=Pt(o,a,this._op)}return new N("",L.from(u))}const t=this._left.evaluate(e),n=this._right.evaluate(e),s=t.length,r=new Array(s);for(let o=0;o<s;o++){const i=t.get(o),l=n.get(o);i===null||l===null?r[o]=null:r[o]=Pt(i,l,this._op)}return new N("",L.from(r))}};function Pt(e,t,n){switch(n){case"eq":return e===t;case"neq":return e!==t;case"gt":return e>t;case"gte":return e>=t;case"lt":return e<t;case"lte":return e<=t}}var ne=class extends C{_left;_right;_op;constructor(e,t,n){super(),this._left=e,this._right=t,this._op=n}get dependencies(){return[...new Set([...this._left.dependencies,...this._right.dependencies])]}toString(){return`(${this._left.toString()} ${this._op.toUpperCase()} ${this._right.toString()})`}evaluate(e){const t=this._left.evaluate(e),n=this._right.evaluate(e),s=t.length,r=[];for(let o=0;o<s;o++){const i=t.get(o),l=n.get(o);i===null||l===null?r.push(null):this._op==="and"?r.push(i&&l):r.push(i||l)}return new N("",L.from(r))}},tn=class extends C{_inner;constructor(e){super(),this._inner=e}get dependencies(){return this._inner.dependencies}toString(){return`NOT ${this._inner.toString()}`}evaluate(e){const t=this._inner.evaluate(e),n=t.length,s=[];for(let r=0;r<n;r++){const o=t.get(r);s.push(o===null?null:!o)}return new N("",L.from(s))}};function st(e){return new jt(e)}function K(e){return new Q(e)}function de(e){return e instanceof Date?`\0date${e.getTime()}`:typeof e=="string"?`\0str${e}`:typeof e=="number"?`\0num${e}`:typeof e=="boolean"?`\0bool${e}`:`\0other${String(e)}`}var rt=class extends C{_columnName;constructor(e){super(),this._columnName=e}get dependencies(){return[this._columnName]}toString(){return`${this._aggName}(${this._columnName})`}evaluate(e){const n=[this.evaluateFrame(e)],s=x.from(n);return new N("",s)}evaluateFrame(e){const t=e.col(this._columnName);return this.evaluateColumn(t.column)}},we=class extends rt{_aggName="sum";evaluateColumn(e){let t=0;for(let n=0;n<e.length;n++){const s=e.get(n);s!==null&&typeof s=="number"&&(t+=s)}return t}},en=class extends rt{_aggName="mean";evaluateColumn(e){let t=0,n=0;for(let s=0;s<e.length;s++){const r=e.get(s);r!==null&&typeof r=="number"&&(t+=r,n++)}return n===0?null:t/n}},nn=class extends rt{_aggName="count";evaluateColumn(e){let t=0;for(let n=0;n<e.length;n++)e.get(n)!==null&&t++;return t}},sn=class extends rt{_aggName="count_distinct";evaluateColumn(e){const t=new Set;for(let n=0;n<e.length;n++){const s=e.get(n);s!==null&&t.add(de(s))}return t.size}},rn=class extends rt{_aggName="min";evaluateColumn(e){let t=null;for(let n=0;n<e.length;n++){const s=e.get(n);s!==null&&typeof s=="number"&&(t===null||s<t)&&(t=s)}return t}},on=class extends rt{_aggName="max";evaluateColumn(e){let t=null;for(let n=0;n<e.length;n++){const s=e.get(n);s!==null&&typeof s=="number"&&(t===null||s>t)&&(t=s)}return t}},ln=class extends rt{_aggName="std";evaluateColumn(e){const t=[];for(let r=0;r<e.length;r++){const o=e.get(r);o!==null&&typeof o=="number"&&t.push(o)}if(t.length<2)return null;const n=t.reduce((r,o)=>r+o,0)/t.length,s=t.reduce((r,o)=>r+(o-n)**2,0);return Math.sqrt(s/(t.length-1))}},cn=class extends rt{_aggName="first";evaluateColumn(e){for(let t=0;t<e.length;t++){const n=e.get(t);if(n!==null)return n}return null}},un=class extends rt{_aggName="last";evaluateColumn(e){for(let t=e.length-1;t>=0;t--){const n=e.get(t);if(n!==null)return n}return null}},an=class extends rt{_aggName="list";evaluateColumn(e){const t=[];for(let n=0;n<e.length;n++){const s=e.get(n);s!==null&&t.push(s)}return t}},fn=class extends rt{_aggName="mode";evaluateColumn(e){const t=new Map;for(let r=0;r<e.length;r++){const o=e.get(r);if(o!==null){const i=de(o),l=t.get(i);l?l.count++:t.set(i,{value:o,count:1})}}let n=null,s=0;for(const r of t.values())r.count>s&&(n=r.value,s=r.count);return n}},hn=class extends C{_exprs;constructor(e){super(),this._exprs=e}get dependencies(){const e=new Set;for(const t of this._exprs)for(const n of t.dependencies)e.add(n);return[...e]}toString(){return`coalesce(${this._exprs.map(e=>e.toString()).join(", ")})`}evaluate(e){const t=this._exprs.map(l=>l.evaluate(e)),n=t[0].length,s=[];for(let l=0;l<n;l++){let c=null;for(const u of t){const f=u.get(l);if(f!==null){c=f;break}}s.push(c)}const o=t[0].column.dtype,i=Qt(o,s);return new N("",i)}},gn=class extends C{_inner;_fill;constructor(e,t){super(),this._inner=e,this._fill=t}get dependencies(){return[...new Set([...this._inner.dependencies,...this._fill.dependencies])]}toString(){return`fillNull(${this._inner.toString()}, ${this._fill.toString()})`}evaluate(e){const t=this._inner.evaluate(e),n=this._fill.evaluate(e),s=t.length,r=[];for(let l=0;l<s;l++){const c=t.get(l);r.push(c!==null?c:n.get(l))}const o=t.column.dtype,i=Qt(o,r);return new N("",i)}},pn=class extends C{_inner;constructor(e){super(),this._inner=e}get dependencies(){return this._inner.dependencies}toString(){return`${this._inner.toString()} IS NULL`}evaluate(e){const t=this._inner.evaluate(e),n=t.length,s=[];for(let r=0;r<n;r++)s.push(t.get(r)===null);return new N("",L.from(s))}},mn=class extends C{_inner;constructor(e){super(),this._inner=e}get dependencies(){return this._inner.dependencies}toString(){return`${this._inner.toString()} IS NOT NULL`}evaluate(e){const t=this._inner.evaluate(e),n=t.length,s=[];for(let r=0;r<n;r++)s.push(t.get(r)!==null);return new N("",L.from(s))}},dn=["","null","NULL","NA","N/A","NaN","nan","None","none"];function wn(e,t={}){const n=_n(e,t);if(n.length===0)return{header:[],columns:{},inferredTypes:{}};const s=t.delimiter??Sn(n.slice(0,10)),r=t.hasHeader!==!1,o=new Set(t.nullValues??dn),i=n.map(d=>yn(d,s));let l=0;t.skipRows&&t.skipRows>0&&(l=t.skipRows);let c,u;if(t.header)c=t.header,u=l+(r?1:0);else if(r&&l<i.length)c=i[l].map(d=>d.trim()),u=l+1;else{const d=i[l];if(!d)return{header:[],columns:{},inferredTypes:{}};c=d.map((_,w)=>`column_${w}`),u=l}let f=i.length;t.nRows!==void 0&&t.nRows>=0&&(f=Math.min(f,u+t.nRows));const a=t.columns?new Set(t.columns):null,g={},h=[];for(const d of c)a&&!a.has(d)||(h.push(d),g[d]=[]);const m=new Map;for(let d=0;d<c.length;d++){const _=c[d];a&&!a.has(_)||m.set(d,_)}for(let d=u;d<f;d++){const _=i[d];if(_)for(const[w,b]of m){const S=w<_.length?_[w]:"",y=o.has(S)?null:S;g[b].push(y)}}const p=bn(g,h,t);return{header:h,columns:g,inferredTypes:p}}function _n(e,t){const n=t.comment,s=[];let r="",o=!1;for(let i=0;i<e.length;i++){const l=e[i];l==='"'?o&&i+1<e.length&&e[i+1]==='"'?(r+='""',i++):(o=!o,r+=l):(l===`
`||l==="\r")&&!o?(l==="\r"&&i+1<e.length&&e[i+1]===`
`&&i++,(r.length>0||s.length>0)&&(!n||!r.trimStart().startsWith(n))&&s.push(r),r=""):r+=l}return r.length>0&&(!n||!r.trimStart().startsWith(n))&&s.push(r),s}function yn(e,t){const n=[];let s="",r=!1,o=0;for(;o<e.length;){const i=e[o];r?i==='"'?o+1<e.length&&e[o+1]==='"'?(s+='"',o+=2):(r=!1,o++):(s+=i,o++):i==='"'&&s.length===0?(r=!0,o++):e.startsWith(t,o)?(n.push(s),s="",o+=t.length):(s+=i,o++)}if(r)throw new nt("Unterminated quoted field in CSV");return n.push(s),n}function Sn(e){const t=[",",";","	","|"];let n=",",s=-1;for(const r of t){const o=e.map(u=>{let f=0,a=!1;for(let g=0;g<u.length;g++)u[g]==='"'?a=!a:!a&&u.startsWith(r,g)&&f++;return f});if(o.length===0)continue;const i=o.reduce((u,f)=>u+f,0)/o.length;if(i===0)continue;const c=o.every(u=>u===o[0])?i*2:i;c>s&&(s=c,n=r)}return n}function bn(e,t,n){const s={},r=n.parseNumbers!==!1,o=n.parseDates!==!1;for(const i of t){if(n.dtypes&&i in n.dtypes){s[i]=n.dtypes[i];continue}const c=e[i].slice(0,100).filter(u=>u!==null);if(c.length===0){s[i]="utf8";continue}if(r&&c.every(_e)){s[i]=c.every(Cn)?"i32":"f64";continue}if(c.every(vn)){s[i]="bool";continue}if(o&&c.every(Nn)){s[i]="date";continue}s[i]="utf8"}return s}function _e(e){if(e.length===0)return!1;const t=Number(e);return!Number.isNaN(t)&&e.trim().length>0}function Cn(e){if(!_e(e))return!1;const t=Number(e);return Number.isInteger(t)&&!e.includes(".")&&!e.includes("e")&&!e.includes("E")}function vn(e){const t=e.toLowerCase();return t==="true"||t==="false"}var xn=/^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}(:\d{2})?(\.\d+)?(Z|[+-]\d{2}:?\d{2})?)?$/;function Nn(e){if(!xn.test(e))return!1;const t=new Date(e);return!Number.isNaN(t.getTime())}function kn(e,t,n={}){const s=n.delimiter??",",r=n.quoteStyle??"necessary",o=n.nullValue??"",i=n.header!==!1,l=n.bom===!0,c=[];l&&c.push("\uFEFF"),i&&c.push(e.map(u=>Ot(u,s,r)).join(s));for(const u of t){const f=u.map(a=>a==null?Ot(o,s,r):a instanceof Date?Ot(a.toISOString(),s,r):Ot(typeof a=="number"||typeof a=="string"||typeof a=="boolean"?String(a):JSON.stringify(a),s,r));c.push(f.join(s))}return c.join(`
`)+`
`}function Ot(e,t,n){return n==="never"?e:n==="always"?'"'+e.replace(/"/g,'""')+'"':e.includes(t)||e.includes('"')||e.includes(`
`)||e.includes("\r")?'"'+e.replace(/"/g,'""')+'"':e}var An=["","null","NULL","NA","N/A","NaN","nan","None","none"];async function*$n(e,t={}){const n=t.chunkSize??1e4,s=await import("./__vite-browser-external-9wXp6ZBx.js"),{createReadStream:r}=s;let o;try{o=r(e,{encoding:t.encoding??"utf-8"})}catch(I){const E=I instanceof Error?I.message:String(I);throw new A(`Failed to open CSV file '${e}': ${E}`)}const i=t.hasHeader!==!1,l=new Set(t.nullValues??An),c=t.comment,u=t.skipRows??0;let f=null,a="",g=!1,h=[],m=0,p=!1,d={},_=0,w=0;const b=t.nRows;function S(I,E){const M=[];let D="",P=!1,T=0;for(;T<I.length;){const U=I[T];P?U==='"'?T+1<I.length&&I[T+1]==='"'?(D+='"',T+=2):(P=!1,T++):(D+=U,T++):U==='"'&&D.length===0?(P=!0,T++):I.startsWith(E,T)?(M.push(D),D="",T+=E.length):(D+=U,T++)}if(P)throw new nt("Unterminated quoted field in CSV");return M.push(D),M}function y(I){const E=[",",";","	","|"];let M=",",D=-1;for(const P of E){const T=I.map(Z=>{let pt=0,Dt=!1;for(let Lt=0;Lt<Z.length;Lt++)Z[Lt]==='"'?Dt=!Dt:!Dt&&Z.startsWith(P,Lt)&&pt++;return pt});if(T.length===0)continue;const U=T.reduce((Z,pt)=>Z+pt,0)/T.length;if(U===0)continue;const Y=T.every(Z=>Z===T[0])?U*2:U;Y>D&&(D=Y,M=P)}return M}function v(I,E,M){const D={},P=M.parseNumbers!==!1,T=M.parseDates!==!1;for(const U of E){if(M.dtypes&&U in M.dtypes){D[U]=M.dtypes[U];continue}const Y=I[U].slice(0,100).filter(Z=>Z!==null);if(Y.length===0){D[U]="utf8";continue}if(P&&Y.every(ye)){D[U]=Y.every(Mn)?"i32":"f64";continue}if(Y.every(In)){D[U]="bool";continue}if(T&&Y.every(Dn)){D[U]="date";continue}D[U]="utf8"}return D}function $(I){const E={};for(const M of I)E[M]=[];return E}function O(I,E){for(let M=0;M<E.header.length;M++){const D=E.header[M],P=M<I.length?I[M]:"",T=E.nullValues.has(P)?null:P;d[D].push(T)}_++}let R=null,B=null;function z(I){if(c&&I.trimStart().startsWith(c))return null;if(m<u)return m++,null;if(!p)return B=t.delimiter??y([I]),t.header?(R=t.header,h.push(I)):i?R=S(I,B).map(M=>M.trim()):(R=S(I,B).map((D,P)=>`column_${P}`),h.push(I)),p=!0,null;if(!f){h.push(I);const M=B,D=R,P=$(D);for(const U of h){const ct=S(U,M);for(let Y=0;Y<D.length;Y++){const Z=D[Y],pt=Y<ct.length?ct[Y]:"",Dt=l.has(pt)?null:pt;P[Z].push(Dt)}}const T=v(P,D,t);f={header:D,delimiter:M,nullValues:l,inferredTypes:T},d=$(D);for(const U of h){const ct=S(U,M);O(ct,f)}if(h=[],_>=n){const U={header:f.header,rawColumns:d,inferredTypes:f.inferredTypes};return d=$(f.header),w+=_,_=0,U}return null}const E=S(I,f.delimiter);if(O(E,f),_>=n){const M={header:f.header,rawColumns:d,inferredTypes:f.inferredTypes};return d=$(f.header),w+=_,_=0,M}return null}for await(const I of o){a+=I;let E=0;for(let M=0;M<a.length;M++){const D=a[M];if(D==='"')g=!g;else if(!g&&(D===`
`||D==="\r")){const P=a.slice(E,M);if(D==="\r"&&M+1<a.length&&a[M+1]===`
`&&M++,E=M+1,P.length>0){if(b!==void 0&&w+_>=b)break;const T=z(P);if(T&&(yield T,b!==void 0&&w>=b)){o.destroy();return}}}}if(a=a.slice(E),b!==void 0&&w>=b){o.destroy();return}}a.length>0&&!(b!==void 0&&w>=b)&&(!c||!a.trimStart().startsWith(c))&&z(a);const J=f;if(_>0&&J!==null){if(b!==void 0){const I=b-w;if(I<=0)return;if(I<_)for(const E of J.header)d[E]=d[E].slice(0,I)}yield{header:J.header,rawColumns:d,inferredTypes:J.inferredTypes}}}function ye(e){if(e.length===0)return!1;const t=Number(e);return!Number.isNaN(t)&&e.trim().length>0}function Mn(e){if(!ye(e))return!1;const t=Number(e);return Number.isInteger(t)&&!e.includes(".")&&!e.includes("e")&&!e.includes("E")}function In(e){const t=e.toLowerCase();return t==="true"||t==="false"}var En=/^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}(:\d{2})?(\.\d+)?(Z|[+-]\d{2}:?\d{2})?)?$/;function Dn(e){if(!En.test(e))return!1;const t=new Date(e);return!Number.isNaN(t.getTime())}async function*On(e,t={}){const n=t.chunkSize??1e4,s=t.nRows,r=await import("./__vite-browser-external-9wXp6ZBx.js"),{createReadStream:o}=r;let i;try{i=o(e,{encoding:t.encoding??"utf-8"})}catch(f){const a=f instanceof Error?f.message:String(f);throw new A(`Failed to open NDJSON file '${e}': ${a}`)}let l="",c=[],u=0;for await(const f of i){l+=f;let a=0;for(let g=0;g<l.length;g++){const h=l[g];if(h===`
`||h==="\r"){const m=l.slice(a,g);if(h==="\r"&&g+1<l.length&&l[g+1]===`
`&&g++,a=g+1,m.trim().length>0&&(c.push(JSON.parse(m)),c.length>=n&&(yield c,u+=c.length,c=[],s!==void 0&&u>=s))){i.destroy();return}}}l=l.slice(a)}if(l.trim().length>0&&c.push(JSON.parse(l)),c.length>0){if(s!==void 0){const f=s-u;if(f<=0)return;f<c.length&&(c=c.slice(0,f))}yield c}}function Rn(e,t,n={}){const s=[];for(const r of t){const o={};for(let i=0;i<e.length;i++){const l=r[i];l instanceof Date?o[e[i]]=l.toISOString():o[e[i]]=l??null}s.push(o)}return n.pretty?JSON.stringify(s,null,2):JSON.stringify(s)}function Tn(e,t){const n=[];for(const s of t){const r={};for(let o=0;o<e.length;o++){const i=s[o];i instanceof Date?r[e[o]]=i.toISOString():r[e[o]]=i??null}n.push(JSON.stringify(r))}return n.join(`
`)+`
`}function Fn(e){return e==null||typeof e=="number"?"f64":typeof e=="boolean"?"bool":e instanceof Date?"date":typeof e=="string"?"utf8":typeof e=="object"?"object":"utf8"}function se(e){const t=/^([A-Z]+)(\d+)$/.exec(e.toUpperCase());if(!t)throw new A(`Invalid cell reference: '${e}'`);const n=t[1],s=parseInt(t[2],10);let r=0;for(let o=0;o<n.length;o++)r=r*26+(n.charCodeAt(o)-64);return{col:r,row:s}}function Ln(e){const t=e.split(":");if(t.length!==2)throw new A(`Invalid range format: '${e}'. Expected format like 'A1:G100'`);const n=se(t[0]),s=se(t[1]);return{startCol:n.col,startRow:n.row,endCol:s.col,endRow:s.row}}function Vn(e,t){if(t===void 0||t===0){const s=e.worksheets[0];if(!s)throw new A("Workbook contains no worksheets");return s}if(typeof t=="number"){const s=e.worksheets[t];if(!s)throw new A(`Worksheet at index ${String(t)} not found`);return s}const n=e.getWorksheet(t);if(!n)throw new A(`Worksheet '${t}' not found`);return n}function Un(e){if(e==null)return null;if(typeof e=="object"&&e!==null&&!Array.isArray(e)&&!(e instanceof Date)){if("richText"in e)return e.richText.map(t=>String(t.text)).join("");if("result"in e)return e.result}return e}function jn(e,t={}){const n=t.hasHeader!==!1,s=t.range;let r,o,i,l;if(s){const h=Ln(s);r=h.startRow,o=h.endRow,i=h.startCol,l=h.endCol}else r=1,o=e.rowCount,i=1,l=e.columnCount;if(o<r||l<i)return{header:[],columns:{},inferredTypes:{}};const c=[];for(let h=r;h<=o;h++){const m=e.getRow(h),p=[];for(let d=i;d<=l;d++){const _=m.getCell(d);p.push(Un(_.value))}c.push(p)}let u,f;if(n&&c.length>0)u=c[0].map((h,m)=>h==null?`column_${String(m)}`:typeof h=="string"?h:typeof h=="number"||typeof h=="boolean"||typeof h=="bigint"?String(h):h instanceof Date?h.toISOString():`column_${String(m)}`),f=1;else{const h=l-i+1;u=Array.from({length:h},(m,p)=>`column_${String(p)}`),f=0}const a={};for(const h of u)a[h]=[];for(let h=f;h<c.length;h++){const m=c[h];for(let p=0;p<u.length;p++){const d=u[p];a[d].push(p<m.length?m[p]??null:null)}}const g={};for(const h of u)if(t.dtypes?.[h]!==void 0)g[h]=t.dtypes[h];else{const m=a[h];let p="f64";for(const d of m)if(d!=null){p=Fn(d);break}g[h]=p}return{header:u,columns:a,inferredTypes:g}}async function Bn(e,t={}){let n;try{n=await import("./exceljs.min-CskDqBR3.js").then(function(s){return s.e})}catch{throw new A("exceljs is required to read Excel files but is not installed. Run: npm install exceljs")}try{const s=new n.Workbook;await s.xlsx.readFile(e);const r=Vn(s,t.sheet);return jn(r,t)}catch(s){if(s instanceof A)throw s;const r=s instanceof Error?s.message:String(s);throw new A(`Failed to read Excel file '${e}': ${r}`)}}function Pn(e){const n=(e.type?.toString?.()??String(e.type)).toLowerCase();return n.includes("int32")||n.includes("int16")||n.includes("int8")?"i32":n.includes("int64")||n.includes("int")||n.includes("uint")||n.includes("float")||n.includes("double")||n.includes("decimal")?"f64":n.includes("utf8")||n.includes("string")||n.includes("largestring")||n.includes("largeutf8")?"utf8":n==="bool"||n.includes("boolean")?"bool":n.includes("date")||n.includes("timestamp")?"date":"utf8"}function qn(e,t,n){const s=[];for(let r=0;r<n;r++){if(e.isValid(r)===!1){s.push(null);continue}let o=e.get(r);typeof o=="bigint"&&(o=Number(o)),t==="date"&&typeof o=="number"&&(o=new Date(o)),s.push(o)}return s}async function Wn(e,t={}){let n;try{n=await import("parquet-wasm")}catch{throw new A("parquet-wasm is required to read Parquet files but is not installed. Run: npm install parquet-wasm")}try{const r=await(await import("./__vite-browser-external-9wXp6ZBx.js")).readFile(e),o=new Uint8Array(r.buffer,r.byteOffset,r.byteLength),i=n.readParquet(o),l=i.schema,c=l.numFields??l.fields?.length??0,u=i.numRows??0,f=[];for(let p=0;p<c;p++){const d=l.field(p),_=String(d.name),w=Pn(d);f.push({name:_,dtype:w,index:p})}const a=t.columns?f.filter(p=>t.columns.includes(p.name)):f,g=[],h={},m={};for(const p of a){g.push(p.name),m[p.name]=p.dtype;const d=i.getChildAt(p.index);d?h[p.name]=qn(d,p.dtype,u):h[p.name]=new Array(u).fill(null)}return{header:g,columns:h,inferredTypes:m}}catch(s){if(s instanceof A)throw s;const r=s instanceof Error?s.message:String(s);throw new A(`Failed to read Parquet file '${e}': ${r}`)}}function zn(e){const t=/^([A-Z]+)(\d+)$/.exec(e.toUpperCase());if(!t)throw new A(`Invalid cell reference: '${e}'`);const n=t[1],s=parseInt(t[2],10);let r=0;for(let o=0;o<n.length;o++)r=r*26+(n.charCodeAt(o)-64);return{col:r,row:s}}function vt(e){let t="",n=e;for(;n>0;){const s=(n-1)%26;t=String.fromCharCode(65+s)+t,n=Math.floor((n-1)/26)}return t}async function Kn(e,t,n,s={}){let r;try{r=await import("./exceljs.min-CskDqBR3.js").then(function(o){return o.e})}catch{throw new A("exceljs is required to write Excel files but is not installed. Run: npm install exceljs")}try{const o=new r.Workbook,i=s.sheet??"Sheet1",l=o.addWorksheet(i),c=s.startCell??"A1",{col:u,row:f}=zn(c);for(let a=0;a<t.length;a++){const h=`${vt(u+a)}${String(f)}`;l.getCell(h).value=t[a]}for(let a=0;a<n.length;a++){const g=n[a];for(let h=0;h<t.length;h++){const p=`${vt(u+h)}${String(f+1+a)}`,d=h<g.length?g[h]:null;l.getCell(p).value=d??null}}if(s.autoFilter){const a=vt(u+t.length-1),g=f+n.length;l.autoFilter=`${vt(u)}${String(f)}:${a}${String(g)}`}if(s.freezePanes){const a=s.freezePanes.row,g=s.freezePanes.col;l.views=[{state:"frozen",xSplit:g,ySplit:f-1+a,topLeftCell:`${vt(u+g)}${String(f+a)}`,activeCell:`${vt(u)}${String(f)}`}]}if(s.columnWidths)for(let a=0;a<t.length;a++){const g=t[a],h=s.columnWidths[g];if(h!==void 0){const m=l.getColumn(u+a);m.width=h}}await o.xlsx.writeFile(e)}catch(o){if(o instanceof A)throw o;const i=o instanceof Error?o.message:String(o);throw new A(`Failed to write Excel file '${e}': ${i}`)}}function Hn(e,t){switch(t){case"f64":return new e.Float64;case"i32":return new e.Int32;case"utf8":return new e.Utf8;case"bool":return new e.Bool;case"date":case"datetime":return new e.DateMillisecond;default:return new e.Utf8}}function Jn(e,t){switch(t){case"f64":case"i32":return e.map(n=>n==null?null:Number(n));case"utf8":return e.map(n=>n==null?null:typeof n=="string"?n:typeof n=="number"||typeof n=="boolean"||typeof n=="bigint"?String(n):typeof n=="object"?JSON.stringify(n):String(n));case"bool":return e.map(n=>n==null?null:!!n);case"date":case"datetime":return e.map(n=>n==null?null:n instanceof Date?n.getTime():typeof n=="number"?n:null);default:return e.map(n=>n==null?null:typeof n=="string"?n:typeof n=="number"||typeof n=="boolean"||typeof n=="bigint"?String(n):typeof n=="object"?JSON.stringify(n):String(n))}}function Yn(e,t){const n=e.Compression;if(!n)return t.toUpperCase();switch(t){case"snappy":return n.SNAPPY;case"gzip":return n.GZIP;case"zstd":return n.ZSTD;case"none":return n.UNCOMPRESSED}}async function Gn(e,t,n,s={}){let r;try{r=await import("parquet-wasm")}catch{throw new A("parquet-wasm is required to write Parquet files but is not installed. Run: npm install parquet-wasm")}let o;try{o=await import("apache-arrow")}catch{throw new A("apache-arrow is required to write Parquet files but is not installed. Run: npm install apache-arrow")}try{const i=[],l={};for(const w of t){const b=n[w],S=Hn(o,b.dtype);i.push(new o.Field(w,S,!0));const y=Jn(b.values,b.dtype);l[w]=o.vectorFromArray(y,S)}const c=new o.Schema(i),u=new o.Table(c,l),f=o.tableToIPC(u,"stream"),a=r.Table.fromIPCStream(f),g=s.compression??"snappy",h=Yn(r,g);let m=new r.WriterPropertiesBuilder;m=m.setCompression(h),s.rowGroupSize!==void 0&&(m=m.setMaxRowGroupSize(s.rowGroupSize));const p=m.build(),d=r.writeParquet(a,p);await(await import("./__vite-browser-external-9wXp6ZBx.js")).writeFile(e,d)}catch(i){if(i instanceof A)throw i;const l=i instanceof Error?i.message:String(i);throw new A(`Failed to write Parquet file '${e}': ${l}`)}}function Qn(e,t){switch(t){case"f64":return new e.Float64;case"i32":return new e.Int32;case"utf8":return new e.Utf8;case"bool":return new e.Bool;case"date":case"datetime":return new e.DateMillisecond;default:return new e.Utf8}}function Zn(e,t){if(e==null)return null;switch(t){case"f64":case"i32":return Number(e);case"bool":return!!e;case"date":case"datetime":return e instanceof Date?e.getTime():typeof e=="number"?e:new Date(e).getTime();default:return typeof e=="string"?e:typeof e=="number"||typeof e=="boolean"||typeof e=="bigint"?String(e):typeof e=="object"?JSON.stringify(e):String(e)}}async function Xn(e){let t;try{t=await import("apache-arrow")}catch{throw new A("apache-arrow is required for Arrow interop but is not installed. Run: npm install apache-arrow")}const{columnOrder:n,getColumnValues:s}=e,r={};for(const o of n){const{values:i,dtype:l}=s(o),c=Qn(t,l),u=i.map(f=>Zn(f,l));r[o]=t.vectorFromArray(u,c)}return new t.Table(r)}function ts(e){const t=e.type?.typeId,n=String(e.type??"");switch(t){case 2:return"i32";case 3:return"f64";case 5:return"utf8";case 6:return"bool";case 8:case 10:return"date";case-1:return n.includes("Utf8"),"utf8";default:return n.includes("Int")?"i32":n.includes("Float")?"f64":n.includes("Utf8")||n.includes("utf8")?"utf8":n.includes("Bool")?"bool":n.includes("Date")||n.includes("Timestamp")?"date":"utf8"}}function es(e){if(!e||!e.schema||!e.schema.fields)throw new A("Invalid Arrow Table: missing schema or fields");const t=[],n={},s={},r=Number(e.numRows),o=e.schema.fields;for(const i of o){const l=String(i.name);t.push(l);const c=ts(i);s[l]=c;const u=e.getChild(l),f=[];for(let a=0;a<r;a++){const g=u.get(a);g==null?f.push(null):c==="date"&&typeof g=="number"?f.push(new Date(g)):f.push(g)}n[l]=f}return{header:t,columns:n,inferredTypes:s}}var ns=`
'use strict';
const { parentPort } = require('worker_threads');

function getNumericValue(data, nullMask, index, dtype) {
  // Check null mask
  if (nullMask) {
    const byteIndex = index >> 3;
    const bitIndex = index & 7;
    if (!((nullMask[byteIndex] >> bitIndex) & 1)) {
      return null; // null value
    }
  }
  if (dtype === 'float64' || dtype === 'int32' || dtype === 'date') {
    return data[index];
  }
  return null;
}

function getStringValue(data, nullMask, index) {
  if (nullMask) {
    const byteIndex = index >> 3;
    const bitIndex = index & 7;
    if (!((nullMask[byteIndex] >> bitIndex) & 1)) {
      return null;
    }
  }
  return data[index];
}

function getValue(colData, index) {
  if (colData.dtype === 'utf8') {
    return getStringValue(colData.data, colData.nullMaskArr, index);
  }
  return getNumericValue(colData.dataArr, colData.nullMaskArr, index, colData.dtype);
}

function computeAgg(colData, indices, aggType) {
  switch (aggType) {
    case 'sum': {
      let total = 0;
      let hasValue = false;
      for (let i = 0; i < indices.length; i++) {
        const v = getValue(colData, indices[i]);
        if (v !== null && typeof v === 'number') {
          total += v;
          hasValue = true;
        }
      }
      return hasValue ? total : null;
    }
    case 'mean': {
      let total = 0;
      let count = 0;
      for (let i = 0; i < indices.length; i++) {
        const v = getValue(colData, indices[i]);
        if (v !== null && typeof v === 'number') {
          total += v;
          count++;
        }
      }
      return count > 0 ? total / count : null;
    }
    case 'count': {
      let count = 0;
      for (let i = 0; i < indices.length; i++) {
        const v = getValue(colData, indices[i]);
        if (v !== null) count++;
      }
      return count;
    }
    case 'count_distinct': {
      const seen = new Set();
      for (let i = 0; i < indices.length; i++) {
        const v = getValue(colData, indices[i]);
        if (v !== null) seen.add(v);
      }
      return seen.size;
    }
    case 'min': {
      let result = null;
      for (let i = 0; i < indices.length; i++) {
        const v = getValue(colData, indices[i]);
        if (v !== null && typeof v === 'number') {
          if (result === null || v < result) result = v;
        }
      }
      return result;
    }
    case 'max': {
      let result = null;
      for (let i = 0; i < indices.length; i++) {
        const v = getValue(colData, indices[i]);
        if (v !== null && typeof v === 'number') {
          if (result === null || v > result) result = v;
        }
      }
      return result;
    }
    case 'std': {
      let sum = 0;
      let sumSq = 0;
      let count = 0;
      for (let i = 0; i < indices.length; i++) {
        const v = getValue(colData, indices[i]);
        if (v !== null && typeof v === 'number') {
          sum += v;
          sumSq += v * v;
          count++;
        }
      }
      if (count < 2) return null;
      const mean = sum / count;
      const variance = sumSq / count - mean * mean;
      return Math.sqrt(variance);
    }
    case 'first': {
      for (let i = 0; i < indices.length; i++) {
        const v = getValue(colData, indices[i]);
        if (v !== null) return v;
      }
      return null;
    }
    case 'last': {
      for (let i = indices.length - 1; i >= 0; i--) {
        const v = getValue(colData, indices[i]);
        if (v !== null) return v;
      }
      return null;
    }
    default:
      return null;
  }
}

parentPort.on('message', (msg) => {
  const { columns, groups, aggSpecs, keyColumns } = msg;

  // Pre-process column data for fast access
  const processedColumns = {};
  for (const [name, colData] of Object.entries(columns)) {
    const processed = { ...colData };
    if (colData.dtype === 'float64' || colData.dtype === 'date') {
      processed.dataArr = new Float64Array(colData.data);
    } else if (colData.dtype === 'int32') {
      processed.dataArr = new Int32Array(colData.data);
    } else if (colData.dtype === 'boolean') {
      processed.dataArr = new Uint8Array(colData.data);
    }
    // utf8: data is already string[]
    if (colData.nullMask) {
      processed.nullMaskArr = new Uint8Array(colData.nullMask);
    } else {
      processed.nullMaskArr = null;
    }
    processedColumns[name] = processed;
  }

  const results = [];
  const aggEntries = Object.entries(aggSpecs);

  for (const [groupIndex, indices] of groups) {
    // Extract key values from first row
    const keyValues = [];
    const firstIndex = indices[0];
    for (const keyCol of keyColumns) {
      const colData = processedColumns[keyCol];
      if (colData) {
        keyValues.push(getValue(colData, firstIndex));
      } else {
        keyValues.push(null);
      }
    }

    // Compute aggregations
    const aggValues = {};
    for (const [outputName, spec] of aggEntries) {
      const colData = processedColumns[spec.columnName];
      if (colData) {
        aggValues[outputName] = computeAgg(colData, indices, spec.aggType);
      } else {
        aggValues[outputName] = null;
      }
    }

    results.push({ groupIndex, keyValues, aggValues });
  }

  parentPort.postMessage({ results });
});
`,ss=1e6,Se=Math.max(1,Ue.cpus().length-1),Yt=null;function rs(){return Yt===null?!0:Yt}function qt(e,t){const n=t?.threshold??ss;return e<n||!rs()?!1:(t?.workerCount??Se)>1}function os(e,t){const n=t.length;let s=null;if(t.nullCount>0){const r=new Uint8Array(Math.ceil(n/8));for(let o=0;o<n;o++)t.get(o)!==null&&(r[o>>3]|=1<<(o&7));s=r.buffer}switch(t.dtype){case"f64":case"date":{const r=new Float64Array(n);for(let o=0;o<n;o++){const i=t.get(o);i===null?r[o]=0:i instanceof Date?r[o]=i.getTime():r[o]=i}return{name:e,dtype:t.dtype==="date"?"date":"float64",data:r.buffer,nullMask:s,length:n}}case"i32":{const r=new Int32Array(n);for(let o=0;o<n;o++){const i=t.get(o);r[o]=i===null?0:i}return{name:e,dtype:"int32",data:r.buffer,nullMask:s,length:n}}case"bool":{const r=new Uint8Array(n);for(let o=0;o<n;o++){const i=t.get(o);r[o]=i===null?0:i?1:0}return{name:e,dtype:"boolean",data:r.buffer,nullMask:s,length:n}}default:{const r=[];for(let o=0;o<n;o++){const i=t.get(o);i===null?r.push(""):typeof i=="string"?r.push(i):typeof i=="number"||typeof i=="boolean"?r.push(String(i)):r.push("")}return{name:e,dtype:"utf8",data:r,nullMask:s,length:n}}}}function is(e,t){const n=Array.from({length:t},()=>[]);for(let s=0;s<e.length;s++){const[,r]=e[s];n[s%t].push([s,r])}return n}async function ls(e,t,n,s,r,o){const i=await import("./__vite-browser-external-9wXp6ZBx.js"),{Worker:l}=i;Yt=!0;const c=Math.min(o?.workerCount??Se,e.length),u=new Set;for(const p of t)u.add(p);for(const p of Object.values(s))u.add(p.columnName);const f={};for(const p of u){const d=r.get(p);d&&(f[p]=os(p,d))}const g=is(e,c).map(p=>p.length===0?Promise.resolve({results:[]}):new Promise((d,_)=>{const w=new l(ns,{eval:!0}),b={columns:f,groups:p,aggSpecs:s,keyColumns:t};w.on("message",S=>{w.terminate(),d(S)}),w.on("error",S=>{w.terminate(),_(S)}),w.postMessage(b)})),h=await Promise.all(g),m=[];for(const p of h)m.push(...p.results);return m.sort((p,d)=>p.groupIndex-d.groupIndex),m}var cs=class{_df;_keys;_groupMap;constructor(e,t){this._df=e,this._keys=t;for(const s of t)if(!e.columns.includes(s))throw new j(s,e.columns);this._groupMap=new Map;const n=t.map(s=>e.col(s).column);for(let s=0;s<e.length;s++){const r=this._serializeKey(n,s),o=this._groupMap.get(r);o?o.push(s):this._groupMap.set(r,[s])}}get keys(){return[...this._keys]}get dataframe(){return this._df}get groupMap(){return this._groupMap}nGroups(){return this._groupMap.size}agg(e,t){return(t||qt(this._df.length))&&qt(this._df.length,t),this._aggSync(e)}async aggAsync(e,t){const n={};for(const[m,p]of Object.entries(e))typeof p=="string"?n[m]=this._resolveShorthand(m,p):n[m]=p;if(!qt(this._df.length,t))return this._aggSync(e);const r={};for(const[m,p]of Object.entries(n)){const d=this._aggExprToType(p);if(!d)return this._aggSync(e);r[m]={columnName:p.dependencies[0],aggType:d}}const o=new Map;for(const m of this._df.columns)o.set(m,this._df.col(m).column);const i=[...this._groupMap.entries()],l=this._keys.map(m=>this._df.col(m).column),c=await ls(i,[...this._keys],l,r,o,t),u=c.length,f=new Map,a=[];for(let m=0;m<this._keys.length;m++){const p=this._keys[m],d=c.map(_=>_.keyValues[m]??null);f.set(p,this._buildColumnLike(l[m],d)),a.push(p)}const g=Object.keys(e);for(const m of g){const p=c.map(d=>d.aggValues[m]??null);f.set(m,this._inferColumn(p,u)),a.push(m)}const h=this._df.constructor;return new h(f,a)}_aggSync(e){const t=[...this._groupMap.entries()],n=t.length,s=this._keys,r=Object.keys(e),o={};for(const[g,h]of Object.entries(e))typeof h=="string"?o[g]=this._resolveShorthand(g,h):o[g]=h;const i=new Map;for(const g of s)i.set(g,[]);const l=new Map;for(const g of r)l.set(g,[]);const c=s.map(g=>this._df.col(g).column);if(r.length===1){const g=r[0],h=o[g];if(h instanceof we){const m=this._df.col(h.dependencies[0]).column;for(const[,w]of t){const b=w[0];for(let v=0;v<s.length;v++)i.get(s[v]).push(c[v].get(b));let S=0,y=!1;for(let v=0;v<w.length;v++){const $=m.get(w[v]);typeof $=="number"&&(S+=$,y=!0)}l.get(g).push(y?S:null)}const p=new Map,d=[];for(let w=0;w<s.length;w++){const b=s[w],S=i.get(b);p.set(b,this._buildColumnLike(c[w],S)),d.push(b)}p.set(g,x.from(l.get(g))),d.push(g);const _=this._df.constructor;return new _(p,d)}}for(const[,g]of t){const h=g[0];for(let w=0;w<s.length;w++)i.get(s[w]).push(c[w].get(h));const m=new Int32Array(g),p=new Map;for(const w of this._df.columns)p.set(w,this._df.col(w).column.take(m));const d=this._df.constructor,_=new d(p,[...this._df.columns]);for(const w of r){const S=o[w].evaluateFrame(_);l.get(w).push(S)}}const u=new Map,f=[];for(let g=0;g<s.length;g++){const h=s[g],m=c[g],p=i.get(h);u.set(h,this._buildColumnLike(m,p)),f.push(h)}for(const g of r){const h=l.get(g);u.set(g,this._inferColumn(h,n)),f.push(g)}const a=this._df.constructor;return new a(u,f)}_aggExprToType(e){const t=e.constructor.name;return{SumAggExpr:"sum",MeanAggExpr:"mean",CountAggExpr:"count",CountDistinctAggExpr:"count_distinct",MinAggExpr:"min",MaxAggExpr:"max",StdAggExpr:"std",FirstAggExpr:"first",LastAggExpr:"last"}[t]??null}_resolveShorthand(e,t){const n=st(e);switch(t){case"sum":return n.sum();case"mean":return n.mean();case"count":return n.count();case"min":return n.min();case"max":return n.max();case"std":return n.std();case"first":return n.first();case"last":return n.last();default:throw new Error(`Unknown aggregation method: ${t}`)}}_buildColumnLike(e,t){switch(e.dtype){case"f64":return x.from(t);case"i32":return x.from(t);case"utf8":return q.from(t);case"bool":return L.from(t);case"date":return H.from(t);default:return x.from(t)}}_inferColumn(e,t){let n=null;for(const s of e)if(s!==null){n=s;break}return n===null||typeof n=="number"?x.from(e):typeof n=="string"?q.from(e):typeof n=="boolean"?L.from(e):n instanceof Date?H.from(e):x.from(e)}count(){const e=[...this._groupMap.entries()],t=this._keys.map(l=>this._df.col(l).column),n=new Map;for(const l of this._keys)n.set(l,[]);const s=[];for(const[,l]of e){const c=l[0];for(let u=0;u<this._keys.length;u++)n.get(this._keys[u]).push(t[u].get(c));s.push(l.length)}const r=new Map,o=[];for(let l=0;l<this._keys.length;l++){const c=this._keys[l],u=n.get(c);r.set(c,this._buildColumnLike(t[l],u)),o.push(c)}r.set("count",x.from(s)),o.push("count");const i=this._df.constructor;return new i(r,o)}sum(e){return this.agg({[e]:st(e).sum()})}mean(e){return this.agg({[e]:st(e).mean()})}min(e){return this.agg({[e]:st(e).min()})}max(e){return this.agg({[e]:st(e).max()})}first(){const e=this._df.columns.filter(n=>!this._keys.includes(n)),t={};for(const n of e)t[n]=st(n).first();return this.agg(t)}last(){const e=this._df.columns.filter(n=>!this._keys.includes(n)),t={};for(const n of e)t[n]=st(n).last();return this.agg(t)}apply(e){const t=[];for(const[,s]of this._groupMap){const r=this._buildSubFrame(s);t.push(e(r))}return t.length===0?this._df.slice(0,0):this._df.constructor.concat(...t)}groups(){const e=new Map;for(const[t,n]of this._groupMap)e.set(t,this._buildSubFrame(n));return e}_serializeKey(e,t){if(e.length===1){const s=e[0].get(t);return s===null?"\0null":s instanceof Date?`\0d${s.getTime()}`:typeof s=="number"||typeof s=="string"||typeof s=="boolean"?`\0${typeof s}${String(s)}`:`\0obj${JSON.stringify(s)}`}const n=[];for(const s of e){const r=s.get(t);r===null?n.push("\0null"):r instanceof Date?n.push(`\0d${r.getTime()}`):typeof r=="number"||typeof r=="string"||typeof r=="boolean"?n.push(`\0${typeof r}${String(r)}`):n.push(`\0obj${JSON.stringify(r)}`)}return n.join("")}_buildSubFrame(e){const t=new Int32Array(e),n=new Map,s=this._df.columns;for(const o of s)n.set(o,this._df.col(o).column.take(t));const r=this._df.constructor;return new r(n,s)}};function Bt(e,t){const n=[];for(const s of e){const r=s.get(t);if(r===null)return null;r instanceof Date?n.push(`\0d${r.getTime()}`):typeof r=="number"||typeof r=="string"||typeof r=="boolean"?n.push(`\0${typeof r}${String(r)}`):n.push(`\0obj${JSON.stringify(r)}`)}return n.join("")}function At(e){return e===null?null:e instanceof Date?`\0d${e.getTime()}`:typeof e=="number"||typeof e=="string"||typeof e=="boolean"?e:`\0obj${JSON.stringify(e)}`}function dt(e,t){switch(e){case"f64":return x.from(t);case"i32":return lt.from(t);case"utf8":return q.from(t);case"bool":return L.from(t);case"date":return H.from(t);default:return x.from(t)}}function be(e){if(typeof e=="string")return{leftKeys:[e],rightKeys:[e]};if(Array.isArray(e))return{leftKeys:e,rightKeys:e};const t=Array.isArray(e.left)?e.left:[e.left],n=Array.isArray(e.right)?e.right:[e.right];if(t.length!==n.length)throw new Error("Left and right key arrays must have the same length");return{leftKeys:t,rightKeys:n}}function us(e,t,n){const s=e.length*t.length,r=new Map,o=[],i=new Map;for(const c of t.columns)e.columns.includes(c)?i.set(c,`${c}${n}`):i.set(c,c);for(const c of e.columns){const u=e.col(c).column,f=new Array(s);for(let a=0;a<e.length;a++){const g=u.get(a);for(let h=0;h<t.length;h++)f[a*t.length+h]=g}r.set(c,dt(u.dtype,f)),o.push(c)}for(const c of t.columns){const u=t.col(c).column,f=i.get(c),a=new Array(s);for(let g=0;g<e.length;g++)for(let h=0;h<t.length;h++)a[g*t.length+h]=u.get(h);r.set(f,dt(u.dtype,a)),o.push(f)}const l=e.constructor;return new l(r,o)}function re(e,t,n,s){const{leftKeys:r,rightKeys:o}=be(n);for(const h of r)if(!e.columns.includes(h))throw new j(h,e.columns);for(const h of o)if(!t.columns.includes(h))throw new j(h,t.columns);const i=o.map(h=>t.col(h).column),l=r.map(h=>e.col(h).column),c=new Set;if(i.length===1){const h=i[0];for(let m=0;m<t.length;m++){const p=At(h.get(m));p!==null&&c.add(p)}}else for(let h=0;h<t.length;h++){const m=Bt(i,h);m!==null&&c.add(m)}const u=[];if(l.length===1){const h=l[0];for(let m=0;m<e.length;m++){const p=At(h.get(m)),d=p!==null&&c.has(p);(s?!d:d)&&u.push(m)}}else for(let h=0;h<e.length;h++){const m=Bt(l,h),p=m!==null&&c.has(m);(s?!p:p)&&u.push(h)}const f=new Map,a=[];for(const h of e.columns){const m=e.col(h).column,p=new Array(u.length);for(let d=0;d<u.length;d++)p[d]=m.get(u[d]);f.set(h,dt(m.dtype,p)),a.push(h)}const g=e.constructor;return new g(f,a)}function as(e,t,n,s="inner",r){const o=r?.suffix??"_right";if(s==="cross")return us(e,t,o);if(s==="semi")return re(e,t,n,!1);if(s==="anti")return re(e,t,n,!0);const{leftKeys:i,rightKeys:l}=be(n);for(const y of i)if(!e.columns.includes(y))throw new j(y,e.columns);for(const y of l)if(!t.columns.includes(y))throw new j(y,t.columns);if(s==="left"&&i.length===1&&l.length===1){const y=e.col(i[0]).column,v=t.col(l[0]).column,$=new Map;let O=!0;for(let R=0;R<t.length;R++){const B=At(v.get(R));if(B!==null){if($.has(B)){O=!1;break}$.set(B,R)}}if(O){const R=new Map,B=[];for(const E of e.columns)R.set(E,e.col(E).column),B.push(E);const z=t.columns.filter(E=>E!==l[0]),J=new Map;for(const E of z)J.set(E,e.columns.includes(E)?`${E}${o}`:E);for(const E of z){const M=t.col(E).column,D=new Array(e.length);for(let T=0;T<e.length;T++){const U=At(y.get(T));if(U===null){D[T]=null;continue}const ct=$.get(U);D[T]=ct===void 0?null:M.get(ct)}const P=J.get(E);R.set(P,dt(M.dtype,D)),B.push(P)}const I=e.constructor;return new I(R,B)}}const c=l.map(y=>t.col(y).column),u=new Map;if(c.length===1){const y=c[0];for(let v=0;v<t.length;v++){const $=At(y.get(v));if($===null)continue;const O=u.get($);O===void 0?u.set($,v):typeof O=="number"?u.set($,[O,v]):O.push(v)}}else for(let y=0;y<t.length;y++){const v=Bt(c,y);if(v===null)continue;const $=u.get(v);$===void 0?u.set(v,[y]):typeof $=="number"?u.set(v,[$,y]):$.push(y)}const f=i.map(y=>e.col(y).column),a=[],g=[],h=new Uint8Array(t.length);if(f.length===1){const y=f[0];for(let v=0;v<e.length;v++){const $=At(y.get(v));if($===null){(s==="left"||s==="outer")&&(a.push(v),g.push(null));continue}const O=u.get($);if(O!==void 0)if(typeof O=="number")a.push(v),g.push(O),(s==="right"||s==="outer")&&(h[O]=1);else for(let R=0;R<O.length;R++){const B=O[R];a.push(v),g.push(B),(s==="right"||s==="outer")&&(h[B]=1)}else(s==="left"||s==="outer")&&(a.push(v),g.push(null))}}else for(let y=0;y<e.length;y++){const v=Bt(f,y);if(v===null){(s==="left"||s==="outer")&&(a.push(y),g.push(null));continue}const $=u.get(v);if($!==void 0)if(typeof $=="number")a.push(y),g.push($),(s==="right"||s==="outer")&&(h[$]=1);else for(let O=0;O<$.length;O++){const R=$[O];a.push(y),g.push(R),(s==="right"||s==="outer")&&(h[R]=1)}else(s==="left"||s==="outer")&&(a.push(y),g.push(null))}if(s==="right"||s==="outer")for(let y=0;y<t.length;y++)h[y]===0&&(a.push(-1),g.push(y));const m=new Map,p=[],d=a.length,_=t.columns.filter(y=>!l.includes(y)),w=e.columns.filter(y=>!i.includes(y)),b=new Map;for(const y of _)e.columns.includes(y)?b.set(y,`${y}${o}`):b.set(y,y);for(let y=0;y<i.length;y++){const v=i[y],$=l[y],O=e.col(v).column,R=t.col($).column,B=new Array(d);for(let z=0;z<d;z++){const J=a[z],I=g[z];J>=0?B[z]=O.get(J):I!==null?B[z]=R.get(I):B[z]=null}m.set(v,dt(O.dtype,B)),p.push(v)}for(const y of w){const v=e.col(y).column,$=new Array(d);for(let O=0;O<d;O++){const R=a[O];$[O]=R>=0?v.get(R):null}m.set(y,dt(v.dtype,$)),p.push(y)}for(const y of _){const v=t.col(y).column,$=b.get(y),O=new Array(d);for(let R=0;R<d;R++){const B=g[R];B!==null?O[R]=v.get(B):O[R]=null}m.set($,dt(v.dtype,O)),p.push($)}const S=e.constructor;return new S(m,p)}function oe(e,t){const n=[];for(const s of e){const r=s.get(t);if(r===null)return null;r instanceof Date?n.push(`\0d${r.getTime()}`):typeof r=="number"||typeof r=="string"||typeof r=="boolean"?n.push(`\0${typeof r}${String(r)}`):n.push(`\0obj${JSON.stringify(r)}`)}return n.join("")}function fs(e,t){switch(e){case"f64":return x.from(t);case"i32":return lt.from(t);case"utf8":return q.from(t);case"bool":return L.from(t);case"date":return H.from(t);default:return new gt(t)}}function hs(e,t,n,s){if(!e.columns.includes(n))throw new j(n,e.columns);if(!t.columns.includes(n))throw new j(n,t.columns);const r=s??t.columns.filter(a=>a!==n);for(const a of r)if(!t.columns.includes(a))throw new j(a,t.columns);const o=[t.col(n).column],i=new Map;for(let a=0;a<t.length;a++){const g=oe(o,a);g!==null&&(i.has(g)||i.set(g,a))}const l=[e.col(n).column],c=new Map,u=[];for(const a of e.columns)c.set(a,e.col(a).column),u.push(a);for(const a of r){const g=t.col(a).column,h=new Array(e.length);for(let p=0;p<e.length;p++){const d=oe(l,p);if(d!==null){const _=i.get(d);h[p]=_!==void 0?g.get(_):null}else h[p]=null}const m=(e.columns.includes(a),a);c.set(m,fs(g.dtype,h)),u.push(m)}const f=e.constructor;return new f(c,u)}function gs(e,t,n={}){if(!e.columns.includes(t))throw new j(t,e.columns);const{limit:s,name:r,drop:o=!1}=n,i=e.col(t).column,l=e.length;let c=!1,u=0;const f=new Set;for(let m=0;m<l;m++){const p=i.get(m);if(p!==null){if(Array.isArray(p))u=Math.max(u,p.length);else if(typeof p=="object"){c=!0;for(const d of Object.keys(p))f.add(d)}}}const a=new Map,g=[];for(const m of e.columns)o&&m===t||(a.set(m,e.col(m).column),g.push(m));if(c){const m=[...f],p=s!==void 0?m.slice(0,s):m;for(const d of p){const _=r?r(t,d):`${t}_${d}`,w=new Array(l);for(let b=0;b<l;b++){const S=i.get(b);if(S===null||typeof S!="object"||Array.isArray(S))w[b]=null;else{const y=S;w[b]=d in y?y[d]:null}}a.set(_,gt.from(w)),g.push(_)}}else{const m=s!==void 0?Math.min(u,s):u;for(let p=0;p<m;p++){const d=r?r(t,p):`${t}_${String(p)}`,_=new Array(l);for(let w=0;w<l;w++){const b=i.get(w);b===null||!Array.isArray(b)||p>=b.length?_[w]=null:_[w]=b[p]}a.set(d,gt.from(_)),g.push(d)}}const h=e.constructor;return new h(a,g)}function ps(e,t,n={}){const s=Array.isArray(t)?t:[t];for(const m of s)if(!e.columns.includes(m))throw new j(m,e.columns);const r=e.length,o=e.columns.filter(m=>!s.includes(m)),i=new Array(r);for(let m=0;m<r;m++){let p=0;for(const d of s){const _=e.col(d).column.get(m);Array.isArray(_)&&(p=Math.max(p,_.length))}i[m]=p}const l=i.reduce((m,p)=>m+p,0),c={};for(const m of o)c[m]=new Array(l);for(const m of s)c[m]=new Array(l);let u;n.index&&(u=new Array(l));let f=0;for(let m=0;m<r;m++){const p=i[m];if(p!==0)for(let d=0;d<p;d++){for(const _ of o)c[_][f]=e.col(_).column.get(m);for(const _ of s){const w=e.col(_).column.get(m);Array.isArray(w)&&d<w.length?c[_][f]=w[d]:c[_][f]=null}u&&(u[f]=d),f++}}const a=new Map,g=[];for(const m of e.columns)a.set(m,gt.from(c[m])),g.push(m);n.index&&u&&(a.set(n.index,gt.from(u)),g.push(n.index));const h=e.constructor;return new h(a,g)}function ie(e,t){return t.map(n=>{const s=e[n];return s===null?"__null__":s instanceof Date?`__date__${String(s.getTime())}`:`__${typeof s}__${JSON.stringify(s)}`}).join("|")}function ms(e){if(e.length===0)return[[]];let t=[[]];for(const n of e){const s=[];for(const r of t)for(const o of n)s.push([...r,o]);t=s}return t}function ds(e,t,n={}){for(const u of Object.keys(t))if(!e.columns.includes(u))throw new j(u,e.columns);const s=n.expand??[];for(const u of s)if(!e.columns.includes(u))throw new j(u,e.columns);const r=e.toArray();let o=r;if(s.length>0){const u=s.map(g=>{const h=new Set,m=[];for(const p of r){const d=p[g],_=d instanceof Date?`d:${String(d.getTime())}`:JSON.stringify(d);h.has(_)||(h.add(_),m.push(d??null))}return m}),f=ms(u),a=new Map;for(const g of r)a.set(ie(g,s),g);o=f.map(g=>{const h={};for(let d=0;d<s.length;d++)h[s[d]]=g[d]??null;const m=a.get(ie(h,s));if(m)return m;const p={};for(const d of e.columns)p[d]=h[d]??null;return p})}const i={};for(const u of e.columns)i[u]=o.map(f=>f[u]??null);const l={};for(const[u,f]of Object.entries(t))l[u]=typeof f=="function"?f(i):f;const c=o.map(u=>{const f={...u};for(const[a,g]of Object.entries(l))(f[a]??null)===null&&(f[a]=g);return f});return e.constructor.fromRows(c)}function ws(e,t){switch(t){case"first":return e.length>0?e[0]:null;case"last":return e.length>0?e[e.length-1]:null;case"count":return e.length;case"sum":{let n=0;for(const s of e)typeof s=="number"&&(n+=s);return n}case"mean":{let n=0,s=0;for(const r of e)typeof r=="number"&&(n+=r,s++);return s>0?n/s:null}}}function le(e,t,n){const s=[];for(const r of n){const o=e.col(r).get(t);o===null?s.push("\0null"):o instanceof Date?s.push(`\0d${o.getTime()}`):typeof o=="number"||typeof o=="string"||typeof o=="boolean"?s.push(`\0${typeof o}${String(o)}`):s.push(`\0obj${JSON.stringify(o)}`)}return s.join("")}function ce(e,t){switch(e){case"f64":return x.from(t);case"i32":return lt.from(t);case"utf8":return q.from(t);case"bool":return L.from(t);case"date":return H.from(t);default:return x.from(t)}}function _s(e,t){const n=Array.isArray(t.index)?t.index:[t.index],s=t.columns,r=t.values,o=t.aggFunc??"first";for(const _ of[...n,s,r])if(!e.columns.includes(_))throw new j(_,e.columns);const i=[],l=new Map;for(let _=0;_<e.length;_++){const w=le(e,_,n);l.has(w)||(i.push(w),l.set(w,[])),l.get(w).push(_)}const c=[],u=new Set,f=e.col(s);for(let _=0;_<e.length;_++){const w=f.get(_);let b;w===null?b="null":typeof w=="string"||typeof w=="number"||typeof w=="boolean"?b=String(w):w instanceof Date?b=w.toISOString():b=JSON.stringify(w),u.has(b)||(u.add(b),c.push(b))}const a=new Map;for(let _=0;_<e.length;_++){const w=le(e,_,n),b=f.get(_);let S;b===null?S="null":typeof b=="string"||typeof b=="number"||typeof b=="boolean"?S=String(b):b instanceof Date?S=b.toISOString():S=JSON.stringify(b);const y=w+""+S;a.has(y)||a.set(y,[]),a.get(y).push(e.col(r).get(_))}const g=e.col(r).column.dtype,h=o==="count"?"f64":g,m=new Map,p=[];for(const _ of n){const w=[],b=e.col(_);for(const S of i){const y=l.get(S)[0];w.push(b.get(y))}m.set(_,ce(b.column.dtype,w)),p.push(_)}for(const _ of c){const w=[];for(const b of i){const S=b+""+_,y=a.get(S);y&&y.length>0?w.push(ws(y,o)):w.push(null)}m.set(_,ce(h,w)),p.push(_)}const d=e.constructor;return new d(m,p)}function ue(e,t){switch(e){case"f64":return x.from(t);case"i32":return lt.from(t);case"utf8":return q.from(t);case"bool":return L.from(t);case"date":return H.from(t);default:return x.from(t)}}function ys(e){for(const t of e)if(t!=null){if(typeof t=="number")return Number.isInteger(t),"f64";if(typeof t=="string")return"utf8";if(typeof t=="boolean")return"bool";if(t instanceof Date)return"date"}return"f64"}function Ss(e,t){const n=Array.isArray(t.idVars)?t.idVars:[t.idVars],s=t.varName??"variable",r=t.valueName??"value";for(const p of n)if(!e.columns.includes(p))throw new j(p,e.columns);let o;if(t.valueVars){o=Array.isArray(t.valueVars)?t.valueVars:[t.valueVars];for(const p of o)if(!e.columns.includes(p))throw new j(p,e.columns)}else{const p=new Set(n);o=e.columns.filter(d=>!p.has(d))}const i=e.length,l=o.length,c=i*l,u=new Map,f=[];for(const p of n){const d=e.col(p),_=new Array(c);for(let w=0;w<i;w++){const b=d.get(w);for(let S=0;S<l;S++)_[w*l+S]=b}u.set(p,ue(d.column.dtype,_)),f.push(p)}const a=new Array(c);for(let p=0;p<i;p++)for(let d=0;d<l;d++)a[p*l+d]=o[d];u.set(s,q.from(a)),f.push(s);const g=new Array(c);for(let p=0;p<i;p++)for(let d=0;d<l;d++)g[p*l+d]=e.col(o[d]).get(p);const h=ys(g);u.set(r,ue(h,g)),f.push(r);const m=e.constructor;return new m(u,f)}function Ce(e){for(const t of e)if(t!=null){if(typeof t=="number")return"f64";if(typeof t=="string")return"utf8";if(typeof t=="boolean")return"bool";if(t instanceof Date)return"date"}return"f64"}function ve(e,t){switch(e){case"f64":return x.from(t);case"i32":return lt.from(t);case"utf8":return q.from(t);case"bool":return L.from(t);case"date":return H.from(t);default:return x.from(t)}}function bs(e){return e==null?"null":e instanceof Date?e.toISOString():typeof e=="number"||typeof e=="string"||typeof e=="boolean"?String(e):JSON.stringify(e)}function Cs(e,t){const n=e.constructor,s=e.length,r=e.columns;if(r.length===0||s===0)return new n(new Map,[]);let o,i;if(t){const u=e.col(t);o=[];for(let f=0;f<s;f++)o.push(bs(u.get(f)));i=r.filter(f=>f!==t)}else{o=[];for(let u=0;u<s;u++)o.push(String(u));i=r}const l=new Map,c=["column"];l.set("column",q.from(i));for(let u=0;u<s;u++){const f=o[u],a=[];for(const h of i)a.push(e.col(h).get(u));const g=Ce(a);l.set(f,ve(g,a)),c.push(f)}return new n(l,c)}function Wt(...e){if(e.length===0)throw new ht("concat requires at least one DataFrame");const t=e[0],n=t.constructor;if(e.length===1)return t;const s=[],r=new Set;for(const c of e)for(const u of c.columns)r.has(u)||(r.add(u),s.push(u));const o=new Map;for(const c of e){const u=c.dtypes;for(const f of c.columns){const a=o.get(f),g=u[f];if(a!==void 0&&a!==g)throw new ht(`Column '${f}' has incompatible types: ${a} vs ${g}`);o.set(f,g)}}const i=e.reduce((c,u)=>c+u.length,0),l=new Map;for(const c of s){const u=new Array(i);let f=0;for(const g of e){const h=g.length;if(g.columns.includes(c)){const m=g.col(c);for(let p=0;p<h;p++)u[f+p]=m.get(p)}else for(let m=0;m<h;m++)u[f+m]=null;f+=h}const a=o.get(c)??Ce(u);l.set(c,ve(a,u))}return new n(l,s)}function $t(e,t,n){const s=[];for(const r of n){const o=e.col(r).get(t);o===null?s.push("\0null"):o instanceof Date?s.push(`\0d${o.getTime()}`):typeof o=="number"||typeof o=="string"||typeof o=="boolean"?s.push(`\0${typeof o}${String(o)}`):s.push(`\0obj${JSON.stringify(o)}`)}return s.join("")}function Zt(e,t){const n=e.columns,s=t.columns;if(n.length!==s.length)throw new ht(`Schema mismatch: left has ${n.length} columns, right has ${s.length} columns`);const r=e.dtypes,o=t.dtypes;for(const i of n){if(!(i in o))throw new ht(`Schema mismatch: column '${i}' not found in right DataFrame`);if(r[i]!==o[i])throw new ht(`Schema mismatch: column '${i}' has dtype '${r[i]}' in left but '${o[i]}' in right`)}}function xe(e,t){switch(e){case"f64":return x.from(t);case"i32":return lt.from(t);case"utf8":return q.from(t);case"bool":return L.from(t);case"date":return H.from(t);default:return x.from(t)}}function Ne(e,t){const n=e.columns,s=e.dtypes,r=new Map;for(const i of n){const l=e.col(i),c=[];for(const u of t)c.push(l.get(u));r.set(i,xe(s[i],c))}const o=e.constructor;return new o(r,[...n])}function vs(e,t){Zt(e,t);const n=e.columns,s=e.dtypes,r=new Set,o=new Map;for(const c of n)o.set(c,[]);for(let c=0;c<e.length;c++){const u=$t(e,c,n);if(!r.has(u)){r.add(u);for(const f of n)o.get(f).push(e.col(f).get(c))}}for(let c=0;c<t.length;c++){const u=$t(t,c,n);if(!r.has(u)){r.add(u);for(const f of n)o.get(f).push(t.col(f).get(c))}}const i=new Map;for(const c of n)i.set(c,xe(s[c],o.get(c)));const l=e.constructor;return new l(i,[...n])}function xs(e,t){Zt(e,t);const n=e.columns,s=new Set;for(let i=0;i<t.length;i++)s.add($t(t,i,n));const r=new Set,o=[];for(let i=0;i<e.length;i++){const l=$t(e,i,n);s.has(l)&&!r.has(l)&&(r.add(l),o.push(i))}return Ne(e,o)}function Ns(e,t){Zt(e,t);const n=e.columns,s=new Set;for(let i=0;i<t.length;i++)s.add($t(t,i,n));const r=new Set,o=[];for(let i=0;i<e.length;i++){const l=$t(e,i,n);!s.has(l)&&!r.has(l)&&(r.add(l),o.push(i))}return Ne(e,o)}function ae(e){return`"${e.replace(/"/g,'""')}"`}function ks(e){return e==null?"NULL":typeof e=="boolean"?e?"TRUE":"FALSE":typeof e=="number"?isFinite(e)?String(e):"NULL":typeof e=="bigint"?String(e):e instanceof Date?`'${e.toISOString()}'`:typeof e=="string"?`'${e.replace(/'/g,"''")}'`:`'${JSON.stringify(e).replace(/'/g,"''")}'`}function As(e,t,n,s={}){const r=s.batchSize??1e3;if(t.length===0||n.length===0)return"";const o=t.map(ae).join(", "),i=[];for(let l=0;l<n.length;l+=r){const u=n.slice(l,l+r).map(f=>`(${f.map(ks).join(", ")})`);i.push(`INSERT INTO ${ae(e)} (${o}) VALUES
${u.join(`,
`)};`)}return i.join(`

`)}var $s=0;function Ms(){return{type:"scan",id:$s++}}function et(e,t=0){const n="  ".repeat(t);switch(e.type){case"scan":return e.projection?`${n}SCAN [id=${e.id}, cols=${e.projection.join(", ")}]`:`${n}SCAN [id=${e.id}]`;case"filter":return`${n}FILTER [${e.predicate.toString()}]
${et(e.input,t+1)}`;case"select":return`${n}SELECT [${e.columns.join(", ")}]
${et(e.input,t+1)}`;case"project":{const s=e.exprs.map(r=>r.toString()).join(", ");return`${n}PROJECT [${s}]
${et(e.input,t+1)}`}case"groupby":{const s=e.aggs.map(r=>r.toString()).join(", ");return`${n}GROUPBY [keys: ${e.keys.join(", ")}; aggs: ${s}]
${et(e.input,t+1)}`}case"join":return`${n}JOIN [${e.how}]
${n}  left:
${et(e.left,t+2)}
${n}  right:
${et(e.right,t+2)}`;case"sort":return`${n}SORT [${e.by} ${e.descending?"DESC":"ASC"}]
${et(e.input,t+1)}`;case"limit":return`${n}LIMIT [${e.n}]
${et(e.input,t+1)}`;case"distinct":return`${n}DISTINCT${e.subset?` [${e.subset.join(", ")}]`:""}
${et(e.input,t+1)}`}}function Is(e,t){function n(s){switch(s.type){case"scan":return s.projection?t.select(...s.projection):t;case"filter":return n(s.input).filter(s.predicate);case"select":return n(s.input).select(...s.columns);case"project":{const r=n(s.input);let o=r;for(const i of s.exprs){const l=i.evaluate(r);o=o.withColumn(l.name,i)}return o}case"groupby":{const o=n(s.input).groupBy(...s.keys),i={};for(const l of s.aggs){const c=l,f=c.dependencies[0]??"value";i[f]=c}return o.agg(i)}case"sort":return n(s.input).sortBy(s.by,s.descending?"desc":"asc");case"limit":return n(s.input).head(s.n);case"distinct":return n(s.input).unique(s.subset);case"join":{const r=n(s.left),o=n(s.right);return r.join(o,s.on,s.how)}}}return n(e)}function Es(e){const t=ot(e),n=it(t);return tt(n)}function ot(e){switch(e.type){case"scan":return e;case"filter":{const n={type:"filter",input:ot(e.input),predicate:e.predicate};return Ut(n)}case"select":return{type:"select",input:ot(e.input),columns:e.columns};case"project":return{type:"project",input:ot(e.input),exprs:e.exprs};case"groupby":return{type:"groupby",input:ot(e.input),keys:e.keys,aggs:e.aggs};case"sort":return{type:"sort",input:ot(e.input),by:e.by,descending:e.descending};case"limit":return{type:"limit",input:ot(e.input),n:e.n};case"distinct":return{type:"distinct",input:ot(e.input),subset:e.subset};case"join":return{type:"join",left:ot(e.left),right:ot(e.right),on:e.on,how:e.how}}}function Ut(e){const t=e.input;switch(t.type){case"select":return{type:"select",input:Ut({type:"filter",input:t.input,predicate:e.predicate}),columns:t.columns};case"project":return{type:"project",input:Ut({type:"filter",input:t.input,predicate:e.predicate}),exprs:t.exprs};case"sort":return{type:"sort",input:Ut({type:"filter",input:t.input,predicate:e.predicate}),by:t.by,descending:t.descending};case"groupby":return e;default:return e}}function it(e){switch(e.type){case"scan":return e;case"filter":{const t=it(e.input);return t.type==="filter"?{type:"filter",input:t.input,predicate:t.predicate.and(e.predicate)}:{type:"filter",input:t,predicate:e.predicate}}case"select":return{type:"select",input:it(e.input),columns:e.columns};case"project":return{type:"project",input:it(e.input),exprs:e.exprs};case"groupby":return{type:"groupby",input:it(e.input),keys:e.keys,aggs:e.aggs};case"sort":return{type:"sort",input:it(e.input),by:e.by,descending:e.descending};case"limit":return{type:"limit",input:it(e.input),n:e.n};case"distinct":return{type:"distinct",input:it(e.input),subset:e.subset};case"join":return{type:"join",left:it(e.left),right:it(e.right),on:e.on,how:e.how}}}function tt(e,t){switch(e.type){case"scan":{if(t&&t.size>0){const n=[...t].sort();return{type:"scan",id:e.id,projection:n}}return e}case"select":{const n=new Set(e.columns);return{type:"select",input:tt(e.input,n),columns:e.columns}}case"filter":{const n=new Set(t);for(const s of e.predicate.dependencies)n.add(s);return{type:"filter",input:tt(e.input,n),predicate:e.predicate}}case"project":{const n=new Set;for(const s of e.exprs)for(const r of s.dependencies)n.add(r);return{type:"project",input:tt(e.input,n),exprs:e.exprs}}case"groupby":{const n=new Set(e.keys);for(const s of e.aggs)for(const r of s.dependencies)n.add(r);return{type:"groupby",input:tt(e.input,n),keys:e.keys,aggs:e.aggs}}case"sort":{const n=new Set(t);return n.add(e.by),{type:"sort",input:tt(e.input,n),by:e.by,descending:e.descending}}case"limit":return{type:"limit",input:tt(e.input,t),n:e.n};case"distinct":{if(e.subset){const n=new Set(t);for(const s of e.subset)n.add(s);return{type:"distinct",input:tt(e.input,n),subset:e.subset}}return{type:"distinct",input:tt(e.input,t),subset:e.subset}}case"join":{const n=typeof e.on=="string"?[e.on]:e.on,s=new Set(t),r=new Set(t);for(const o of n)s.add(o),r.add(o);return{type:"join",left:tt(e.left,s),right:tt(e.right,r),on:e.on,how:e.how}}}}var Ds=class{_source;_plan;_keys;constructor(e,t,n){this._source=e,this._plan=t,this._keys=n}agg(...e){return new ke(this._source,{type:"groupby",input:this._plan,keys:[...this._keys],aggs:e})}},ke=class mt{_source;_plan;constructor(t,n){this._source=t,this._plan=n}filter(t){return new mt(this._source,{type:"filter",input:this._plan,predicate:t})}select(...t){return new mt(this._source,{type:"select",input:this._plan,columns:t})}project(...t){return new mt(this._source,{type:"project",input:this._plan,exprs:t})}sort(t,n=!1){return new mt(this._source,{type:"sort",input:this._plan,by:t,descending:n})}sortBy(t,n=!1){return this.sort(t,n)}limit(t){return new mt(this._source,{type:"limit",input:this._plan,n:t})}head(t){return this.limit(t)}distinct(t){return new mt(this._source,{type:"distinct",input:this._plan,subset:t})}unique(t){return this.distinct(t)}groupBy(...t){return new Ds(this._source,this._plan,t)}explain(){const t=et(this._plan),n=Es(this._plan),s=et(n);return`ORIGINAL:
${t}

OPTIMIZED:
${s}`}collect(){return Promise.resolve(Is(this._plan,this._source))}async sink(t){const n=await this.collect(),s=t.toLowerCase();if(s.endsWith(".csv")||s.endsWith(".tsv"))await n.toCSV(t);else if(s.endsWith(".ndjson")||s.endsWith(".jsonl"))await n.toNDJSON(t);else throw new Error(`Unsupported sink format for '${t}'. Supported: .csv, .tsv, .ndjson, .jsonl`)}};function zt(e){return new ke(e,Ms())}var Os=new Set(["SELECT","FROM","WHERE","ORDER","BY","LIMIT","GROUP","HAVING","AND","OR","IN","LIKE","IS","NOT","NULL","ASC","DESC","AS"]);function Rs(e){const t=[];let n=0;for(;n<e.length;){if(/\s/.test(e[n])){n++;continue}const s=n;if(e[n]==="'"){n++;let r="";for(;n<e.length&&e[n]!=="'";)e[n]==="'"&&e[n+1]==="'"?(r+="'",n+=2):(r+=e[n],n++);if(n>=e.length)throw new nt(`Unterminated string literal at position ${s}`);n++,t.push({type:"STRING",value:r,position:s});continue}if(/\d/.test(e[n])||e[n]==="-"&&n+1<e.length&&/\d/.test(e[n+1])){let r="";for(e[n]==="-"&&(r+="-",n++);n<e.length&&/[\d.]/.test(e[n]);)r+=e[n],n++;t.push({type:"NUMBER",value:r,position:s});continue}if(e[n]==="*"){t.push({type:"STAR",value:"*",position:s}),n++;continue}if(e[n]===","){t.push({type:"COMMA",value:",",position:s}),n++;continue}if(e[n]==="("){t.push({type:"LPAREN",value:"(",position:s}),n++;continue}if(e[n]===")"){t.push({type:"RPAREN",value:")",position:s}),n++;continue}if(e[n]==="!"&&e[n+1]==="="){t.push({type:"NEQ",value:"!=",position:s}),n+=2;continue}if(e[n]==="<"&&e[n+1]===">"){t.push({type:"NEQ",value:"<>",position:s}),n+=2;continue}if(e[n]===">"&&e[n+1]==="="){t.push({type:"GTE",value:">=",position:s}),n+=2;continue}if(e[n]==="<"&&e[n+1]==="="){t.push({type:"LTE",value:"<=",position:s}),n+=2;continue}if(e[n]===">"){t.push({type:"GT",value:">",position:s}),n++;continue}if(e[n]==="<"){t.push({type:"LT",value:"<",position:s}),n++;continue}if(e[n]==="="){t.push({type:"EQ",value:"=",position:s}),n++;continue}if(/[a-zA-Z_]/.test(e[n])){let r="";for(;n<e.length&&/[a-zA-Z0-9_]/.test(e[n]);)r+=e[n],n++;const o=r.toUpperCase();Os.has(o)?t.push({type:o,value:o,position:s}):t.push({type:"IDENTIFIER",value:r,position:s});continue}throw new nt(`Unexpected character '${e[n]}' at position ${s}`)}return t.push({type:"EOF",value:"",position:n}),t}var Ts=class{tokens;pos;_selectItems=[];constructor(e){this.tokens=e,this.pos=0}current(){return this.tokens[this.pos]}peek(){return this.tokens[this.pos]}advance(){const e=this.tokens[this.pos];return this.pos++,e}expect(e){const t=this.current();if(t.type!==e)throw new nt(`Expected ${e} but got '${t.value}' at position ${t.position}`);return this.advance()}match(e){return this.current().type===e?(this.advance(),!0):!1}parse(){this.expect("SELECT");let e=!1;const t=[];if(this.current().type==="STAR")e=!0,this.advance();else for(t.push(this.parseSelectItem());this.match("COMMA");)t.push(this.parseSelectItem());this._selectItems=t,this.expect("FROM");const n=this.expect("IDENTIFIER");if(n.value!=="this")throw new nt(`FROM clause must reference 'this', got '${n.value}' at position ${n.position}`);let s;this.current().type==="WHERE"&&(this.advance(),s=this.parseOrExpr());const r=[];if(this.current().type==="GROUP")for(this.advance(),this.expect("BY"),r.push(this.expect("IDENTIFIER").value);this.match("COMMA");)r.push(this.expect("IDENTIFIER").value);let o;this.current().type==="HAVING"&&(this.advance(),o=this.parseOrExpr());const i=[];if(this.current().type==="ORDER")for(this.advance(),this.expect("BY"),i.push(this.parseOrderByItem());this.match("COMMA");)i.push(this.parseOrderByItem());let l;if(this.current().type==="LIMIT"){this.advance();const c=this.expect("NUMBER");l=parseInt(c.value,10)}if(this.current().type!=="EOF")throw new nt(`Unexpected token '${this.current().value}' at position ${this.current().position}`);return{selectItems:t,selectAll:e,whereExpr:s,groupByColumns:r,havingExpr:o,orderByItems:i,limit:l}}parseSelectItem(){const e=this.current(),t=e.value.toUpperCase();if(e.type==="IDENTIFIER"&&["SUM","AVG","COUNT","MIN","MAX"].includes(t)&&this.tokens[this.pos+1]?.type==="LPAREN"){const r=t;this.advance(),this.advance();let o;this.current().type==="STAR"?(o="*",this.advance()):o=this.expect("IDENTIFIER").value,this.expect("RPAREN");let i;return this.current().type==="AS"&&(this.advance(),i=this.expect("IDENTIFIER").value),{column:o,alias:i,aggregate:r}}const n=this.expect("IDENTIFIER").value;let s;return this.current().type==="AS"&&(this.advance(),s=this.expect("IDENTIFIER").value),{column:n,alias:s,aggregate:void 0}}parseOrderByItem(){const e=this.expect("IDENTIFIER").value;let t="asc";return this.current().type==="ASC"?(this.advance(),t="asc"):this.current().type==="DESC"&&(this.advance(),t="desc"),{column:e,direction:t}}parseOrExpr(){let e=this.parseAndExpr();for(;this.current().type==="OR";){this.advance();const t=this.parseAndExpr();e=e.or(t)}return e}parseAndExpr(){let e=this.parseComparison();for(;this.current().type==="AND";){this.advance();const t=this.parseComparison();e=e.and(t)}return e}parseComparison(){if(this.current().type==="LPAREN"){this.advance();const i=this.parseOrExpr();return this.expect("RPAREN"),i}if(this.current().type==="NOT")return this.advance(),this.parseComparison().not();const e=this.current(),t=e.value.toUpperCase();if(e.type==="IDENTIFIER"&&["SUM","AVG","COUNT","MIN","MAX"].includes(t)&&this.tokens[this.pos+1]?.type==="LPAREN")return this.parseAggregateComparison();const n=this.expect("IDENTIFIER").value,s=st(n);if(this.current().type==="IS")return this.advance(),this.current().type==="NOT"?(this.advance(),this.expect("NULL"),new fe(n,!0)):(this.expect("NULL"),new fe(n,!1));if(this.current().type==="NOT"){if(this.advance(),this.current().type==="IN"){this.advance();const i=this.parseValueList();let l=s.eq(K(i[0]));for(let c=1;c<i.length;c++)l=l.or(s.eq(K(i[c])));return l.not()}if(this.current().type==="LIKE"){this.advance();const i=this.expect("STRING").value;return this.buildLikeExpr(n,i).not()}throw new nt(`Expected IN or LIKE after NOT at position ${this.current().position}`)}if(this.current().type==="IN"){this.advance();const i=this.parseValueList();let l=s.eq(K(i[0]));for(let c=1;c<i.length;c++)l=l.or(s.eq(K(i[c])));return l}if(this.current().type==="LIKE"){this.advance();const i=this.expect("STRING").value;return this.buildLikeExpr(n,i)}const r=this.current();this.advance();const o=this.parseLiteralValue();switch(r.type){case"EQ":return s.eq(K(o));case"NEQ":return s.neq(K(o));case"GT":return s.gt(K(o));case"GTE":return s.gte(K(o));case"LT":return s.lt(K(o));case"LTE":return s.lte(K(o));default:throw new nt(`Expected comparison operator at position ${r.position}, got '${r.value}'`)}}parseAggregateComparison(){const e=this.advance().value.toUpperCase();this.expect("LPAREN");let t;this.current().type==="STAR"?(t="*",this.advance()):t=this.expect("IDENTIFIER").value,this.expect("RPAREN");const s=this._selectItems.find(l=>l.aggregate===e&&l.column===t)?.alias??(t==="*"?`${e.toLowerCase()}`:`${e.toLowerCase()}_${t}`),r=st(s),o=this.current();this.advance();const i=this.parseLiteralValue();switch(o.type){case"EQ":return r.eq(K(i));case"NEQ":return r.neq(K(i));case"GT":return r.gt(K(i));case"GTE":return r.gte(K(i));case"LT":return r.lt(K(i));case"LTE":return r.lte(K(i));default:throw new nt(`Expected comparison operator at position ${o.position}, got '${o.value}'`)}}parseLiteralValue(){const e=this.current();if(e.type==="NUMBER")return this.advance(),parseFloat(e.value);if(e.type==="STRING")return this.advance(),e.value;if(e.type==="NULL")return this.advance(),null;if(e.type==="IDENTIFIER"){const t=e.value.toUpperCase();if(t==="TRUE")return this.advance(),!0;if(t==="FALSE")return this.advance(),!1}throw new nt(`Expected literal value at position ${e.position}, got '${e.value}'`)}parseValueList(){this.expect("LPAREN");const e=[];for(e.push(this.parseLiteralValue());this.match("COMMA");)e.push(this.parseLiteralValue());return this.expect("RPAREN"),e}buildLikeExpr(e,t){const n="^"+t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&").replace(/%/g,".*").replace(/_/g,".")+"$";return new Fs(e,n)}},Fs=class extends C{_columnName;_regexStr;constructor(e,t){super(),this._columnName=e,this._regexStr=t}get dependencies(){return[this._columnName]}evaluate(e){const t=e.col(this._columnName),n=new RegExp(this._regexStr),s=[];for(let r=0;r<t.length;r++){const o=t.column.get(r);o===null?s.push(null):s.push(n.test(typeof o=="string"?o:`${o}`))}return new N("like_result",L.from(s))}toString(){return`LIKE(${this._columnName}, ${this._regexStr})`}},fe=class extends C{_columnName;_invert;constructor(e,t){super(),this._columnName=e,this._invert=t}get dependencies(){return[this._columnName]}evaluate(e){const t=e.col(this._columnName);return this._invert?t.isNotNull():t.isNull()}toString(){return`${this._columnName} IS ${this._invert?"NOT ":""}NULL`}};function Ls(e,t){const n={};for(const s of e){if(t.includes(s.column)||s.aggregate===void 0)continue;const r=s.alias??(s.column==="*"?`${s.aggregate.toLowerCase()}`:`${s.aggregate.toLowerCase()}_${s.column}`),o=s.column==="*"?t[0]:s.column,i=st(o);switch(s.aggregate){case"SUM":n[r]=i.sum();break;case"AVG":n[r]=i.mean();break;case"COUNT":n[r]=i.count();break;case"MIN":n[r]=i.min();break;case"MAX":n[r]=i.max();break}}return n}function Vs(e,t){const n=Rs(t),r=new Ts(n).parse();let o=e;if(r.whereExpr!==void 0&&(o=o.filter(r.whereExpr)),r.groupByColumns.length>0){const i=Ls(r.selectItems,r.groupByColumns);if(o=o.groupBy(...r.groupByColumns).agg(i),r.havingExpr!==void 0&&(o=o.filter(r.havingExpr)),!r.selectAll){const c=[];for(const u of r.selectItems)if(u.aggregate!==void 0){const f=u.alias??(u.column==="*"?`${u.aggregate.toLowerCase()}`:`${u.aggregate.toLowerCase()}_${u.column}`);c.push(f)}else c.push(u.alias??u.column);o=o.select(...c)}}else if(!r.selectAll){const i=r.selectItems.map(c=>c.column);o=o.select(...i);const l={};for(const c of r.selectItems)c.alias!==void 0&&(l[c.column]=c.alias);Object.keys(l).length>0&&(o=o.rename(l))}if(r.orderByItems.length>0){const i=r.orderByItems.map(c=>c.column),l=r.orderByItems.map(c=>c.direction);o=o.sortBy(i,l)}return r.limit!==void 0&&(o=o.head(r.limit)),o}var Mt=class k{static _readers=new Map;static _writers=new Map;_columns;_columnOrder;constructor(t,n){this._columns=t,this._columnOrder=n;for(const s of t.values())s.addRef()}get shape(){return[this.length,this._columnOrder.length]}get columns(){return[...this._columnOrder]}get dtypes(){const t={};for(const n of this._columnOrder)t[n]=this._columns.get(n).dtype;return t}get length(){return this._columnOrder.length===0?0:this._columns.get(this._columnOrder[0]).length}col(t){const n=this._columns.get(t);if(!n)throw new j(t,this._columnOrder);return new N(t,n)}row(t){if(t<0||t>=this.length)throw new F("INVALID_OPERATION",`Row index ${t} out of bounds for DataFrame with ${this.length} rows`);const n={};for(const s of this._columnOrder)n[s]=this._columns.get(s).get(t);return n}*[Symbol.iterator](){for(let t=0;t<this.length;t++)yield this.row(t)}rows(){return this[Symbol.iterator]()}toArray(){const t=[];for(let n=0;n<this.length;n++)t.push(this.row(n));return t}clone(){const t=new Map;for(const[n,s]of this._columns)t.set(n,s.clone());return new k(t,[...this._columnOrder])}reify(){return this.clone()}lazy(){return zt(this)}select(...t){for(const s of t)if(!this._columns.has(s))throw new j(s,this._columnOrder);const n=new Map;for(const s of t)n.set(s,this._columns.get(s));return new k(n,[...t])}drop(...t){for(const o of t)if(!this._columns.has(o))throw new j(o,this._columnOrder);const n=new Set(t),s=new Map,r=[];for(const o of this._columnOrder)n.has(o)||(s.set(o,this._columns.get(o)),r.push(o));return new k(s,r)}head(t=5){return this.slice(0,Math.min(t,this.length))}tail(t=5){const n=Math.max(0,this.length-t);return this.slice(n,this.length)}slice(t,n){const s=n===void 0?this.length:Math.min(n,this.length),r=Math.max(0,t),o=new Map;for(const i of this._columnOrder)o.set(i,this._columns.get(i).slice(r,s));return new k(o,[...this._columnOrder])}withColumn(t,n){if(n instanceof C){const c=n.evaluate(this),u=new Map(this._columns);u.set(t,c.column);const f=this._columnOrder.includes(t)?[...this._columnOrder]:[...this._columnOrder,t];return new k(u,f)}let s;if(typeof n=="function"){const c=n;s=[];for(let u=0;u<this.length;u++)s.push(c(this.row(u)))}else if(s=n,s.length!==this.length)throw new ht(`Column '${t}' has length ${s.length}, expected ${this.length}`);const r=ge(s),o=ft(r,s),i=new Map(this._columns);i.set(t,o);const l=this._columnOrder.includes(t)?[...this._columnOrder]:[...this._columnOrder,t];return new k(i,l)}assign(t){if(t.length!==this.length&&t.columns.length>0&&this._columnOrder.length>0)throw new ht(`Cannot assign DataFrame with ${t.length} rows to DataFrame with ${this.length} rows`);const n=new Map(this._columns),s=[...this._columnOrder];for(const r of t.columns)n.set(r,t._columns.get(r)),this._columnOrder.includes(r)||s.push(r);return new k(n,s)}derive(t){let n=this;for(const[s,r]of Object.entries(t)){if(this.length===0){n=n.withColumn(s,[]);continue}const o=r(this.row(0));if(o instanceof C){n=n.withColumn(s,o.evaluate(this).toArray());continue}const i=[o];for(let l=1;l<this.length;l++)i.push(r(this.row(l)));n=n.withColumn(s,i)}return n}lookup(t,n,s){return hs(this,t,n,s)}spread(t,n){return gs(this,t,n)}unroll(t,n){return ps(this,t,n)}impute(t,n){return ds(this,t,n)}relocate(t,n){const{before:s,after:r}=n;if(s!==void 0&&r!==void 0)throw new F("INVALID_OPERATION",'Cannot specify both "before" and "after" in relocate');if(s===void 0&&r===void 0)throw new F("INVALID_OPERATION",'Must specify either "before" or "after" in relocate');for(const f of t)if(!this._columns.has(f))throw new j(f,this._columnOrder);const o=s??r;if(!this._columns.has(o))throw new j(o,this._columnOrder);const i=this._columnOrder.filter(f=>!t.includes(f)),l=i.indexOf(o),c=s!==void 0?l:l+1,u=[...i.slice(0,c),...t,...i.slice(c)];return new k(new Map(this._columns),u)}rename(t){for(const r of Object.keys(t))if(!this._columns.has(r))throw new j(r,this._columnOrder);const n=new Map,s=[];for(const r of this._columnOrder){const o=t[r]??r;n.set(o,this._columns.get(r)),s.push(o)}return new k(n,s)}filter(t){if(t instanceof C){const l=t;if(l._op!==void 0&&l._left instanceof jt&&l._right instanceof Q){const g=l._left.dependencies[0],h=l._right._value,m=this._columns.get(g);if(m){let p=0;for(let w=0;w<this.length;w++){const b=m.get(w);if(b===null||h===null)continue;let S=!1;switch(l._op){case"eq":S=b===h;break;case"neq":S=b!==h;break;case"gt":S=b>h;break;case"gte":S=b>=h;break;case"lt":S=b<h;break;case"lte":S=b<=h;break}S&&p++}if(p===this.length)return this;if(p===0)return this.slice(0,0);const d=new Int32Array(p);let _=0;for(let w=0;w<this.length;w++){const b=m.get(w);if(b===null||h===null)continue;let S=!1;switch(l._op){case"eq":S=b===h;break;case"neq":S=b!==h;break;case"gt":S=b>h;break;case"gte":S=b>=h;break;case"lt":S=b<h;break;case"lte":S=b<=h;break}S&&(d[_++]=w)}return this._takeByInt32Indices(d)}}const c=t.evaluate(this);let u=0;for(let g=0;g<this.length;g++)c.get(g)===!0&&u++;if(u===this.length)return this;if(u===0)return this.slice(0,0);const f=new Int32Array(u);let a=0;for(let g=0;g<this.length;g++)c.get(g)===!0&&(f[a++]=g);return this._takeByInt32Indices(f)}const n=t;let s=0;for(let i=0;i<this.length;i++)n(this.row(i))&&s++;if(s===this.length)return this;if(s===0)return this.slice(0,0);const r=new Int32Array(s);let o=0;for(let i=0;i<this.length;i++)n(this.row(i))&&(r[o++]=i);return this._takeByInt32Indices(r)}apply(t){if(this.length===0)return new k(new Map,[...this._columnOrder]);const n=[];for(let s=0;s<this.length;s++)n.push(t(this.row(s)));return k.fromRows(n)}where(t,n,s){const r=st(t),o=s;let i;switch(n){case"=":i=r.eq(o);break;case"!=":i=r.neq(o);break;case">":i=r.gt(o);break;case">=":i=r.gte(o);break;case"<":i=r.lt(o);break;case"<=":i=r.lte(o);break}return this.filter(i)}sortBy(t,n){const s=Array.isArray(t)?t:[t],r=Array.isArray(n)?n:s.map(()=>n??"asc");for(const u of s)if(!this._columns.has(u))throw new j(u,this._columnOrder);if(s.length===1){const u=this._columns.get(s[0]),f=new Array(this.length);for(let p=0;p<this.length;p++)f[p]=u.get(p);const a=r[0]==="desc",g=Array.from({length:this.length},(p,d)=>d);g.sort((p,d)=>{const _=f[p],w=f[d],b=_==null,S=w==null;if(b&&S)return 0;if(b)return 1;if(S)return-1;let y=0;return typeof _=="number"&&typeof w=="number"?y=_-w:typeof _=="string"&&typeof w=="string"?y=_<w?-1:_>w?1:0:typeof _=="boolean"&&typeof w=="boolean"?y=(_?1:0)-(w?1:0):_ instanceof Date&&w instanceof Date&&(y=_.getTime()-w.getTime()),a?-y:y});const h=new Int32Array(g),m=new Map;for(const p of this._columnOrder)m.set(p,this._columns.get(p).take(h));return new k(m,[...this._columnOrder])}if(s.length===2&&this._columns.get(s[0]).dtype==="utf8"&&(this._columns.get(s[1]).dtype==="f64"||this._columns.get(s[1]).dtype==="i32")){const u=this._columns.get(s[0]),f=this._columns.get(s[1]),a=new Array(this.length),g=new Array(this.length);for(let _=0;_<this.length;_++)a[_]=u.get(_),g[_]=f.get(_);const h=r[0]==="desc",m=r[1]==="desc",p=Array.from({length:this.length},(_,w)=>w);p.sort((_,w)=>{const b=a[_],S=a[w],y=b===null,v=S===null;if(!y||!v){if(y)return 1;if(v)return-1;const J=b<S?-1:b>S?1:0;if(J!==0)return h?-J:J}const $=g[_],O=g[w],R=$===null,B=O===null;if(R&&B)return 0;if(R)return 1;if(B)return-1;const z=$-O;return m?-z:z});const d=new Int32Array(p);return this._takeByInt32Indices(d)}const o=s.map(u=>{const f=this._columns.get(u),a=new Array(this.length);for(let g=0;g<this.length;g++)a[g]=f.get(g);return a}),i=Array.from({length:this.length},(u,f)=>f);i.sort((u,f)=>{for(let a=0;a<s.length;a++){const g=o[a][u],h=o[a][f],m=g==null,p=h==null;if(m&&p)continue;if(m)return 1;if(p)return-1;let d=0;if(g instanceof Date&&h instanceof Date?d=g.getTime()-h.getTime():typeof g=="string"&&typeof h=="string"?d=g<h?-1:g>h?1:0:typeof g=="number"&&typeof h=="number"?d=g-h:typeof g=="boolean"&&typeof h=="boolean"&&(d=(g?1:0)-(h?1:0)),d!==0)return r[a]==="desc"?-d:d}return 0});const l=new Int32Array(i),c=new Map;for(const u of this._columnOrder)c.set(u,this._columns.get(u).take(l));return new k(c,[...this._columnOrder])}unique(t,n="first"){const s=t===void 0?this._columnOrder:Array.isArray(t)?t:[t];for(const i of s)if(!this._columns.has(i))throw new j(i,this._columnOrder);const r=new Set,o=[];if(n==="first")for(let i=0;i<this.length;i++){const l=this._rowKey(i,s);r.has(l)||(r.add(l),o.push(i))}else{const i=new Map,l=[];for(let c=0;c<this.length;c++){const u=this._rowKey(c,s);i.has(u)||l.push(u),i.set(u,c)}for(const c of l)o.push(i.get(c))}return this._takeByIndices(o)}sample(t,n){if(this.length===0)return this.clone();let s;if(t>=1)s=Math.min(Math.floor(t),this.length);else if(t>0&&t<1)s=Math.max(1,Math.round(t*this.length));else throw new F("INVALID_OPERATION",`sample size must be positive, got ${t}`);const r=n?.seed!==void 0?Us(n.seed):Math.random,o=Array.from({length:this.length},(i,l)=>l);for(let i=o.length-1;i>0;i--){const l=Math.floor(r()*(i+1)),c=o[i];o[i]=o[l],o[l]=c}return this._takeByIndices(o.slice(0,s))}groupBy(...t){return new cs(this,t)}join(t,n,s="inner",r){return as(this,t,n,s,r)}pivot(t){return _s(this,t)}melt(t){return Ss(this,t)}explode(t){if(!this._columns.has(t))throw new j(t,this._columnOrder);const n=this._columns.get(t),s=this._columnOrder.filter(o=>o!==t),r={};for(const o of this._columnOrder)r[o]=[];for(let o=0;o<this.length;o++){const i=n.get(o);if(i===null){r[t].push(null);for(const l of s)r[l].push(this._columns.get(l).get(o))}else if(Array.isArray(i)){if(i.length===0)continue;for(const l of i){r[t].push(l===void 0?null:l);for(const c of s)r[c].push(this._columns.get(c).get(o))}}else{r[t].push(i);for(const l of s)r[l].push(this._columns.get(l).get(o))}}return k.fromColumns(r)}transpose(t){return Cs(this,t)}static concat(...t){return Wt(...t)}_rowKey(t,n){const s=[];for(const r of n){const o=this._columns.get(r).get(t);o===null?s.push("\0null"):o instanceof Date?s.push(`\0d${o.getTime()}`):typeof o=="number"||typeof o=="string"||typeof o=="boolean"?s.push(`\0${typeof o}${String(o)}`):s.push(`\0obj${JSON.stringify(o)}`)}return s.join("")}_takeByIndices(t){const n=new Int32Array(t);return this._takeByInt32Indices(n)}_takeByInt32Indices(t){const n=new Map;for(const s of this._columnOrder)n.set(s,this._columns.get(s).take(t));return new k(n,[...this._columnOrder])}dropNull(t){const n=t===void 0?this._columnOrder:Array.isArray(t)?t:[t];for(const r of n)if(!this._columns.has(r))throw new j(r,this._columnOrder);const s=[];for(let r=0;r<this.length;r++){let o=!1;for(const i of n)if(this._columns.get(i).get(r)===null){o=!0;break}o||s.push(r)}return this._takeByIndices(s)}fillNull(t){if(typeof t=="string")return this._fillNullDirectional(t);for(const s of Object.keys(t))if(!this._columns.has(s))throw new j(s,this._columnOrder);const n=new Map;for(const s of this._columnOrder){const r=this._columns.get(s),o=t[s];if(o!==void 0){const i=[];for(let l=0;l<r.length;l++){const c=r.get(l);i.push(c===null?o:c)}n.set(s,ft(r.dtype,i))}else n.set(s,r)}return new k(n,[...this._columnOrder])}_fillNullDirectional(t){const n=new Map;for(const s of this._columnOrder){const r=this._columns.get(s);if(r.nullCount===0){n.set(s,r);continue}const o=[];for(let i=0;i<r.length;i++)o.push(r.get(i));if(t==="forward")for(let i=1;i<o.length;i++)o[i]===null&&o[i-1]!==null&&(o[i]=o[i-1]);else for(let i=o.length-2;i>=0;i--)o[i]===null&&o[i+1]!==null&&(o[i]=o[i+1]);n.set(s,ft(r.dtype,o))}return new k(n,[...this._columnOrder])}cast(t){for(const s of Object.keys(t))if(!this._columns.has(s))throw new j(s,this._columnOrder);const n=new Map;for(const s of this._columnOrder){const r=t[s];if(r){const i=new N(s,this._columns.get(s)).cast(r);n.set(s,i.column)}else n.set(s,this._columns.get(s))}return new k(n,[...this._columnOrder])}toString(t){const n=t?.maxRows??10,s=t?.maxCols??10,[r,o]=this.shape;if(o===0||r===0)return`Empty DataFrame
0 rows x ${o} columns`;const i=this._columnOrder;let l;if(i.length>s){const S=Math.floor(s/2);l=[...i.slice(0,S),"...",...i.slice(i.length-S)]}else l=[...i];let c;if(r>n){const S=Math.floor(n/2);c=[...Array.from({length:S},(y,v)=>v),-1,...Array.from({length:S},(y,v)=>r-S+v)]}else c=Array.from({length:r},(S,y)=>y);const u=S=>S===null?"null":S instanceof Date?S.toISOString():typeof S=="number"||typeof S=="string"||typeof S=="boolean"?String(S):JSON.stringify(S),f=["",...l],a=[];for(const S of c){if(S===-1){a.push(f.map(()=>"..."));continue}const y=[String(S)];for(const v of l)v==="..."?y.push("..."):y.push(u(this._columns.get(v).get(S)));a.push(y)}const g=f.map((S,y)=>{let v=S.length;for(const $ of a)v=Math.max(v,$[y].length);return v}),h=(S,y,v)=>v===0?S.padStart(y):S.padEnd(y),m="",p=[],d=" "+f.map((S,y)=>h(S,g[y],y)).join("  ")+" ",_=""+g.map(S=>m.repeat(S)).join("")+"",w=""+g.map(S=>m.repeat(S)).join("")+"",b=""+g.map(S=>m.repeat(S)).join("")+"";p.push(_),p.push(d),p.push(w);for(const S of a)p.push(" "+S.map((y,v)=>h(y,g[v],v)).join("  ")+" ");return p.push(b),p.push(`${r} rows x ${o} columns`),p.join(`
`)}print(t){console.log(this.toString(t))}describe(){const n={stat:["count","mean","std","min","max"]};for(const s of this._columnOrder){const r=this._columns.get(s),o=r.dtype;if(o==="f64"||o==="i32"){const i=new N(s,r),l=i.length-i.nullCount,c=i.mean(),u=i.std(),f=i.min(),a=i.max();n[s]=[l,c,u,f,a]}}return k.fromColumns(n)}memoryUsage(){let t=0;for(const n of this._columnOrder)t+=this._columns.get(n).estimatedMemoryBytes();return t}info(){const[t,n]=this.shape,s=[];s.push(`DataFrame: ${t} rows x ${n} columns`),s.push("");const r=Math.max(6,...this._columnOrder.map(l=>l.length)),o=`${"Column".padEnd(r)}  ${"DType".padEnd(10)}  ${"Null Count".padEnd(10)}  Memory`;s.push(o),s.push("".repeat(o.length));let i=0;for(const l of this._columnOrder){const c=this._columns.get(l),u=c.dtype,f=c.nullCount,a=c.estimatedMemoryBytes();i+=a,s.push(`${l.padEnd(r)}  ${u.padEnd(10)}  ${String(f).padEnd(10)}  ${pe(a)}`)}s.push("".repeat(o.length)),s.push(`Total memory: ${pe(i)}`),console.log(s.join(`
`))}static fromColumns(t){const n=Object.keys(t);if(n.length===0)return k.empty();const s=n[0],r=t[s].length;for(const i of n)if(t[i].length!==r)throw new ht(`Column '${i}' has length ${t[i].length}, expected ${r}`);const o=new Map;for(const i of n){const l=t[i],c=ge(l),u=ft(c,l);o.set(i,u)}return new k(o,n)}static fromRows(t){if(t.length===0)return k.empty();const n=new Set;for(const o of t)for(const i of Object.keys(o))n.add(i);const s=[...n],r={};for(const o of s)r[o]=[];for(const o of t){const i=o;for(const l of s){const c=l in i?i[l]:null;r[l].push(c===void 0?null:c)}}return k.fromColumns(r)}static empty(){return new k(new Map,[])}static range(t,n,s,r=1){if(r===0)throw new F("INVALID_OPERATION","step must not be zero");if(n>=s)throw new F("INVALID_OPERATION",`start (${n}) must be less than end (${s})`);const o=Math.ceil((s-n)/r),i=new Float64Array(o);for(let f=0;f<o;f++)i[f]=n+f*r;const l=new V(o,!0),c=new x(i,l),u=new Map;return u.set(t,c),new k(u,[t])}static linspace(t,n,s,r){if(r<2)throw new F("INVALID_OPERATION","count must be at least 2");const o=new Float64Array(r),i=(s-n)/(r-1);for(let f=0;f<r;f++)o[f]=n+f*i;const l=new V(r,!0),c=new x(o,l),u=new Map;return u.set(t,c),new k(u,[t])}static async fromCSV(t,n={}){let s;if(typeof t!="string")try{const o=[];for await(const i of t)o.push(Buffer.isBuffer(i)?i:Buffer.from(i));s=Buffer.concat(o).toString(n.encoding??"utf-8")}catch(o){if(o instanceof A)throw o;const i=o instanceof Error?o.message:String(o);throw new A(`Failed to read CSV from stream: ${i}`)}else if(n.parse==="string")s=t;else if(t.startsWith("http://")||t.startsWith("https://"))try{const o=await fetch(t);if(!o.ok)throw new A(`Failed to fetch CSV from '${t}': HTTP ${String(o.status)} ${o.statusText}`);s=await o.text()}catch(o){if(o instanceof A)throw o;const i=o instanceof Error?o.message:String(o);throw new A(`Failed to fetch CSV from '${t}': ${i}`)}else try{s=await(await import("./__vite-browser-external-9wXp6ZBx.js")).readFile(t,n.encoding??"utf-8")}catch(o){if(o instanceof A)throw o;const i=o instanceof Error?o.message:String(o);throw new A(`Failed to read CSV file '${t}': ${i}`)}const r=wn(s,n);return he(r.header,r.columns,r.inferredTypes)}static async*streamCSV(t,n={}){for await(const s of $n(t,n))yield he(s.header,s.rawColumns,s.inferredTypes)}static scanCSV(t,n={}){const s=k.empty(),r=zt(s);return r.collect.bind(r),r.collect=async()=>{const o=[];for await(const i of k.streamCSV(t,n))o.push(i);return o.length===0?k.empty():o.length===1?o[0]:Wt(...o)},r}static async*streamNDJSON(t,n={}){for await(const s of On(t,n))yield k.fromRows(s)}static scanNDJSON(t,n={}){const s=k.empty(),r=zt(s);return r.collect.bind(r),r.collect=async()=>{const o=[];for await(const i of k.streamNDJSON(t,n))o.push(i);return o.length===0?k.empty():o.length===1?o[0]:Wt(...o)},r}toCSV(t,n){let s,r,o;typeof t=="string"?(s=t,o=n??{}):t!=null&&typeof t=="object"&&"write"in t&&typeof t.write=="function"?(r=t,o=n??{}):o=t??{};const{header:i,rows:l}=this._extractRows(),c=kn(i,l,o);if(r){const u=r;return new Promise((f,a)=>{let g=!1;const h=m=>{g||(g=!0,a(new A(`Failed to write CSV to stream: ${m.message}`)))};u.once("error",h),u.write(c,"utf-8",m=>{if(m)h(m);else{if(g)return;g=!0,u.removeListener("error",h),f()}})})}return s?import("./__vite-browser-external-9wXp6ZBx.js").then(u=>u.writeFile(s,c,"utf-8").catch(f=>{const a=f instanceof Error?f.message:String(f);throw new A(`Failed to write CSV file '${s}': ${a}`)})):c}static async fromJSON(t,n={}){let s;if(n.parse==="string")s=t;else try{s=await(await import("./__vite-browser-external-9wXp6ZBx.js")).readFile(t,"utf-8")}catch(o){if(o instanceof A)throw o;const i=o instanceof Error?o.message:String(o);throw new A(`Failed to read JSON file '${t}': ${i}`)}let r=JSON.parse(s);if(n.path){const o=n.path.split(".");for(const i of o)if(r!==null&&typeof r=="object"&&!Array.isArray(r))r=r[i];else throw new A(`JSON path '${n.path}' not found: '${i}' is not an object`)}if(!Array.isArray(r))throw new A("JSON content must be an array of objects");return k.fromRows(r)}toJSON(t,n){let s,r;typeof t=="string"?(s=t,r=n??{}):r=t??{};const{header:o,rows:i}=this._extractRows(),l=Rn(o,i,r);return s?import("./__vite-browser-external-9wXp6ZBx.js").then(c=>c.writeFile(s,l,"utf-8").catch(u=>{const f=u instanceof Error?u.message:String(u);throw new A(`Failed to write JSON file '${s}': ${f}`)})):l}static async fromNDJSON(t,n={}){let s;if(n.parse==="string")s=t;else try{s=await(await import("./__vite-browser-external-9wXp6ZBx.js")).readFile(t,"utf-8")}catch(i){if(i instanceof A)throw i;const l=i instanceof Error?i.message:String(i);throw new A(`Failed to read NDJSON file '${t}': ${l}`)}const o=s.split(`
`).filter(i=>i.trim()!=="").map(i=>JSON.parse(i));return k.fromRows(o)}static async fromExcel(t,n={}){const s=await Bn(t,n);if(s.header.length===0)return k.empty();const r=new Map;for(const o of s.header){const i=s.inferredTypes[o]??"f64",l=s.columns[o];r.set(o,ft(i,l))}return new k(r,[...s.header])}static async fromParquet(t,n={}){const s=await Wn(t,n);if(s.header.length===0)return k.empty();const r=new Map;for(const o of s.header){const i=s.inferredTypes[o]??"f64",l=s.columns[o];r.set(o,ft(i,l))}return new k(r,[...s.header])}async toExcel(t,n={}){const{header:s,rows:r}=this._extractRows();await Kn(t,s,r,n)}async toParquet(t,n={}){const s=this._columnOrder,r={};for(const o of s){const i=this._columns.get(o),l=[];for(let c=0;c<i.length;c++)l.push(i.get(c));r[o]={values:l,dtype:i.dtype}}await Gn(t,s,r,n)}async toArrow(){return Xn({columnOrder:this._columnOrder,getColumnValues:t=>{const n=this._columns.get(t),s=[];for(let r=0;r<n.length;r++)s.push(n.get(r));return{values:s,dtype:n.dtype}}})}static fromArrow(t){const n=es(t);if(n.header.length===0)return k.empty();const s=new Map;for(const r of n.header){const o=n.inferredTypes[r]??"f64",i=n.columns[r];s.set(r,ft(o,i))}return new k(s,[...n.header])}async toArrowIPC(){let t;try{t=await import("apache-arrow")}catch{throw new A("apache-arrow is required for Arrow IPC serialization but is not installed. Run: npm install apache-arrow")}const n=await this.toArrow();return t.tableToIPC(n,"stream")}static async fromArrowIPC(t){let n;try{n=await import("apache-arrow")}catch{throw new A("apache-arrow is required for Arrow IPC deserialization but is not installed. Run: npm install apache-arrow")}const s=n.tableFromIPC(t);return k.fromArrow(s)}toNDJSON(t){const{header:n,rows:s}=this._extractRows(),r=Tn(n,s);return t?import("./__vite-browser-external-9wXp6ZBx.js").then(o=>o.writeFile(t,r,"utf-8").catch(i=>{const l=i instanceof Error?i.message:String(i);throw new A(`Failed to write NDJSON file '${t}': ${l}`)})):r}toSQL(t,n){const{header:s,rows:r}=this._extractRows();return As(t,s,r,n)}_extractRows(){const t=this._columnOrder,n=[];for(let s=0;s<this.length;s++){const r=[];for(const o of this._columnOrder)r.push(this._columns.get(o).get(s));n.push(r)}return{header:t,rows:n}}union(t){return vs(this,t)}intersection(t){return xs(this,t)}difference(t){return Ns(this,t)}query(t){return Vs(this,t)}static registerReader(t,n){const s=t.startsWith(".")?t.slice(1):t;k._readers.set(s.toLowerCase(),n)}static registerWriter(t,n){const s=t.startsWith(".")?t.slice(1):t;k._writers.set(s.toLowerCase(),n)}static async fromFile(t,n){const s=t.split(".").pop()?.toLowerCase();if(!s)throw new A(`Cannot determine file extension from path: '${t}'`);const r=k._readers.get(s);if(!r)throw new A(`No reader registered for extension '.${s}'. Use DataFrame.registerReader('${s}', readerFn) to register one.`);const o=await import("./__vite-browser-external-9wXp6ZBx.js");let i;try{i=await o.readFile(t)}catch(l){const c=l instanceof Error?l.message:String(l);throw new A(`Failed to read file '${t}': ${c}`)}return r(i,n)}async toFile(t,n){const s=t.split(".").pop()?.toLowerCase();if(!s)throw new A(`Cannot determine file extension from path: '${t}'`);const r=k._writers.get(s);if(!r)throw new A(`No writer registered for extension '.${s}'. Use DataFrame.registerWriter('${s}', writerFn) to register one.`);await r(this,t,n)}};function Us(e){let t=e|0;return()=>{t=t+1831565813|0;let n=Math.imul(t^t>>>15,1|t);return n=n+Math.imul(n^n>>>7,61|n)^n,((n^n>>>14)>>>0)/4294967296}}function he(e,t,n){if(e.length===0)return Mt.empty();const s=new Map;for(const r of e){const o=n[r]??"utf8",i=t[r],l=js(i,o);s.set(r,ft(o,l))}return new Mt(s,[...e])}function js(e,t){switch(t){case"f64":case"i32":return e.map(n=>n===null?null:Number(n));case"bool":return e.map(n=>n===null?null:n.toLowerCase()==="true");case"date":return e.map(n=>n===null?null:new Date(n));default:return e}}function ge(e){for(const t of e)if(t!=null){if(typeof t=="number")return"f64";if(typeof t=="string")return"utf8";if(typeof t=="boolean")return"bool";if(t instanceof Date)return"date";if(Array.isArray(t)||typeof t=="object")return"object"}return"f64"}function ft(e,t){switch(e){case"f64":return x.from(t);case"i32":return lt.from(t);case"utf8":return q.from(t);case"bool":return L.from(t);case"date":return H.from(t);case"object":return gt.from(t);default:throw new F("INVALID_OPERATION",`Unsupported dtype for column construction: ${e}`)}}function pe(e){return e<1024?`${e} B`:e<1024*1024?`${(e/1024).toFixed(1)} KB`:e<1024*1024*1024?`${(e/(1024*1024)).toFixed(1)} MB`:`${(e/(1024*1024*1024)).toFixed(1)} GB`}Je((e,t)=>new Mt(e,t));function me(e){return typeof e=="number"?"f64":typeof e=="string"?"utf8":typeof e=="boolean"?"bool":e instanceof Date?"date":"f64"}function Bs(e,t){switch(e){case"f64":return x.from(t);case"utf8":return q.from(t);case"bool":return L.from(t);case"date":return H.from(t);default:return x.from(t)}}var Ps=class extends C{_clauses;_otherwise;constructor(e,t){super(),this._clauses=e,this._otherwise=t}get dependencies(){const e=new Set;for(const t of this._clauses){for(const n of t.condition.dependencies)e.add(n);for(const n of t.value.dependencies)e.add(n)}if(this._otherwise)for(const t of this._otherwise.dependencies)e.add(t);return[...e]}toString(){const e=this._clauses.map(t=>`WHEN ${t.condition.toString()} THEN ${t.value.toString()}`);return this._otherwise&&e.push(`ELSE ${this._otherwise.toString()}`),`CASE ${e.join(" ")} END`}evaluate(e){const t=e.length,n=this._clauses.map(u=>u.condition.evaluate(e)),s=this._clauses.map(u=>u.value.evaluate(e)),r=this._otherwise?this._otherwise.evaluate(e):null,o=[];let i=null;for(let u=0;u<t;u++){let f=!1;for(let a=0;a<this._clauses.length;a++)if(n[a].get(u)===!0){const h=s[a].get(u);o.push(h),i===null&&h!==null&&(i=me(h)),f=!0;break}if(!f)if(r){const a=r.get(u);o.push(a),i===null&&a!==null&&(i=me(a))}else o.push(null)}const c=Bs(i??"f64",o);return new N("",c)}},qs=class{_condition;constructor(e){this._condition=e}then(e){const t=e instanceof C?e:new Q(e);return new Ae([{condition:this._condition,value:t}])}},Ae=class{_clauses;constructor(e){this._clauses=e}when(e){return new Ws(this._clauses,e)}otherwise(e){const t=e instanceof C?e:new Q(e);return new Ps(this._clauses,t)}},Ws=class{_clauses;_condition;constructor(e,t){this._clauses=e,this._condition=t}then(e){const t=e instanceof C?e:new Q(e);return new Ae([...this._clauses,{condition:this._condition,value:t}])}};function Nr(e){return new qs(e)}var Kt=class extends C{_inner;_op;constructor(e,t){super(),this._inner=e,this._op=t}get dependencies(){return this._inner.dependencies}toString(){return`${this._inner.toString()}.str.${this._op}()`}evaluate(e){const t=this._inner.evaluate(e),n=[];for(let s=0;s<t.length;s++){const r=t.get(s);if(r===null)n.push(null);else switch(this._op){case"toLowerCase":n.push(r.toLowerCase());break;case"toUpperCase":n.push(r.toUpperCase());break;case"trim":n.push(r.trim());break}}return new N("",q.from(n))}},zs=class extends C{_inner;_pattern;constructor(e,t){super(),this._inner=e,this._pattern=t}get dependencies(){return this._inner.dependencies}toString(){return`${this._inner.toString()}.str.contains("${this._pattern}")`}evaluate(e){const t=this._inner.evaluate(e),n=[];for(let s=0;s<t.length;s++){const r=t.get(s);n.push(r===null?null:r.includes(this._pattern))}return new N("",L.from(n))}},Ks=class extends C{_inner;_prefix;constructor(e,t){super(),this._inner=e,this._prefix=t}get dependencies(){return this._inner.dependencies}toString(){return`${this._inner.toString()}.str.startsWith("${this._prefix}")`}evaluate(e){const t=this._inner.evaluate(e),n=[];for(let s=0;s<t.length;s++){const r=t.get(s);n.push(r===null?null:r.startsWith(this._prefix))}return new N("",L.from(n))}},Hs=class extends C{_inner;_suffix;constructor(e,t){super(),this._inner=e,this._suffix=t}get dependencies(){return this._inner.dependencies}toString(){return`${this._inner.toString()}.str.endsWith("${this._suffix}")`}evaluate(e){const t=this._inner.evaluate(e),n=[];for(let s=0;s<t.length;s++){const r=t.get(s);n.push(r===null?null:r.endsWith(this._suffix))}return new N("",L.from(n))}},Js=class extends C{_inner;_pattern;_replacement;constructor(e,t,n){super(),this._inner=e,this._pattern=t,this._replacement=n}get dependencies(){return this._inner.dependencies}toString(){return`${this._inner.toString()}.str.replace("${this._pattern}", "${this._replacement}")`}evaluate(e){const t=this._inner.evaluate(e),n=[];for(let s=0;s<t.length;s++){const r=t.get(s);n.push(r===null?null:r.replaceAll(this._pattern,this._replacement))}return new N("",q.from(n))}},Ys=class extends C{_inner;_start;_end;constructor(e,t,n){super(),this._inner=e,this._start=t,this._end=n}get dependencies(){return this._inner.dependencies}toString(){return`${this._inner.toString()}.str.slice(${this._start}${this._end!==void 0?`, ${this._end}`:""})`}evaluate(e){const t=this._inner.evaluate(e),n=[];for(let s=0;s<t.length;s++){const r=t.get(s);n.push(r===null?null:r.slice(this._start,this._end))}return new N("",q.from(n))}},Gs=class extends C{_inner;constructor(e){super(),this._inner=e}get dependencies(){return this._inner.dependencies}toString(){return`${this._inner.toString()}.str.length()`}evaluate(e){const t=this._inner.evaluate(e),n=[];for(let s=0;s<t.length;s++){const r=t.get(s);n.push(r===null?null:r.length)}return new N("",x.from(n))}},Qs=class extends C{_parts;constructor(e){super(),this._parts=e}get dependencies(){const e=new Set;for(const t of this._parts)if(t instanceof C)for(const n of t.dependencies)e.add(n);return[...e]}toString(){return`concat(${this._parts.map(t=>t instanceof C?t.toString():`"${t}"`).join(", ")})`}evaluate(e){const t=e.length,n=this._parts.map(r=>r instanceof C?r.evaluate(e):r),s=[];for(let r=0;r<t;r++){let o=!1,i="";for(const l of n)if(typeof l=="string")i+=l;else{const c=l.get(r);if(c===null){o=!0;break}i+=c}s.push(o?null:i)}return new N("",q.from(s))}},kr=class{_expr;constructor(e){this._expr=e}toLowerCase(){return new Kt(this._expr,"toLowerCase")}toUpperCase(){return new Kt(this._expr,"toUpperCase")}trim(){return new Kt(this._expr,"trim")}contains(e){return new zs(this._expr,e)}startsWith(e){return new Ks(this._expr,e)}endsWith(e){return new Hs(this._expr,e)}replace(e,t){return new Js(this._expr,e,t)}slice(e,t){return new Ys(this._expr,e,t)}length(){return new Gs(this._expr)}concat(...e){return new Qs([this._expr,...e])}};function Zs(e,t){switch(t){case"year":return e.getFullYear();case"month":return e.getMonth()+1;case"day":return e.getDate();case"hour":return e.getHours();case"minute":return e.getMinutes();case"second":return e.getSeconds();case"dayOfWeek":return e.getDay();case"dayOfYear":{const n=new Date(e.getFullYear(),0,0),s=e.getTime()-n.getTime(),r=1e3*60*60*24;return Math.floor(s/r)}case"weekNumber":{const n=new Date(e.getTime());n.setHours(0,0,0,0),n.setDate(n.getDate()+3-(n.getDay()+6)%7);const s=new Date(n.getFullYear(),0,4),r=(n.getTime()-s.getTime())/(1e3*60*60*24);return 1+Math.round((r-3+(s.getDay()+6)%7)/7)}case"quarter":return Math.floor(e.getMonth()/3)+1;case"timestamp":return e.getTime()}}var X=class extends C{_inner;_op;constructor(e,t){super(),this._inner=e,this._op=t}get dependencies(){return this._inner.dependencies}toString(){return`${this._inner.toString()}.dt.${this._op}()`}evaluate(e){const t=this._inner.evaluate(e),n=[];for(let s=0;s<t.length;s++){const r=t.get(s);n.push(r===null?null:Zs(r,this._op))}return new N("",x.from(n))}},Xs=class extends C{_inner;_unit;constructor(e,t){super(),this._inner=e,this._unit=t}get dependencies(){return this._inner.dependencies}toString(){return`${this._inner.toString()}.dt.truncate("${this._unit}")`}evaluate(e){const t=this._inner.evaluate(e),n=[];for(let s=0;s<t.length;s++){const r=t.get(s);r===null?n.push(null):n.push(nr(r,this._unit))}return new N("",H.from(n))}},tr=class extends C{_left;_right;_unit;constructor(e,t,n){super(),this._left=e,this._right=t,this._unit=n}get dependencies(){return[...new Set([...this._left.dependencies,...this._right.dependencies])]}toString(){return`dateDiff(${this._left.toString()}, ${this._right.toString()}, "${this._unit}")`}evaluate(e){const t=this._left.evaluate(e),n=this._right.evaluate(e),s=t.length,r=[];for(let o=0;o<s;o++){const i=t.get(o),l=n.get(o);if(i===null||l===null)r.push(null);else{const c=i.getTime()-l.getTime();r.push(er(c,this._unit))}}return new N("",x.from(r))}};function er(e,t){switch(t){case"milliseconds":return e;case"seconds":return e/1e3;case"minutes":return e/(1e3*60);case"hours":return e/(1e3*60*60);case"days":return e/(1e3*60*60*24)}}function nr(e,t){switch(t){case"year":return new Date(e.getFullYear(),0,1);case"month":return new Date(e.getFullYear(),e.getMonth(),1);case"day":return new Date(e.getFullYear(),e.getMonth(),e.getDate());case"hour":return new Date(e.getFullYear(),e.getMonth(),e.getDate(),e.getHours());case"minute":return new Date(e.getFullYear(),e.getMonth(),e.getDate(),e.getHours(),e.getMinutes());case"second":return new Date(e.getFullYear(),e.getMonth(),e.getDate(),e.getHours(),e.getMinutes(),e.getSeconds())}}var Ar=class{_expr;constructor(e){this._expr=e}year(){return new X(this._expr,"year")}month(){return new X(this._expr,"month")}day(){return new X(this._expr,"day")}hour(){return new X(this._expr,"hour")}minute(){return new X(this._expr,"minute")}second(){return new X(this._expr,"second")}dayOfWeek(){return new X(this._expr,"dayOfWeek")}dayOfYear(){return new X(this._expr,"dayOfYear")}weekNumber(){return new X(this._expr,"weekNumber")}quarter(){return new X(this._expr,"quarter")}timestamp(){return new X(this._expr,"timestamp")}truncate(e){return new Xs(this._expr,e)}diff(e,t="days"){return new tr(this._expr,e,t)}},Et=class extends C{_source;_descending;constructor(e,t=!1){super(),this._source=e,this._descending=t}get dependencies(){return this._source.dependencies}_sortCompare(e,t){return this._descending?-It(e,t):It(e,t)}},sr=class $e extends Et{toString(){return`rank(${this._source.toString()})`}withDescending(t){return new $e(this._source,t)}evaluate(t){const n=this._source.evaluate(t),s=n.length,r=[];for(let l=0;l<s;l++)r.push({value:n.get(l),idx:l});r.sort((l,c)=>this._sortCompare(l.value,c.value));const o=new Array(s);let i=1;for(let l=0;l<r.length;l++)l>0&&It(r[l].value,r[l-1].value)!==0&&(i=l+1),o[r[l].idx]=i;return new N("rank",x.from(o))}},rr=class Me extends Et{toString(){return`dense_rank(${this._source.toString()})`}withDescending(t){return new Me(this._source,t)}evaluate(t){const n=this._source.evaluate(t),s=n.length,r=[];for(let l=0;l<s;l++)r.push({value:n.get(l),idx:l});r.sort((l,c)=>this._sortCompare(l.value,c.value));const o=new Array(s);let i=1;for(let l=0;l<r.length;l++)l>0&&It(r[l].value,r[l-1].value)!==0&&i++,o[r[l].idx]=i;return new N("dense_rank",x.from(o))}},or=class Ie extends Et{toString(){return`row_number(${this._source.toString()})`}withDescending(t){return new Ie(this._source,t)}evaluate(t){const n=this._source.evaluate(t),s=n.length,r=new Array(s);for(let l=0;l<s;l++)r[l]=n.get(l);const o=Array.from({length:s},(l,c)=>c);o.sort((l,c)=>this._sortCompare(r[l],r[c]));const i=new Array(s);for(let l=0;l<o.length;l++)i[o[l]]=l+1;return new N("row_number",x.from(i))}},ir=class Ee extends Et{toString(){return`percent_rank(${this._source.toString()})`}withDescending(t){return new Ee(this._source,t)}evaluate(t){const n=this._source.evaluate(t),s=n.length;if(s<=1){const l=new Array(s).fill(0);return new N("percent_rank",x.from(l))}const r=[];for(let l=0;l<s;l++)r.push({value:n.get(l),idx:l});r.sort((l,c)=>this._sortCompare(l.value,c.value));const o=new Array(s);let i=1;for(let l=0;l<r.length;l++)l>0&&It(r[l].value,r[l-1].value)!==0&&(i=l+1),o[r[l].idx]=(i-1)/(s-1);return new N("percent_rank",x.from(o))}},lr=class De extends Et{_n;constructor(t,n,s=!1){super(t,s),this._n=n}toString(){return`ntile(${this._source.toString()}, ${this._n})`}withDescending(t){return new De(this._source,this._n,t)}evaluate(t){const n=this._source.evaluate(t),s=n.length,r=[];for(let i=0;i<s;i++)r.push({value:n.get(i),idx:i});r.sort((i,l)=>this._sortCompare(i.value,l.value));const o=new Array(s);for(let i=0;i<r.length;i++)o[r[i].idx]=Math.floor(i*this._n/s)+1;return new N("ntile",x.from(o))}};function It(e,t){if(e===null&&t===null)return 0;if(e===null)return 1;if(t===null)return-1;if(typeof e=="number"&&typeof t=="number")return e-t;if(typeof e=="string"&&typeof t=="string")return e<t?-1:e>t?1:0;if(e instanceof Date&&t instanceof Date)return e.getTime()-t.getTime();const n=typeof e=="string"?e:typeof e=="number"?`${e}`:typeof e=="boolean"?`${e}`:"object",s=typeof t=="string"?t:typeof t=="number"?`${t}`:typeof t=="boolean"?`${t}`:"object";return n<s?-1:n>s?1:0}var Tt=class extends C{_source;constructor(e){super(),this._source=e}get dependencies(){return this._source.dependencies}},cr=class extends Tt{toString(){return`cumSum(${this._source.toString()})`}evaluate(e){const t=this._source.evaluate(e),n=t.length,s=new Array(n);let r=0;for(let o=0;o<n;o++){const i=t.get(o);i!==null&&typeof i=="number"&&(r+=i),s[o]=r}return new N("cumSum",x.from(s))}},ur=class extends Tt{toString(){return`cumMax(${this._source.toString()})`}evaluate(e){const t=this._source.evaluate(e),n=t.length,s=new Array(n);let r=null;for(let o=0;o<n;o++){const i=t.get(o);i!==null&&typeof i=="number"&&(r=r===null?i:Math.max(r,i)),s[o]=r}return new N("cumMax",x.from(s))}},ar=class extends Tt{toString(){return`cumMin(${this._source.toString()})`}evaluate(e){const t=this._source.evaluate(e),n=t.length,s=new Array(n);let r=null;for(let o=0;o<n;o++){const i=t.get(o);i!==null&&typeof i=="number"&&(r=r===null?i:Math.min(r,i)),s[o]=r}return new N("cumMin",x.from(s))}},fr=class extends Tt{toString(){return`cumProd(${this._source.toString()})`}evaluate(e){const t=this._source.evaluate(e),n=t.length,s=new Array(n);let r=1;for(let o=0;o<n;o++){const i=t.get(o);i!==null&&typeof i=="number"&&(r*=i),s[o]=r}return new N("cumProd",x.from(s))}},hr=class extends Tt{toString(){return`cumCount(${this._source.toString()})`}evaluate(e){const t=this._source.evaluate(e),n=t.length,s=new Array(n);let r=0;for(let o=0;o<n;o++)t.get(o)!==null&&r++,s[o]=r;return new N("cumCount",x.from(s))}},Xt=class extends C{_source;_offset;constructor(e,t){super(),this._source=e,this._offset=t}get dependencies(){return this._source.dependencies}},gr=class extends Xt{toString(){return`shift(${this._source.toString()}, ${this._offset})`}evaluate(e){const t=this._source.evaluate(e),n=t.length,s=new Array(n);for(let r=0;r<n;r++){const o=r-this._offset;if(o<0||o>=n)s[r]=null;else{const i=t.get(o);s[r]=i!==null&&typeof i=="number"?i:null}}return new N("shift",x.from(s))}},pr=class extends Xt{toString(){return`diff(${this._source.toString()}, ${this._offset})`}evaluate(e){const t=this._source.evaluate(e),n=t.length,s=new Array(n);for(let r=0;r<n;r++){const o=r-this._offset;if(o<0||o>=n)s[r]=null;else{const i=t.get(r),l=t.get(o);i!==null&&typeof i=="number"&&l!==null&&typeof l=="number"?s[r]=i-l:s[r]=null}}return new N("diff",x.from(s))}},mr=class extends Xt{toString(){return`pctChange(${this._source.toString()}, ${this._offset})`}evaluate(e){const t=this._source.evaluate(e),n=t.length,s=new Array(n);for(let r=0;r<n;r++){const o=r-this._offset;if(o<0||o>=n)s[r]=null;else{const i=t.get(r),l=t.get(o);i!==null&&typeof i=="number"&&l!==null&&typeof l=="number"&&l!==0?s[r]=(i-l)/l:s[r]=null}}return new N("pctChange",x.from(s))}},Ft=class extends C{_source;_windowSize;constructor(e,t){super(),this._source=e,this._windowSize=t}get dependencies(){return this._source.dependencies}_getNumericValues(e){const t=this._source.evaluate(e),n=t.length,s=[];for(let r=0;r<n;r++){const o=t.get(r);s.push(o!==null&&typeof o=="number"?o:null)}return s}},dr=class extends Ft{toString(){return`rollingMean(${this._source.toString()}, ${this._windowSize})`}evaluate(e){const t=this._getNumericValues(e),n=t.length,s=new Array(n);for(let r=0;r<n;r++)if(r<this._windowSize-1)s[r]=null;else{let o=0,i=0;for(let l=r-this._windowSize+1;l<=r;l++){const c=t[l];c!==null&&(o+=c,i++)}s[r]=i>0?o/i:null}return new N("rollingMean",x.from(s))}},wr=class extends Ft{toString(){return`rollingSum(${this._source.toString()}, ${this._windowSize})`}evaluate(e){const t=this._getNumericValues(e),n=t.length,s=new Array(n);for(let r=0;r<n;r++)if(r<this._windowSize-1)s[r]=null;else{let o=0;for(let i=r-this._windowSize+1;i<=r;i++){const l=t[i];l!==null&&(o+=l)}s[r]=o}return new N("rollingSum",x.from(s))}},_r=class extends Ft{toString(){return`rollingStd(${this._source.toString()}, ${this._windowSize})`}evaluate(e){const t=this._getNumericValues(e),n=t.length,s=new Array(n);for(let r=0;r<n;r++)if(r<this._windowSize-1)s[r]=null;else{const o=[];for(let i=r-this._windowSize+1;i<=r;i++){const l=t[i];l!==null&&o.push(l)}if(o.length<2)s[r]=null;else{let i=0;for(const u of o)i+=u;const l=i/o.length;let c=0;for(const u of o)c+=(u-l)*(u-l);s[r]=Math.sqrt(c/(o.length-1))}}return new N("rollingStd",x.from(s))}},yr=class extends Ft{toString(){return`rollingMin(${this._source.toString()}, ${this._windowSize})`}evaluate(e){const t=this._getNumericValues(e),n=t.length,s=new Array(n);for(let r=0;r<n;r++)if(r<this._windowSize-1)s[r]=null;else{let o=null;for(let i=r-this._windowSize+1;i<=r;i++){const l=t[i];l!==null&&(o=o===null?l:Math.min(o,l))}s[r]=o}return new N("rollingMin",x.from(s))}},Sr=class extends Ft{toString(){return`rollingMax(${this._source.toString()}, ${this._windowSize})`}evaluate(e){const t=this._getNumericValues(e),n=t.length,s=new Array(n);for(let r=0;r<n;r++)if(r<this._windowSize-1)s[r]=null;else{let o=null;for(let i=r-this._windowSize+1;i<=r;i++){const l=t[i];l!==null&&(o=o===null?l:Math.max(o,l))}s[r]=o}return new N("rollingMax",x.from(s))}},br=class extends C{_source;_alpha;constructor(e,t){super(),this._source=e,this._alpha=t}get dependencies(){return this._source.dependencies}toString(){return`ewm(${this._source.toString()}, ${this._alpha})`}evaluate(e){const t=this._source.evaluate(e),n=t.length,s=new Array(n);let r=null;for(let o=0;o<n;o++){const i=t.get(o);i!==null&&typeof i=="number"&&(r===null?r=i:r=this._alpha*i+(1-this._alpha)*r),s[o]=r}return new N("ewm",x.from(s))}},Gt=class extends C{_inner;_partitionCols;constructor(e,t){super(),this._inner=e,this._partitionCols=t}get dependencies(){return[...new Set([...this._inner.dependencies,...this._partitionCols])]}toString(){return`${this._inner.toString()}.over(${this._partitionCols.join(", ")})`}evaluate(e){const t=e.length,n=new Array(t),s=new Map,r=this._partitionCols.map(i=>e.col(i).column);for(let i=0;i<t;i++){const l=Cr(r,i),c=s.get(l);c?c.push(i):s.set(l,[i])}const o=e.columns;for(const i of s.values()){const l=new Int32Array(i),c=new Map;for(const a of o)c.set(a,e.col(a).column.take(l));const u=new Mt(c,o),f=this._inner.evaluate(u);for(let a=0;a<i.length;a++)n[i[a]]=f.get(a)}return new N("over",x.from(n))}};function Cr(e,t){const n=[];for(const s of e){const r=s.get(t);r===null?n.push("\0null"):r instanceof Date?n.push(`\0d${r.getTime()}`):typeof r=="number"||typeof r=="string"||typeof r=="boolean"?n.push(`\0${typeof r}${String(r)}`):n.push(`\0obj${JSON.stringify(r)}`)}return n.join("")}var vr=class extends C{_inner;_orderCol;_direction;constructor(e,t,n="asc"){super(),this._inner=e,this._orderCol=t,this._direction=n}get dependencies(){return[...new Set([...this._inner.dependencies,this._orderCol])]}toString(){return`${this._inner.toString()}.orderBy(${this._orderCol}, ${this._direction})`}evaluate(e){const t=e.length,n=this._direction==="desc",s=Oe(this._inner,n),r=e.col(this._orderCol).column,o=[];for(let h=0;h<t;h++)o.push(h);const i=n?-1:1;o.sort((h,m)=>i*It(r.get(h),r.get(m)));const l=new Int32Array(o),c=e.columns,u=new Map;for(const h of c)u.set(h,e.col(h).column.take(l));const f=new Mt(u,c),a=s.evaluate(f),g=new Array(t);for(let h=0;h<t;h++)g[o[h]]=a.get(h);return new N("orderBy",x.from(g))}};function Oe(e,t){if(e instanceof Et)return e.withDescending(t);if(e instanceof Gt){const n=Oe(e._inner,t);return new Gt(n,e._partitionCols)}return e}C.prototype.rank=function(){return new sr(this)};C.prototype.denseRank=function(){return new rr(this)};C.prototype.rowNumber=function(){return new or(this)};C.prototype.percentRank=function(){return new ir(this)};C.prototype.ntile=function(e){return new lr(this,e)};C.prototype.cumSum=function(){return new cr(this)};C.prototype.cumMax=function(){return new ur(this)};C.prototype.cumMin=function(){return new ar(this)};C.prototype.cumProd=function(){return new fr(this)};C.prototype.cumCount=function(){return new hr(this)};C.prototype.shift=function(e){return new gr(this,e)};C.prototype.diff=function(e=1){return new pr(this,e)};C.prototype.pctChange=function(e=1){return new mr(this,e)};C.prototype.rollingMean=function(e){return new dr(this,e)};C.prototype.rollingSum=function(e){return new wr(this,e)};C.prototype.rollingStd=function(e){return new _r(this,e)};C.prototype.rollingMin=function(e){return new yr(this,e)};C.prototype.rollingMax=function(e){return new Sr(this,e)};C.prototype.ewm=function(e){return new br(this,e)};C.prototype.over=function(...e){return new Gt(this,e)};C.prototype.orderBy=function(e,t="asc"){return new vr(this,e,t)};function $r(e){return Mt.fromRows(e)}export{rt as AggExpr,V as BitArray,L as BooleanColumn,_t as Column,j as ColumnNotFoundError,nn as CountAggExpr,sn as CountDistinctAggExpr,hr as CumCountExpr,ur as CumMaxExpr,ar as CumMinExpr,fr as CumProdExpr,cr as CumSumExpr,je as DType,Mt as DataFrame,We as DateAccessor,H as DateColumn,Ar as DateExprAccessor,pr as DiffExpr,Be as ErrorCode,C as Expr,cn as FirstAggExpr,x as Float64Column,F as FrameKitError,cs as GroupBy,A as IOError,lt as Int32Column,un as LastAggExpr,ke as LazyFrame,Ds as LazyGroupBy,an as ListAggExpr,on as MaxAggExpr,en as MeanAggExpr,rn as MinAggExpr,fn as ModeAggExpr,Ye as NamedExpr,gt as ObjectColumn,vr as OrderedWindowExpr,nt as ParseError,Gt as PartitionedWindowExpr,mr as PctChangeExpr,N as Series,ht as ShapeMismatchError,gr as ShiftExpr,ln as StdAggExpr,Pe as StringAccessor,kr as StringExprAccessor,we as SumAggExpr,Ae as ThenBuilder,wt as TypeMismatchError,q as Utf8Column,qs as WhenBuilder,rr as WindowDenseRankExpr,lr as WindowNtileExpr,ir as WindowPercentRankExpr,sr as WindowRankExpr,or as WindowRowNumberExpr,st as col,$r as df,Is as execute,K as lit,Es as optimize,Nr as when};
//# sourceMappingURL=browser-B9MCPMmA.js.map
